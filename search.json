[{"title":"ACTF2020密码学部分writeup","url":"/2020/06/05/ACTF2020密码学部分writeup/","content":"\n编写的项目文件请参考[链接]()。\n\n为了保护服务器的同时不给选手带来更多困难，密码学部分的交互题开了pow算力检测，我也提供了相应的pow算力运算解决样例，大家下载即可。\n\n#### 入门题\n\n##### Column Permutation Cipher：\n\n简单的矩阵换位密码，首先统计字段长度为625，由于题目中告诉我们是m*n举证换位，所以m,n的可能值是(5,125),(25,25),(125,5)，然后爆破即可，示例脚本: \n\n```python\n#-*- coding=UTF-8 -*-\npossiblelen=[5,25,125]\nfor k in possiblelen:\n    plaintext=\"\"\n    line=625//k\n    for i in range(k):\n        for j in range(line):\n            plaintext+=cipher[j*k+i]\n    print(plaintext)\n```\n\n##### 我的密码本: \n\n统计英文文本中每个字符的出现频率，并查找概率表进行对比。当然其中需要用到一些英文知识，一般这种题目语义都是连贯的，一定要注意最后解出来的明文语义上是否通顺。\n\n![image-20200529003238548](image-20200529003238548.png)\n\n如果你统计好词频并确定了明文-密文对以后，即可还原出原文。\n\n```python\ncode_book=\"ㅡ贰ㅒㄱёㄴ伍ㅊあムг肆ンㅇэ叁йΣωθξ壹ㅣのл￥\"\nplaintext=\"\"\nfor j in range(len(cipher)):\n    flag=0\n    for i in range(len(code_book)):\n        if(cipher[j]==code_book[i]):\n            plaintext+=str(chr(0x61+i))\n            flag=1\n    if(flag==0):\n        plaintext+=cipher[j]\nprint(plaintext)\n\n```\n\n#### 简单题\n\n##### bomb or boom：\n\n题目给出了5个压缩包文件和一个密码本，并告知我们5个压缩包只要破解4个就行。所以应该涉及到门限方案，这里虽然没有题目名，但是hint中给出来了，用的是bloom门限。这是一个（4,5）门限，消息被5个随机模数求模，得到a<sub>i</sub>和m<sub>i</sub>。并被封装在五个压缩包中。\n\n压缩包的密码被一些编码方式加密了，想了解这些编码方式请看[这里](https://www.cnblogs.com/mq0036/p/6544055.html)。\n\n下面稍微解释一下这些有趣的编码，第一个是培根，第二个盲文，第三个用的是千千秀字的文本转音符（大可搜索一下，如何把文本加密为音符，仅此一家，ps.看着音符的样子难道不好看嘛），第四个是aaencode（学过web应该都知道的吧），第五个是brainfuck，参考一下资料即可。\n\n然后用门限方案的脚本直接跑，就可以辽：\n\n```python\nimport math\nfrom Cryptodome.Util.number import *\nimport gmpy2\ndef re(w1,m1):#乘法逆\n\tt1=w1\n\tt2=m1\n\ti=0\n\ts=[]\n\twhile(t1):\n\t\ty=t2%t1\n\t\ts.append(int(t2//t1))\n\t\tt2=t1\n\t\tt1=y\n\tre1= 0\n\tre2= 1\n\ti=len(s)-2\t\n\twhile(i>=0):\n\t\tt=re2\n\t\tre2=re1*1-re2*s[i]\n\t\tre1=t\n\t\ti-=1\n\treturn re2\ndef debloom(k):\n    x=[]\n    m=[]\n    for i in range(0,k):\n        print(\"inputs x\"+str(i+1)+\" and m\"+str(i+1)+\":\")\n        x.append(int(input()))\n        m.append(int(input()))\n    Mn=1\n    for i in range(0,k):\n        Mn=Mn*m[i]\n\n    w=[]\n    for i in range(0,k):\n        w.append(int(Mn//m[i]))\n    t=[]\n    for i in range(0,k):\n        t.append(re(w[i],m[i]))\n    result=0#初始化\n    for i in range(0,k):\n        result+=(w[i]*t[i]*x[i])\n    result=result%Mn\n    print(long_to_bytes(result))\n\nprint(\"input bloom k:\")\nk=int(input())\ndebloom(k)\n\n```\n\n运行结果：\n\n![解密图片](解密图片.png)\n\n##### naive encryption:\n\n一道改装后的仿射密码题，只不过采用了不同的a,b进行了更多的轮加密，所以说这道题目更像是算法逆向。关键知识是乘法逆。解题脚本如下：\n\n```python\nfrom Cryptodome.Util.number import *\n\ndef inv(u,v):\n    u3,v3=u,v\n    u1,v1=1,0\n    while v3>0:\n        q=u3//v3\n        u1,v1=v1,u1-v1*q\n        u3,v3=v3,u3-v3*q\n    while u1<0:\n        u1=u1+v\n    return u1\n    \n\nk=[3,5,7,11,13,17,19,23,29,31,37,\n    41,43,47,53,59,61,67,71,73,79,\n    83,89,97,101,103,107,109,113,\n    127,131,137,139,149,151,157,\n    163,167,173,179,181,191,193,\n    197,199,211,223,227,229,233,\n    239,241,251]\nn=1000\nlen_k=len(k)\ncipher=[71, 37, 4, 242, 109, 227, 22, 207, 36, 5, 39, 87, 22, 155, 19, 5, 19, 36, 155, 36, 224, 2, 104, 155, 39, 2, 19, 241, 155, 70, 210, 241, 53, 5, 19, 39, 22, 70, 22, 210, 70, 75]\n\nflag=0\nlen_cipher=len(cipher)\nwhile(n>0):\n    pointer=1001-n\n    for i in range(len_cipher):\n        #cipher[i]=(cipher[i]*k[((pointer+2)%len_k]+k[(pointer*7)%len_k])&0xff\n        cipher[i]=((cipher[i]-k[(pointer*7)%len_k])*inv(k[(pointer+2)%len_k],0x100))&0xff\n    n=n-1\nfor i in range(0,len_cipher):\n    flag+=cipher[i]\n    flag=flag<<8\nflag=flag>>8\nprint(long_to_bytes(flag))\n\n```\n\n##### naive rsa：\n\n本来这道题目我已经出好推送想送分的，但不料推送还没轮到我，所以没发出来，希望大家多多支持“中南极光网安实验室”的公众号，支持痛并快乐着的作品。\n\n回到题目，这是一道简单的coppersmith，主要问题出在getPrime函数和给出的p%q上。p是520位素数，q是500位素数，所以p//q就在2<sup>19</sup>到2<sup>21</sup>之间，我们假设p//q=k，p%q=a，那么p=kq+a，那么我们只需要在2<sup>19</sup>到2<sup>21</sup>之间爆破k即可，脚本如下：\n\n```python\nimport gmpy2\nfrom Cryptodome.Util.number import *\na=int(input())\nN=int(input())\nc=int(input())\ne=65537\nfor k in range(2**19,2**21):\n    #print(gmpy2.iroot(k*k+4*N, 2)[0])\n    q = (-a + gmpy2.iroot(a*a+4*k*N, 2)[0])//(2*k)\n    p = k*q+a\n    #print(k)\n    if(p*q==N):\n        #print (k)\n        phi = (p-1)*(q-1)\n        d = gmpy2.invert(e,phi)\n        m = pow(c,d,N)\n        print (long_to_bytes(m))\n        break\n\n```\n\n#### 中等题\n\n##### Imitation game：\n\n由于在密码学实验期间，我发现基本没有同学完成mtp的实验，所以在这里稍微加深了一下mtp以后形成了新的题目。这道题目和一般的mtp的区别就是，这里对密钥进行了类似于CBC的块加密，代码如下：\n\n```python\ndef encrypt(iv,message):\n    padding=[iv]   \n    cipher=[message[0]^padding[0]]\n    for i in range(1,len_flag):\n        #print(cipher)\n        padding.append(cipher[i-1]^padding[i-1])\n        cipher.append(message[i]^padding[i])\n    print(\"cipher={}\".format(cipher))\n```\n\n但是由于初始iv范围很小，而且它嵌入到了密钥的每一个字节中，所以我们只需要爆破iv就可以得到明文。甚至我们可以知道密钥最后一位是\"}\"，直接与mtp后得到的密钥异或就知道iv值了。然后整个密钥每个字节异或iv就得到明文。\n\n而对于mtp，题目中已经给出，密文都来自于书本原句，即可见字符，那么我们只需要通过限定课件字符的范围就可以排除很多无关答案。这里推荐python的mtp包，效果很棒，运行截图如下：\n\n![样例-得到的key每一位异或0xab即可](样例-得到的key每一位异或0xab即可.png)\n\n得到的key不是最后的key，但是0xd6^b'}'=0xab，所以对每一位异或0xab即可得到明文。\n\n##### naive aes：\n\n又是一道算法逆向题，但是这里主要考察的是S盒和P盒的逆向。\n\nfrom： [nactf——Super Duper AES](https://ctftime.org/task/9330 )\n\nwriteup: [detail link]( https://seymour.hackstreetboys.ph/chals/ctf/2019_NACTF/crypto/5_Super_Duper_AES.html )\n\nall you need is to:\n\n1.Reverse the **permute()** function.\n\n2.Reverse the **substitute()** function.\n\n3.Put everything together and run the script.\n\nIsn't it easy?\n\n##### tiny_PRNG0:\n\n出题人：[DJ](csuwangj.github.io)\n\n出题人只给了我脚本，不过mt19937伪随机数预测最近的CTF题目很多，大家可以参考这个[博客](https://blog.wuhao13.xin/1245.html )。\n\n基本思想：根据输出的随机数逆向extract_number对应的状态，实际上只需要前624个随机数恢复前624个state，就可以预测此后生成的随机数。 脚本：\n\n1.mt19937.py\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\ndef inv_right_shift(v, b, m):\n    '\n        >>> from cryptonita.attacks.prng import inv_right_shift\n        >>> y, b, m = 524889969, 11, 0x010101\n        >>> v = y ^ ((y >> b) & m)\n        >>> inv_right_shift(v, b, m)\n        524889969\n        >>> y, b, m = 0xffffffff, 4, 0xffffffff\n        >>> v = y ^ ((y >> b) & m)\n        >>> inv_right_shift(v, b, m)\n        4294967295\n    '\n    assert 0 < b < 32\n\n    g = 0\n    i = 0\n    while i < 32:\n        g = v ^ ((g >> b) & m)\n        i += b\n\n    return g\n\ndef inv_left_shift(v, b, m):\n    '\n        >>> from cryptonita.attacks.prng import inv_left_shift\n        >>> y, b, m = 524889969, 3, 0x010101\n        >>> v = y ^ ((y << b) & m)\n        >>> inv_left_shift(v, b, m)\n        524889969\n        >>> y, b, m = 0xffffffff, 4, 0xffffffff\n        >>> v = y ^ ((y << b) & m)\n        >>> inv_left_shift(v, b, m)\n        4294967295\n    '\n    assert 0 < b < 32\n\n    g = 0\n    i = 0\n    while i < 32:\n        g = v ^ ((g << b) & m)\n        i += b\n\n    return g\n\ndef clone_mt19937(out):\n    '   Clone the internal state of a Mersenne Twister 19937 (MT19937)\n        from its output <out>.\n        For MT19937 we need 624 sequential bytes at minimum to clone\n        the state.\n            >>> from cryptonita.attacks.prng import clone_mt19937\n            >>> clone_mt19937(B('abc'))           # byexample: +norm-ws\n            Traceback <...>\n            ValueError: You need at least 624 bytes to clone the MT19937 PRNG\n                        but you have only 3.\n        With 624+n, the first 624 are used to clone the\n        MT19937's state and the next byte is used to validate.\n        If the validation fails, \"shift to the right one byte\": the first\n        byte is ignored, the next 624 bytes are used to re-clone the state\n        and the next byte is used to validate the generator.\n        The process continues until one validation success or until reach the\n        end of the string.\n        The last cloned MT19937 cannot be validated.\n        Given 624 bytes only, no validation is performed; given 624*2 bytes,\n        it is guaranteed that a valid clone can be found.\n        '\n\n    n = 624\n    if len(out) < n:\n        raise ValueError((\"You need at least %i bytes to clone the MT19937 PRNG\" +\\\n                          \" but you have only %i.\") % (n, len(out)))\n\n    u, d = 11, 0xffffffff\n    s, b = 7, 0x9d2c5680\n    t, c = 15, 0xefc60000\n    l = 18\n\n    state = []\n    for y in out:\n        y = inv_right_shift(y, l, 0xffffffff)    # inv of y ^ ((y >> l) & 0)\n        y = inv_left_shift(y, t, c)     # inv of y ^ ((y << t) & c)\n        y = inv_left_shift(y, s, b)     # inv of y ^ ((y << s) & b)\n        y = inv_right_shift(y, u, d)    # inv of y ^ ((y >> u) & d)\n\n        state.append(y)\n\n    found = False\n    i = 0\n    g = MT19937(0)\n    g.reset_state(state[i:i+n], index=n)\n\n    while i+n < len(out):\n        v = g.extract_number()\n        found = v == out[i+n]\n        if found:\n            g.reset_state(state[i:i+n], index=n)\n            break\n\n        i += 1\n        g.reset_state(state[i:i+n], index=n)\n\n    return g\n\n# https://en.wikipedia.org/wiki/Mersenne_Twister\nclass MT19937:\n    def __init__(self, seed):\n        w, n, m, r = 32, 624, 397, 31\n        a, f = 0x9908b0df, 1812433253\n        W = 0xffffffff\n        u, d = 11, 0xffffffff\n        s, b = 7, 0x9d2c5680\n        t, c = 15, 0xefc60000\n        l = 18\n\n        # Create a length n array to store the state of the generator\n        self.MT = MT = [] # n size\n        self.index = n+1\n        lower_mask = (1 << r) - 1\n        upper_mask = (~lower_mask) & W\n\n        # Initialize the generator from a seed\n        index = n\n        MT.append(seed)\n        for i in range(1, n):\n            MT.append((f * (MT[i-1] ^ (MT[i-1] >> (w-2))) + i) & W)\n\n\n        # Generate the next n values from the series x_i\n        def twist():\n            for i in range(n):\n                 x = (MT[i] & upper_mask) \\\n                           + (MT[(i+1) % n] & lower_mask)\n\n                 xA = x >> 1\n                 if (x % 2) != 0:  # lowest bit of x is 1\n                     xA = xA ^ a\n\n                 MT[i] = MT[(i + m) % n] ^ xA\n\n            self.index = 0\n\n        # Extract a tempered value based on MT[index]\n        # calling twist() every n numbers\n        def extract_number():\n            while 1:\n                if self.index >= n:\n                    twist()\n\n                y = MT[self.index]\n                y = y ^ ((y >> u) & d)\n                y = y ^ ((y << s) & b)\n                y = y ^ ((y << t) & c)\n                y = y ^ (y >> l)\n\n                self.index += 1\n                yield y & W\n\n        self.extract_number = extract_number\n\n    def reset_state(self, MT, index=0):\n        assert len(MT) == len(self.MT)\n\n        self.index = index\n        if not (0 <= self.index <= len(MT)):\n            raise IndexError(\"Setting index=%i is out of range\" \\\n                    % (self.index))\n\n        self.MT[:] = MT\n\n    def __iter__(self):\n        return self.extract_number()\n```\n\n2.exp.py\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom sys import argv\nfrom typing import List\nfrom tqdm import tqdm\nfrom mt19937 import clone_mt19937\nimport re \nfrom pwn import (\n    process,\n    remote,\n    log,\n    # context\n)\n# context.log_level = \"DEBUG\"\n\n\ndef get_output(io, size):\n    output = []\n    with tqdm(total=size) as bar:\n        while len(output) < size:\n            io.sendlineafter(\"> \", \"1\")\n            line = io.recvline().decode(\"utf-8\")\n            output += list(map(int, line.strip().split(\" \")))\n            bar.update(10)\n    bar.close()\n    return output\n\ndef main():\n    if len(argv) == 1:\n        io = process(\"./a.out\")\n    else:\n        io = remote(argv[1], int(argv[2]))\n    log.info(\"get output from mt19937\")\n    out = get_output(io, 640)\n    log.info(\"clone mt19937 from output\")\n    new_iter = iter(clone_mt19937(out))\n    io.sendline(\"2\")\n    log.info(\"send answer\")\n    io.sendline(str(next(new_iter)))\n    s = str(io.recvuntil(\"4) \"))\n    s = str(io.recvuntil(\"4) \"))\n    log.success(re.search(\"ACTF{.*}\", s).group(0))\n\nif __name__ == \"__main__\":\n    main()\n```\n\n#### 难题\n\n##### DLP头号玩家：\n\n这道题主要是想考察离散对数问题，设计的考点有：如何计算离散对数，ElGamal算法，ecc算法。\n\nlevel1:计算离散对数\n\n采用大步小步法即可。\n\nlevel2：ElGamal算法\n\n首先，这里的密钥是两个字节的（见下面代码），可以直接考虑爆破：\n\n```python\nd=bytes_to_long(message[0:2])\n```\n\n然后根据密钥进行ElGamal算法解密即可。\n\nlevel3：ECC算法\n\n先回顾一下ECC算法\n\n![1](1.png)\n\n这里我在具体代码中做了一些手脚，令k=100,d=100，把100当成常量嵌入到了kG的运算中，所以其实解密的时候只需要代入d=100,k=100即可。\n\n解题脚本示例如下(省略交互)：\n\n```python\nfrom math import ceil,sqrt\nfrom Cryptodome.Util.number import *\nfrom ecc import get_inverse,get_gcd,get_np,get_ng\ndef bsgs(g, y, p):\n    res = []\n    m = int(ceil(sqrt(p - 1)))\n    S = {pow(g, j, p):j for j in range(m)}\n    gs = pow(g, p - 1 - m, p)\n    for i in range(m):\n        if y in S:\n            res.append(i * m + S[y])\n        y = y * gs % p\n    return res\n\ndef get_inverse(u,v):\n    u3,v3=u,v\n    u1,v1=1,0\n    while v3>0:\n        q=u3//v3\n        u1,v1=v1,u1-v1*q\n        u3,v3=v3,u3-v3*q\n    while u1<0:\n        u1=u1+v\n    return u1\n\n#level1\np=5391644857\ng=2\nc1=[4908063849,1283736637,4385640372,428852363]\nfor i in range(len(c1)):\n    inp=c1[i]\n    c=int(inp)\n    res=bsgs(g,c,p)\n    for i in res:\n        print(long_to_bytes(i))\n\n#level2\ne,g,p=(2685568775701283525351462610033561666387306287538522499134808519515971408889570947875407095838440735098786110848850070468375238474921045086123009358906,\n       2,\n       3108147961599785276150798080269087679501293709501455568774725039866085754219397531303169017523045103124751042601841840328290404343235853405579539233773)\na,b=(1968486588460454870108621075441203470309302694739442500606039058477890260262954690597523764122825500774397066089804125306327432806567312924827814647950,\n     1024812622664084668424411594448713407303536660751692688061972897584163822765150299422248209733371319297760175591974882337903320853550670045641950256872)\n       \nfor i in range(2**16):\n    if(pow(g,i,p)==e):\n        print(long_to_bytes(i))\n        d=i\ninv=get_inverse(a,p)\nm2=(b*pow(inv,d,p))%p\nprint(long_to_bytes(m2))\n\n#level3\ncipher=[[414,131,27744],\n        [249,291,27612],\n        [26,255,26656],\n        [452,278,31968],\n        [78,308,17034],\n        [319,33,15400],\n        [598,457,51200],\n        [310,478,2695],\n        [307,739,5500],\n        [397,455,89500]\n        ]\np=769\na=23\nb=711\n\nkey=100\nk=100\nfor ci in cipher:\n    kG=[0,0]\n    kG[0],kG[1]=get_ng(ci[0], ci[1] , k, a, p) \n    decrypto_text_x,decrypto_text_y = get_ng(kG[0], kG[1] , key, a, p)\n    print(chr(ci[2]//decrypto_text_x),end=\"\") \n```\n\n##### tiny_PRNG1：\n\n出题人：[DJ](csuwangj.github.io)\n\n主要是对xoroshiro128plus随机数发生器，[参考资料](https://github.com/lemire/crackingxoroshiro128plus/blob/master/xoroshiftall.py )\n\n需要对next函数进行逆向，然后用z3求解种子。\n\n直接放解题脚本：\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\nimport sys, z3\nfrom sys import argv\nfrom typing import List\nfrom pwn import (\n    process,\n    remote,\n    log,\n    # context\n)\nfrom Crypto.Util.number import long_to_bytes\n# context.log_level = \"DEBUG\"\nbit64 = 0xffffffffffffffff\n\ndef LShL(x, n): return (x << n) & bit64\n\ndef xo128(x, y, LShR = lambda x,i: x>>i):\n    y ^= x\n    return y ^ LShL(y, 14) ^ (LShL(x,55)|LShR(x,9)), (LShL(y,36)|LShR(y,28))\n\ndef get_output(io, size):\n    output = []\n    with tqdm(total=size) as bar:\n        while len(output) < size:\n            io.sendlineafter(\"> \", \"1\")\n            line = io.recvline().decode(\"utf-8\")\n            output += list(map(int, line.strip().split(\" \")))\n            bar.update(10)\n    bar.close()\n    return output\n\ndef main():\n    if len(argv) == 1:\n        io = process(\"./a.out\")\n    else:\n        io = remote(argv[1], int(argv[2]))\n    log.info(\"get output\")\n    out = get_output(io, 10)\n    x0, y0 = z3.BitVecs('x0 y0', 64)\n    x, y = x0, y0\n    s = z3.SimpleSolver()\n    \n    for v in out:\n        s.add((x + y) & bit64 == v)\n        x, y = xo128(x, y, z3.LShR)\n    \n    ans = []\n\n    for i in range(1, sys.maxsize):\n        if s.check().r != 1: break  # quit if failed\n        soln = s.model()\n        x, y = (soln[i].as_long() for i in (x0,y0))\n        ans += [\"ACTF{\" \n            + long_to_bytes(x).decode(\"utf-8\")[::-1]\n            + long_to_bytes(y).decode(\"utf-8\")[::-1]\n            + \"}\"]\n        for j in range(10):\n            x, y = xo128(x, y)\n        s.add( z3.Or(x0 != soln[x0], y0 != soln[y0]) )\n    \n    for a in ans:\n        log.info(\"possible flag: \" + a)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n","tags":["project"],"categories":["project"]},{"title":"GPT技术初探","url":"/2020/05/27/GPT技术初探/","content":"\n### 第一部分 引入 \n\n#### 1.概念\n\nGPT：Generative Pre-Training 生成式的预训练、\n\n#### 2.工作机制\n\nGPT也采用两阶段过程，第 一个阶段是利用语言模型进行预训练，第二阶段通过 Fine-tuning的模式解决下游任务。\n\n#### 3.GPT系列发布者\n\nopenai  说明文章请见 [GPT](https://openai.com/blog/language-unsupervised/ ) [GPT2](https://openai.com/blog/better-language-models/#sample1 )\n\n### 第二部分 GPT论文\n\n[原文链接](language_understanding_paper.pdf)\n\n#### 1.摘要\n\n##### （1）背景\n\n 大多数深度学习方法都需要大量的标注数据，在NLP领域中也是如此，但是标注数据毕竟是稀少的，大部分数据肯定还是非标注数据。\n\n标注数据[参考文章](http://www.woshipm.com/pd/856172.html ) ： 类比机器学习，我们要教他认识一个苹果，你直接给它一张苹果的图片，它是完全不知道这是个啥玩意的。我们得先有苹果的图片，上面标注着“苹果”两个字，然后机器通过学习了大量的图片中的特征，这时候再给机器任意一张苹果的图片，它就能认出来了。 \n\n那碰到非标注数据该怎么办?\n一种解决办法就是pre-training。 其实词向量就是一种pre-training技术，通过语言模型将文本转化为数字表示。\n\n##### （2）方案\n\n在优化期间使用任务感知输入转换来实现有效的传输，同时要求对模型架构进行最小的更改。\n\n解释： 论文提出的主要是一种半监督的学习方法：非监督的预训练和监督的fine-tuning。  generative pre-training主要应用于无标记文本，在fine-tuning的时候使用了task-aware的方法，并且使模型的变化最小的前提下获得有效的转化。 \n\n##### （3）效果\n\n 模型在常识推理（Stories Cloze Test）上获得8.9％的绝对改善，在问答（RACE）上达到5.7％，在文本蕴涵（MultiNLI）上达到1.5％。 \n\n#### 2.Related Work\n\n##### （1）词嵌入及其好处\n\n略，详见课件。\n\n##### （2）无监督学习\n\n无监督学习是一种特殊的半监督学习，其目标是找到一个好的初始化点，而不是修改监督学习目标。可以使用语言建模目标对神经网络进行预训练，然后在监督下根据目标任务对其进行优化。\n\n##### （3）辅助训练目标\n\n增加辅助的无监督训练目标是半监督学习的另一种形式。用来来改进语义角色标记。\n\n#### 3.Framework\n\nOpenAI 的系统分为两阶段，首先研究者以无监督的方式在大型数据集上训练一个 Transformer，使用语言建模作为训练信号，然后在小得多的模型上精调解决具体任务。 \n\n ![img](https://pic4.zhimg.com/80/v2-e485cfb6b87b4fa65565c704f52f05a7_720w.jpg)\n\n左图：Transfromer进行预训练。\n\n右图：输入转换，用于对不同任务进行fine-tuning（精确调整）。我们将所有结构化输入转换成标记序列，然后由我们的预训练模型进行处理，然后是linear+softmax层。\n\n##### （1）第一阶段： **非监督预训练** \n\n   1）介绍\n\n模型的一般方法是用语言模型去极大化极大似然函数。 在输入的文本上使用*multi-head-self-attention*(Bert中也有用到)，之后使用包含位置信息的前馈神经网络，输出的是各个词的概率分布 。 \n\n   2）特点（和ELMO相比）\n\n首先，特征抽取器不是用的RNN，而是用的[Transformer](https://arxiv.org/abs/1706.03762 )叠加的“自注意力机制” 构成的深度网络）。\n\n评价：Transformer的特征抽取能力要强于RNN，这个选择是很明智的。\n\n其次，GPT的预训练虽然仍然是以语言模型作为目标任务， 但是采用的是单向的语言模型。\n\n\"单向\"的概念：GPT只采用Context-before（上文）来进行预测。\n\n##### （2）第二阶段：监督微调\n\n   1）介绍\n\n对前一个阶段训练出来的模型参数进行微调，以适应当前的监督型任务。 假设我们有带标签的数据集*C，* 经过我们的预训练模型在输入上的迭代之后，获得输出向量 ，然后经过线性层和softmax得到预测标签。  \n\n左图中\n\n   2）步骤\n\n首先，对于下游任务来说，需要把任务的网络结构改成和GPT的网络结构一 样。\n\n其次，利用第一步预训练好的参数初始化GPT的网络结构，把通过预训练学到的语言学知识引入到任务里来。\n\n再次，用手头的任务去训练这个网络，对网络参数进行 Fine-tuning，使得这个网络更适合解决手头的问题。\n\n##### （3）特殊任务的输入变换\n\n对于特定的任务比如文本分类，我们能够直接使用上面的模型，因为文本分类的标签是确定的，正好对应论文的使用场景。由于文中的模型处理的是序列化的文本，对于问答系统或文本蕴含问题就需要手动修改文本格式、问题以及答案。 \n\n   1）文本蕴含\n\n用$连接前后两个文本，即前提p和假设h。\n\n   2）相似度\n\n由于两个文本内部没有先后顺序，对此我们可以输入两个句子Text1$Text2和Text2$Text1，将结果用element-wise的方式相加起来，再放进线性输出层中。\n\n   3）问答系统和常识推理\n\n对于这类问题一般有Context、Question和Answer{a1,a2,...,an},可以组合n个问答对(Context_i,Question_i,$,ai)，获得n个输出，再将其通过linear层后softmax输出。\n\n#### 4.效果和不足之处\n\n##### （1）效果\n\nGPT的效果是非常令人惊艳的，在12个任务里，9个达到 了最好的效果，有些任务性能提升非常明显。\n\n##### （2）不足之处\n\n模型训练计算要求大： 以前许多用于NLP任务的方法都从头开始在单个GPU上训练相对较小的模型。我们的预培训步方需要8个GPU上进行1个月。\n\n通过文本学习世界的局限性和片面性：最近的工作表明，仅通过文本就很难学习某些类型的信息，而其他工作表明，模型可以学习和利用数据分布中的偏差。\n\n特征概括能力依然不足：尽管我们的方法可以提高各种任务的性能，但是当前的深度学习NLP模型仍然表现出令人惊讶和违反直觉的行为-尤其是在以系统，对抗或分布外的方式进行评估时。\n\nGPT使用单向语言模型是个不好的选择，它没有把单词的下文融合进来，这限制了其在更多应用场景的效果。比如阅读理解，在做任务的时候是可以允许同时看到上文和下 文一起做决策的，如果预训练时候不把单词的下文嵌入到 Word Embedding中，是很吃亏的，白白丢掉了很多信息。\n\n#### 5.GPT项目\n\n[项目链接](https://github.com/openai/finetune-transformer-lm)\n\n### 第三部分 GPT2\n\n[openai链接](https://openai.com/blog/better-language-models/#sample1)\n\n#### 1.GPT2模型简介\n\n我们的模型称为GPT-2（是GPT的继承者），仅经过训练即可预测40GB的互联网文本中的下一个单词。由于我们担心该技术的恶意应用，因此我们不会发布经过训练的模型。作为负责任公开的一项实验，我们将发布一个供研究人员进行实验的小得多的模型以及一份技术论文。\n\n#### 2.GPT-2的训练目标\n\nGPT-2是基于大型transformer的语言模型，具有15亿个参数，并在<u>非常高质量的</u>数据集上进行了训练800万个网页。根据文本中的所有先前单词，预测下一个单词。数据集的多样性使这个简单的目标包含了跨不同领域的许多任务的自然发生的演示。GPT-2是GPT的直接扩展，具有超过10倍的参数，并接受了超过10倍的数据量训练。\n\n#### 3.GPT-2的效果\n\nGPT2显示了广泛的功能，包括生成具有空前质量的条件合成文本样本的能力，我们在模型中使用输入来填充模型并让其生成冗长的延续。此外，GPT-2优于其他在特定领域（如Wikipedia，新闻或书籍）上训练的语言模型，而无需使用这些特定于领域的训练数据集。在诸如答疑，阅读理解，总结和翻译之类的语言任务上，GPT-2开始使用原始文本来学习这些任务，而没有使用特定于任务的训练数据。尽管这些下游任务的得分远非最新，但它们表明，只要有足够的（未标记）数据和计算，这些任务就可以从无监督的技术中受益。\n\n##### （1）答疑\n\n![image-20200527165249559](image-20200527165249559.png)\n\n##### （2）文本填充\n\n![image-20200527165550265](image-20200527165550265.png)\n\n##### （3）文章内容概括总结\n\n![image-20200527165902886](image-20200527165902886.png)\n\n##### （4）翻译\n\n![image-20200527165928137](image-20200527165928137.png)\n\n##### （5）阅读理解\n\n![image-20200527170248695](image-20200527170248695.png)\n\n[4.GPT2论文](language-models.pdf)  \n\n[5.GPT2项目](https://github.com/openai/gpt-2 )\n\n### 第四部分 特别鸣谢\n\n[openai项目组](https://openai.com )\n\n李芳芳,中南大学\n\n[蔡杰 ,北京大学:论文研读之OpenAI-Generative Pre-Training](https://zhuanlan.zhihu.com/p/52775384 )\n\n","tags":["study"],"categories":["study"]},{"title":"通过python脚本自动插入汇编反调试代码","url":"/2020/05/20/通过python脚本自动插入混淆代码的一种基本示例/","content":"\n### 研究背景\n\n在之前OLLVM项目的研究过程中，我们发现反调试技术对反混淆脚本有一定的干扰作用，如果可以在OLLVM的中间代码中自动化插入反调试代码，那么就可以给OLLVM的代码混淆增加一层保障。\n\n### 方案分析\n\n探讨多种方案以后，我认为最适合在汇编代码中进行代码嵌入，原因如下：\n\n1.首先，在C语言或者LL层的高级语言中，存在比较复杂的括号和分支语句，代码有可能错误的嵌入。\n\n2.其次，反调试代码主要是以汇编语言为主，所以选择越底层的语言嵌入越好。\n\n但是在汇编代码中的嵌入依然存在很大的问题：\n\n1.我们要确定汇编程序的代码段，而且要把函数进行划分，甚至要划分出，在一个基本块或函数之内进行代码嵌入。\n\n2.汇编代码中存在比较多的分支和跳转，混淆代码的插入可能会破坏原程序流程。\n\n3.有些混淆代码并不是连续的，而且包含跳转语句，因此嵌入时需要对上下文的语义进行分析。\n\n### 初步脚本\n\n选择一种最简单的嵌入形式，即假设已经确定需要嵌入的代码段，处理完分支和跳转，而且嵌入的代码是连续的，那么只需要直接完成嵌入工作即可。于是用python写出一个样例脚本模拟OLLVM的工作：\n\n```python\n#conding=utf-8\nfrom Cryptodome.Util.number import *;\n\ncode=[\"          .byte 0x80 ;auto insert\\n\",\n      \"          int 3 ;auto insert\\n\",\n      \"          rdtsc ;auto insert\\n\"]\n\nn=int(input(\"请输入需要插入的代码段的数量：\"))\nwith open(\"Code.asm\",\"r\") as f:\n    strr=[]\n    while(True):\n        line=f.readline()\n        if not line:\n            break\n        strr.append(line)\nfor i in range(n):\n    index=getRandomRange(1,len(strr))\n    cindex=getRandomRange(0,3)\n    strr.insert(index,code[cindex])\nwith open(\"output.asm\",\"w\") as o:\n    for i in range(len(strr)):\n        o.write(strr[i])\n    \n```\n\n### 运行效果\n\n假设有下面这样的汇编文件Code.asm：\n\n```asm\nstart:\n           push ds\n           mov ax,0\n           push ax\n\t   mov ax,data\n           mov ds,ax\n           mov es,ax\n           cld \n           lea di,nametab\na20loop:\n\t   call b10read\n           cmp namelen,0\n           jz a30\n           cmp namectr,30\n           je a30\n           call d10stor\n           jmp  a20loop\na30:\n          cmp namectr,1\n          jbe a40\n        ; call  g10sort\n          call  k10disp \na40:\n          mov ah,4ch\n          Int  21h\nb10read  proc  near\n          mov  ah,09h\n          lea dx ,messg1\n          int  21h\n          mov ah,0ah\n          lea dx,namepar\n          int 21h\n          mov ah,09h\n          lea dx,crlf\n          Int  21h\n          mov  bx,0\n          mov bl ,namelen\n          mov cx,21\n          sub cx,bx\nb20: \n          mov namefld[bx],20h\n          inc bx\n          loop b20\n          ret            \nd10stor  proc  near\n          inc namectr\n          cld\n          lea si , namefld\n          mov cx,10\n          rep movsw\n          ret\ng10sort  proc near\n          sub  di ,40\n          mov endaddr,di\ng20:\n          mov swapped,0\n          lea  si,nametab\ng30:\n          mov cx,20\n          mov di,si\n          add di,20\n          add ax,di\n          mov ax,di\n          mov  bx,si\n          repe  cmpsb\n          jbe g40\n          call h10xchg\ng40:      mov si,ax\n          cmp swapped,0\n          jnz  g20\n          ret\nh10xchg   proc  near\n          mov cx,10\n          lea di , namesav\n          mov si,bx\n          rep  movsw\n          mov cx,10\n          mov di,bx\n          rep movsw\n          mov cx ,10\n          lea si,namesav\n          rep   movsw\n          mov swapped,1\n          ret\nk10disp   proc  near\n          mov ah,09\n          lea  dx,messg2\n          int 21h\n          lea  si,nametab\nk20:    \n          lea di,namesav\n          mov cx,10\n          rep movsw\n          mov ah,09\n          lea dx, namesav\n          int 21h\n          dec namectr\n          jnz  k20\n          ret\n```\n\n运行后得到的output.asm如下：\n\n```assembly\nstart:\n           push ds\n           mov ax,0\n           push ax\n\t   mov ax,data\n           mov ds,ax\n           mov es,ax\n           cld \n           lea di,nametab\na20loop:\n\t   call b10read\n           cmp namelen,0\n           jz a30\n           cmp namectr,30\n           je a30\n           call d10stor\n           jmp  a20loop\na30:\n          cmp namectr,1\n          jbe a40\n        ; call  g10sort\n          call  k10disp \na40:\n          mov ah,4ch\n          Int  21h\nb10read  proc  near\n          mov  ah,09h\n          lea dx ,messg1\n          int  21h\n          mov ah,0ah\n          lea dx,namepar\n          int 21h\n          mov ah,09h\n          lea dx,crlf\n          Int  21h\n          mov  bx,0\n          mov bl ,namelen\n          int 3 ;auto insert\n          mov cx,21\n          sub cx,bx\nb20: \n          rdtsc ;auto insert\n          mov namefld[bx],20h\n          inc bx\n          loop b20\n          ret            \n          rdtsc ;auto insert\nd10stor  proc  near\n          inc namectr\n          cld\n          int 3 ;auto insert\n          lea si , namefld\n          mov cx,10\n          rep movsw\n          rdtsc ;auto insert\n          ret\ng10sort  proc near\n          rdtsc ;auto insert\n          sub  di ,40\n          mov endaddr,di\ng20:\n          mov swapped,0\n          lea  si,nametab\ng30:\n          mov cx,20\n          mov di,si\n          int 3 ;auto insert\n          add di,20\n          .byte 0x80 ;auto insert\n          add ax,di\n          mov ax,di\n          mov  bx,si\n          repe  cmpsb\n          jbe g40\n          call h10xchg\ng40:      mov si,ax\n          cmp swapped,0\n          jnz  g20\n          ret\nh10xchg   proc  near\n          mov cx,10\n          lea di , namesav\n          mov si,bx\n          rep  movsw\n          mov cx,10\n          mov di,bx\n          rep movsw\n          mov cx ,10\n          lea si,namesav\n          rep   movsw\n          .byte 0x80 ;auto insert\n          mov swapped,1\n          ret\nk10disp   proc  near\n          mov ah,09\n          lea  dx,messg2\n          int 21h\n          lea  si,nametab\nk20:    \n          int 3 ;auto insert\n          lea di,namesav\n          mov cx,10\n          rep movsw\n          mov ah,09\n          lea dx, namesav\n          int 21h\n          dec namectr\n          jnz  k20\n          ret\n```\n\n初步实现了嵌入功能。\n\n---\n\n2020520 愿所有关心我的人都能被温柔相待，愿世间所有人都能乐观阳光积极向上。特别感谢我的父母一直含辛茹苦地哺育着我，我爱你们。","tags":["project"],"categories":["project"]},{"title":"答辩顺序抽签小程序","url":"/2020/05/14/答辩顺序抽签小程序/","content":"\n最近比较喜欢动手编写小程序和脚本。晚上有同学和我讨论对答辩队伍进行公平抽签的方案，所以打算编写一个很简单的小脚本，并做到尽量减少计算量。\n\n#### 脚本思路\n\n按照一定根据给各个队伍排序，然后初始化抽签序号池，每次随机获取池内的一个值，交给其中一支队伍，被使用的值从抽签序号池扔掉\n\n#### 代码\n\n```python\nimport random\n\nteam=100000\n\nnumpool=[]\norderpool=[]\n\nfor i in range(1,team+1):\n    numpool.append(i)\n\nwhile(team):   \n    rand=random.randint(0,team-1)\n    orderpool.append(numpool[rand])\n    del numpool[rand]\n    team-=1\n\nprint(orderpool)\n```\n\n#### 运行效果\n\n可在5s内完成300000支队伍的排序。\n\n#### 感想\n\n从python代码来看，我认为已经做到了最优化。但不知道del函数的实现方式会不会导致一些不必要的耗时。以后有机会当采用C语言来编写。","tags":["project"]},{"title":"课堂记录小助手","url":"/2020/05/07/课堂记录小助手/","content":"\n作为一名课代表，我需要每天记录同学在QQ群的签到和回答问题情况。开始我是直接把记录复制到word里面手动提取有用的消息，最后我决定解放双手编写一个自动化处理脚本。\n\n#### 这个脚本需要一些什么功能呢？\n\n1.最基础的，就是从漫长的聊天记录中提取专业，班级，姓名等信息。\n\n2.然后就是要进行去重操作，要不老师一个个对照打勾会比较困难。\n\n#### 如何处理？\n\n1.首先让同学们按照“专业-班级-姓名”的顺序修改好群名片以后，通过观察我发现他们的名片里面都有“170”这个字符串。所以可以提取到发言记录中人名的那一行。\n\n2.若是发言记录，后面会附上一个10个字符的时间，把这个去掉即可。\n\n3.对新记录进行存储，输出。若该记录和已有的内容重复则不输出。\n\n#### 代码\n\n```python\n#-*-coding=UTF-8-*-\n\nf=open(\"record.txt\",encoding='utf-8')\noutput=[]\nfor line in f.readlines():\n    if \"170\"in line:\n        subline=line[:-10]\n        if(subline not in output):\n            output.append(subline)\n            print(subline)\n\n```\n\n\n\n#### Todo:\n\n1.如果我能拿到班级名单的话，应该可以通过excel自动化生成到课情况和答疑情况，并进行适当标注。\n\n2.存在一些错误的识别情况，例如“xxx撤回了一条消息”，“@xxx”。但是这些现象比较罕见，没必要为此提高计算复杂度。所以在最终记录后还需要少量人工处理。\n\n#### 5.19更新\n\n改进了错误识别情况，成功去掉“xxx撤回了一条消息”的“@xxx”的无效记录。\n\n```python\n#-*-coding=UTF-8-*-\n\nf=open(\"record.txt\",encoding='utf-8')\noutput=[]\nfor line in f.readlines():\n    if \"170\"in line:\n        if('@' in line):\n            continue\n        if('撤回了一条消息' in line):\n            continue\n        if(':' in line):\n            subline=line[:-10]\n        else:\n            subline=line[:-1]\n        if(subline not in output):\n            output.append(subline)\n            print(subline)\n\n```\n\n","tags":["project"]},{"title":"基于门限方案的条形码保密及容错技术","url":"/2020/04/30/基于门限方案的条形码保密及容错技术/","content":"\n关键词：门限方案，条形码保密，条形码容错，条形码认证与防伪造。\n\n经历过初期两个小项目的探索，我们项目团队积累了一定的项目研究经验，在老师和16级学长的帮助下，我们把研究方向转到了门限方案的实际应用上。结合市面上用9张合并的条形码提高条形码的容错能力的操作，我们在保留一定的容错能力的基础上提高条形码的安全性，具体而言就是条形码的保密性和容错能力。\n\n### 背景\n\n依托于信息技术和电子商务的发展，条码技术，作为当今十分流行的一种自动识别与数据采集技术，在商品流通领域被广泛应用。但是在身份识别等应用场景下，传统的条形码不仅易被他人伪造，而且容易导致信息泄露；在恶劣的生产环境中，传统的条形码极有可能因污染损坏导致误读甚至无法识别；此外，常有因传统条形码被覆盖、遮挡或内装物品的安放而造成的条形码弯曲，扫描器无法识别的情况。因此，传统条形码的保密性显得不足，可靠性受到考验。人们急需冗余度高且具有保密能力的条形码，以及在此基础上的自动化扫码系统的大规模使用。\n\n### 主要问题\n\n目前传统的一维条形码的使用范围依然很广。 一维条形码的应用可以提高信息录入的速度，减少差错率，而且标签简单实用易于制作，成本几乎为零。但是一维码的设计从未考虑到保密性和防伪造的问题，以至于所有的消息用手机一扫就明文可见，并且输入同样的明文就可以产生相同的条形码。而且，对于所有条形码而言，冗余度低，破损后无法识别的问题普遍存在。\n\n同时，几乎所有的条形码都面临一个问题——冗余度为0，破损或污染以后即无法识别。\n\n### 解决方案\n\n针对传统一维条形码中存在的冗余度的问题，一些企业把条码重复拼接，以提高条形码的冗余度。这种做法的确大大的提高了条形码的冗余度和可靠性，值得肯定。但是在条码无一例外的重复的同时，我们是否能做一件手到拈来的事情呢？我们可以通过在重复的条形码中加入一些门限方案以及验证条形码，在保证条码可靠性的基础上，顺势达到保密性和防伪造的作用。\n\n为解决以上问题，本团队结合 shamir 门限方案与信息隐藏技术，在保障信息安全的基础上提出了基于门限方案的条形码容错与保密技术，旨在解决破损条形码无法扫描识别与传统条形码保密性差、易被伪造等信息安全问题，并且设计制作了一整套生成高保密新型条形码、读码的客户端软件——SaferBar。\n\n### 实现原理\n\n本方案依托操作简易的手机APP——SaferBar，可以根据客户需求将传统条形码转换成不同冗余度的门限条形码，极大地提高了条形码的容错率与保密性。另外，我们在原有明文的基础上拼接条形码的认证密钥，以达到防止伪造的效果。而且，基于图像识别技术，它同时采集处理多个条形码信息，并同时识别含多个子条形码的新型条形码，提高扫码效率，实现传统条形码与新型条形码的无缝衔接，极大程度地提高了条形码的容错率，防止了信息泄露和信息伪造，保障了商品财产及信息安全。具体流程如下：\n\n#### 生成认证密钥\n\nAPP为每一类商品都设置一个随机生成的认证密钥key，并上传存储在数据库中。通过字符串拼接在原有明文的基础上拼接条形码的认证密钥，以达到防止伪造的效果。解密的时候需要验证key的值是否正确，只有当key值正确时才连接数据库获取商品信息。  \n\n#### 编码与加密\n\n编码环节需要从多方面考虑来确定，如实际的信息量、所选条码的码数限制， 所载信息的可靠性与冗余量的相互取舍关系等。\n\n在条形码选择上，采用 CODE 39 码。这是一种双向扫描的非定长码，即条形码字符个数不是固定的，编码信息可以是数字也可以是大写英文字母码并自带校验码。条形码由九条不同的排列线条编码而得。基于信息冗余提高数据可靠性的思想，每段条形码的最后一位均附带上此条形码的校验位。\n\n生成门限条形码时，初始密钥x为原始的条形码编号。子密钥公式为：\n\n\nf (x)=m+a<sub>1</sub>x+a<sub>2</sub>x<sub>2</sub>+…+a<sub>k-1</sub>x<sub>k-1</sub> mod p\n\n\n以（5,9）型条形码为例：\n\n由（5,9）门限方案可知要将条形码分割成由九块条形码组成的门限条形码，n=9。\n扫描时只要扫描出5块完整内容就可能得到完整的数据，即门限值k=5。\n把编码 x 代入，依次可算出8个门限值yi=f(i),i=1-9；利用条形码换算公式，将 y<sub>1</sub>-y<sub>9</sub> 换算成对应的条形码，形成由九部分组成的门限条形码。如图：\n\n![image-20200430220542949](image-20200430220542949.png)\n\n#### 译码环节\n\n机器扫描门限条形码的过程中，将未被损坏的部分子条形码识别出来，将这些门限值y<sub>i </sub>代入拉格朗日，根据Shamir 的门限秘密共享方案的性质可知，最终一定能得出拼接后的条形码 x，其中包括商品编号以及认证密钥。  \n\n#### 服务器验证与商品信息显示\n\n在拼接后的条形码中获取认证密钥，发送到后端进行校验。服务器中数据库存储格式如下：\n\n![image-20200430224443914](image-20200430224443914.png)\n\n若校验成功，则连接数据库获取商品信息。\n\n![image-20200430224501556](image-20200430224501556.png)\n\n### 项目的意义\n\n项目创新性的提出了基于门限方案的条形码保密及容错方案，推出了一款集保密，防伪造，防污损等功能于一体的新型一维条形码。有以下几项重大意义：\n\n1.解决了一维条形码没有任何保密性和冗余度的现状。\n\n2.使得一维条形码可以在身份认证等应用场景流通。\n\n3.只需其中若干子条形码完整,即可可靠识别出原条形码的信息。\n\n4.可以一次性识别出多条条形码信息,即可一次识别出门限条形码,更加快捷。\n\n5.推广价值。本方案不仅限于条形码,还可用于其他相似领域,如二维码。","tags":["project"],"categories":["project"]},{"title":"2020新年原创脚本-其中的小把戏你清楚吗","url":"/2020/04/26/2020新年小发明/","content":"\n关键词：随机数素数生成，新年祝福小程序。\n\n### 脚本创作\n\n这是我在大年三十写的一个程序，当时我正准备去伯克利交流，但由于疫情的缘故，出国变数增大，所以我就打算通过随机数“未卜先知”。以下就是我的脚本：\n\n```python\n#-*- coding:utf-8 -*-\nfrom Cryptodome.Util.number import *\n\ndef 成功抵达伯克利():\n    p = getPrime(512)\n    q = getPrime(512)\n    if(p // q < 100000):\n        return 1\n    else:\n        return 0\n\ndef 感染新冠肺炎():\n    p = getPrime(512)\n    q = getPrime(512)\n    if(p // q > 100000):\n        return 1\n    else:\n        return 0\n\ndef 课程顺利完结():\n    p = getPrime(512)\n    q = getPrime(512)\n    if(p//q < 2):\n        return 1\n    else:\n        return 0\n\ndef 选择不去伯克利():\n    if(感染新冠肺炎()==0):\n        print(\"身体健康\")\n        print(\"万事如意\")\n    \ndef 选择去伯克利():\n    if(成功抵达伯克利()):\n        print(\"学业有成\")\n    if(感染新冠肺炎()==0):\n        print(\"身体健康\")\n        if(课程顺利完结()):\n            print(\"万事如意\")\ndef 今年我还能去伯克利吗():        \n    p = getPrime(512)\n    q = getPrime(512)\n    if(p//q > 2):\n        选择不去伯克利()\n    else:\n        选择去伯克利()\n\n    \nif __name__ == \"__main__\":\n    今年我还能去伯克利吗()\n\n```\n\n运行这个程序，按理说我们通过分支，最终将只有一定的概率能把“身体健康，万事如意，学业有成”三个词都输出，但是实际上的运行结果肯定是这样：\n\n![img](1.png)\n\n大家知道我耍了什么小把戏吗？那就是getPrime函数！\n\n### getPrime函数的特性\n\ngetPrime函数根据用户输入的需求生成相应位数的随机素数。需要注意的是，这个随机数是有范围的，那就是它的最高位肯定是1。那么如果我们采用的是getPrime(10)的话，得到的数就应该在2<sup>9</sup>~2<sup>10</sup>-1左右。\n\n### 那么脚本用了什么小伎俩？\n\n在脚本中，我的getPrime函数都是512位的，所以p,q都在2<sup>511</sup>~2<sup>512</sup>之间。那么p//q就在(0.5~2)之间所以p//q>=2或者p//q<=0.5是不可能成立的。因此相关的分支为无效分支。代码最终只会执行今年我还能去伯克利吗-> 选择去伯克利->成功抵达伯克利->(not)感染新冠肺炎->课程顺利完结的路径，最终的输出就是：身体健康，万事如意，学业有成。\n\n---\n\n说个题外话，伯克利最终还是没有成行，疫情让我难得的出国游学的机会泡汤了，不过寒假我会再争取一次的。","tags":["project"],"categories":["project"]},{"title":"基于CRT的物流信息安全处理方案","url":"/2020/04/15/基于CRT的物流信息安全处理方案/","content":"\n关键词：中国剩余定理，密钥分发技术，隐私保护。\n\n### 引言\n\n在2018年11月份的时候，段老师在密码学课上讲到了密钥分发协议，我当时就觉得这个协议很有意思也很有应用前景。后来老师还很主动地分享了一下它的idea，其中一部分就是有关物流单上的信息安全问题的。这个我深有感触，其实每次处理快递的时候，我都会把快递单撕得粉碎，然后倒进垃圾桶。但是物流过程中的信息泄露的确更让人担心。\n\n老师向我们提出了她的愿景：通过洋葱路由或者密钥分发技术加密快递单上的消息，使得快递在配送的过程中只知道它的上一站和下一站。于是我搭档了两位学习很认真的女同学，打算对基于CRT的物流信息安全处理方案一探究竟。\n\n### 实现过程\n\n基于CRT的理论知识，我们采用二维码技术以及密钥分发技术，提出了一种物流过程信息安全处理方法。这种方法的实施过程如下（设寄件人为p，收件人为q，先后经过快递驿站或快递员A,B,C,D）：\n\n1. **寄件人p通过app填上寄件驿站代号（A）,收件人q的地址、姓名以及app号。**\n\n2. **app终端立即自动生成快递单号以及最短路径，并分割形成相应密文。**\n          App根据寄件驿站与目的地，用迪杰斯特拉算法生成最短路径(p-A-B-C-D-q)，并告知q寄件人的相关信息。然后把路径中除了初始驿站的每一个结点分割出来(B/C/D/收件人姓名和地址)，并一次对每一个文件随机产生一次性密钥(Ks1, Ks2, Ks3, Ks4)，并用AES算法进行加密（生成密文c1,c2,c3,c4）\n\n3. **同时，生成通过中转站私钥生成随机数R，使该站只能解密其下一个站点的信息。**\n         若中转站的私钥为（Ka,Kb,Kc,Kd）：\n      \t（1）A知道下一个地址是B，那么我们可以构造R1使得下列方程组成立:\n      \t\tR1=Ks1(mod Ka)\n      \t\tR1=0(mod Kb)\n      \t\tR1=0(mod Kc)\n      \t\tR1=0(mod Kd)\n      \t（2）B知道下一个地址是C，那么我们可以构造R2使得下列方程组成立:\n      \t\tR2=0(mod Ka)\n      \t\tR2=Ks2(mod Kb)\n      \t\tR2=0(mod Kc)\n      \t\tR2=0(mod Kd)\n      \t（3）C知道下一个地址是D，那么我们可以构造R3使得下列方程组成立:\n      \t\tR3=0(mod Ka)\n      \t\tR3=0(mod Kb)\n      \t\tR3=Ks3(mod Kc)\n      \t\tR3=0(mod Kd)\n      \t（4）D知道下一个地址最终是用户q，那么我们可以构造R4下列方程组成立:\n      \t\tR4=0(mod Ka)\n      \t\tR4=0(mod Kb)\n      \t\tR4=0 (mod Kc)\n      \t\tR4= Ks4(mod Kd)\n\n4. **用二维码对所有密文（c1,c2,c3,c4）与随机数(R1,R2,R3,R4)以及快递单号进行封装**。\n\n5. **寄件。**\n\n   ​       p到A驿站寄件时出示快递单号，系统就会自动把二维码打印出来，由工作人员贴在快递上。同时终端删除路径信息，只留下快递单号和收件人的app号。A驿站派件时，只需要扫描一下二维码查看下一个站点，此时终端自动通过快递号给收件人q发送一条“快递已经在A寄出，下一站是B” 的消息。\n\n6. **中转。**\n\n   ​       到达中转站时，分发人员只需要扫描一下二维码，就可以得到该包裹下一站的信息，但是却得不到其他任何信息。同时通过终端给收件人q发送一条“快递已经到达中转站xx（B/C），下一站是xx（C/D）”的信息\n\n7. **到达。**\n\n   ​       到达最后一个中转站D时，由于扫出的信息带有用户姓名，app自动给用户发送一条“请到D驿站取快递，取件码xxx（随机生成）”的消息。\n\n8. **接收。**\n\n   ​       用户取快递时，只需要通过取件码和姓名取快递即可。若为贵重物品，则只需要拿出app通过快递号验证即可。\n\n### 优点分析\n\n**1.AES算法极大的简化了加密解密的时间，而且安全性也相对较好，资源消耗也较少。**\n\n**2.基于CRT的密钥分发协议，简单易实现，而且计算代价为常数阶。**\n\n**3.通过加密和密钥分发能充分达到保护用户隐私的要求。**\n       由于通过二维码只可以得知快递单号，其余均是密文，不法分子无法从中得到任何有用的信息，所以用户大可抛弃快递单。\n       不仅如此，对各中转站而言，他们也无法从中得到任何有用的信息，因为他们只知道快递的下一个中转站。而对于最后一站，他们尽管可以知道用户在app中的ID和姓名，但是没有电话号码，所以作用也不大。\n**4.用户能够了解物流寄出与派送情况**\n       用户可以通过app发出的消息，先后知道寄件人的信息，快递已经到达的中转站及其下一站，最后知道取件码等信息。所以出现问题也可以问责相关的物流站点。\n\n### 讨论与质疑\n\n我们小组在项目实施过程中，对项目的应用前景提出了如下质疑：\n\n1.流程中存在的漏洞：\n\n​       在设计流程中，我们先让寄件人选择好寄件地址和收件地址，并由算法确定接下来邮件的路径，但这样可能会存在一些非预期问题。如果寄件人说好在A驿站寄件却去了其他驿站，是拒绝派送还是新生成一张存储A驿站信息的二维码，方法有待商榷。另外如果由于工作或者其他原因邮件被寄到了某个不在路径之内的中转站，又应该怎么处理？\n\n2.密钥更新有关问题：\n\n​       分析对中转站密钥穷举攻击的可能性，以及中转站是否需要更换密钥，多久更换密钥。\n\n3.成本与性价比问题：\n\n​       需要分析二维码加密和识别工具的制作成本以及攻击者的攻击成本和可能导致的信息泄露后果，以及加密对快递拣发效率的影响。以确定该方案的性价比是否足够的好。\n\n### 总结与感想\n\n电子商务的快速发展使得个人信息的泄露问题已经成为公众生活的威胁之一，针对不法快递人员将快递信息用以市场交易，甚至直接威胁收件人、寄件人的生命财产安全，文章提出利用二维码技术与计算机技术相结合，基于二维码技术，采用分层加密技术，对物流信息进行分层加密后转储到二维码进行二次封装，并且不同等级授权机制解密相关信息，保护信息安全。\n\n但是流程中存在某些漏洞，实际应用中可能带来比较大的麻烦，性价比方面还需要调查研究。所以这个项目有待优化。\n","tags":["project"],"categories":["project"]},{"title":"基于CRT的新型群文件共享系统","url":"/2020/04/13/基于CRT的新型群文件共享系统/","content":"\n关键词：隐私保护，权限管理，身份认证，中国剩余定理，密钥分发，密钥更新。\n\n这个项目的是在2019年寒假期间进行的，4月份在中南大学信息安全作品赛答辩，但是由于功能只实现了主体部分，加之我在台上比较胆怯紧张，所以只获得团队三等奖，但是当时老师们还是对我们鼓励有加，说我们有实实在在在做项目。在此感谢两位搭档与我一起努力，共克难关。看着当时做的答辩PPT和项目代码，依然觉得感受良多。这的确是一次既有收获又有遗憾的项目经历。\n\n#### 选题背景\n\n在密码学课程中，我们的指导老师段老师给了我们很多新颖的idea。其中一条是和群文件分级管理有关的，她分析了一个现象：目前在比较大的QQ群里，往往存在很严重的信息泄露情况。如果我们能在聊天群里面对文件进行分级管理，会不会有更好的效果？\n\n的确，信息泄露现象已经屡见不鲜，前不久在学校举办的天梯赛里面就出现了这样的问题，**组委会在公布参赛人员名单的时候竟然把所有参与者的姓名，学院，专业名称，班级，学号，QQ，邮箱和联系电话等资料统统泄露了出来，其中也包括我的资料。**我对此感到不满，立即与发布这份名单的同学说清楚这样发布名单的危险。还好她很快认识到自己在隐私保护方面的不足，两三分钟后迅速地把这份报名表撤回了。\n\n![被泄露的报名表](1.png)\n\n虽然一份名单中的信息量不多，对不法分子而言可能还卖不出一份好价钱。但是如果人人都抱着这种随意和侥幸的心态，就有可能导致更多更重要的隐私被一次性泄露，从而带来非常大的危害。\n\n#### 作品功能\n\n经过项目组的讨论和意见交换，分析上述情况出现的原因主要有以下三点：\n\n**1.文件的发布者隐私保护意识不强。**\n\n**2.群里人员鱼龙混杂。**\n\n**3.群文件明文可见。**\n\n对发布者的隐私保护意识的提升，光有宣传，效果是不大的，只有通过设计出一款人性化的软件来使他们在不知不觉中形成这种习惯。而群里人员鱼龙混杂，则主要归因于群成员缺乏身份认证。群文件明文可见，则是由于对群成员缺乏分层管理，导致可拓展性低。\n\n为了保证群文件的安全，我们的应用程序打算做到以下几点：\n\n1.群文件加密保存。\n\n2.群成员实名认证。\n\n3.对群成员进行分级权限管理。\n\n4.提醒管理员注意群文件的安全。\n\n这意味着需要实现如下功能：\n\n1.通过**权限分级**实现**权限管理**，控制每个用户所能解密的文件等级，以保证保密级别较高的文件具有比较好的保密性。\n\n2.通过**基于CRT的密钥分发**系统，具体实现文件的**访问控制**，使级别较低的人不能解密级别较高的文件\n\n3.通过**实名制与重名查询**，实现辅助的**身份认证**。\n\n4.当群成员退出或者权限降低后，**密钥自动更新**，使得退出群组的成员无法再解密群中的文件。\n\n群成员的权限管理该采用什么模型呢？当时我在学操作系统安全，在寒假的预习过程中，我预习到了一种模型，叫做Biba模型，当看到这个模型的思路的什么，我就觉得，它正好可以用在我们项目组研制的软件中，根据Biba模型，我做出了一些调整，最终软件所能实现的分层管理功能就是：任何一个等级的群成员，只能浏览安全等级小于或者等于这个等级的群文件。例如，安全等级为4的用户可以得知安全等级为1,2,3,4的文件的密码(这个用户的私钥可以解密上述四种安全等级文件的会话密钥)，而安全等级为4的文件只可以被安全等级为4,5的用户查看(只要这些用户能通过解密相应信息或者这个文件的会话密钥)\n\n而基于CRT的密钥分发技术则是在密码学课程中我十分感兴趣的技术。例如在一个交际系统中，A,B,C,D,E都有自己的私钥，若B,C,D需要在不透露自己的私钥的情况下进行沟通，那么可以生成一个会话密钥并通过CRT技术用B,C,D的私钥进行加密，B,C,D可以通过解密这条消息看到相应的会话密钥，而A,E则不行。这样就实现了一个小范围保密通信协议。\n\n身份认证这方面，主要是重名查询。为免有人冒充群里已有的成员加入，每位成员加入的时候，系统会遍历一遍已有的群成员，如果已经存在该群成员，则系统会出现“Red Alert”，提醒管理员要十分注意核实该申请者的身份。同时每一位入群的成员都将被管理员设置成相应的安全级别。\n\n故作品的关键流程与技术如下：\n\n![](2.png)\n\n![](3.png)\n\n#### 作品实现\n\n作品最终实现了以下功能：群文件密钥分发，实名制，权限管理，密钥可更新，重名查询。\n\n我的两位队友主要负责聊天软件的制作(Q群界面的模拟和身份认证功能的实现)，而我负责关键流程的算法设计和代码实现（权限管理，访问控制和密钥更新）。但是最后由于两部分的代码不太兼容，最后没调通，我就直接在eclipse上面展示关键代码的功能了。\n\n关键代码部分（含注释）实现如下：\n\n```java\nimport java.math.BigInteger;//用于支持java密钥的大数\nimport java.util.*;\n\n\npublic class CRT {\n;\n\tpublic static void main(String[] args) {\n\t\tKEY []key=new KEY[5];\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tkey[i]=new KEY(32);//对话密钥一般比用户密钥少，用户密钥需要稍大\n\t\t\tSystem.out.println(\"初始化用户密钥: key\"+(i+1)+\"=\"+key[i].primekey);//用户私钥\n\t\t}\n\t\tint rank;//文件等级\n\t\tMOD m=new MOD();\n\t\tSystem.out.println(\"自动生成模数:\"+m.primemod);\n\t\ttry {Thread.sleep(1000);}\n\t\tcatch(Exception e) {};\n\t\tScanner cin=new Scanner(System.in);\n\t\t//某用户传送文件\n\t\tKEY []Ks=new KEY[5];//生成会话密钥\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tKs[i]=new KEY(30);//会话密钥要比普通密钥稍小\n\t\t\tSystem.out.println(\"初始化会话密钥: ks\"+(i+1)+\"=\"+Ks[i].primekey);//+\"=\"+Ks[i].primekey\n\t\t}\n\t\ttry {Thread.sleep(500);}//这一段是为了在答辩时老师能慢慢的看变化，看得更清楚\n\t\tcatch(Exception e) {};\n\t\t//System.out.println(\"系统内部生成文件加密密钥中\");//测试\n\t\t\n\t\tKEY []Kr=new KEY[5];\n\t\tSystem.out.println(\"根据文件等级生成传输密钥Kr\");\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\t//第i+1级文件的CRT\n\t\t\t//System.out.println(\"根据文件等级生成传输密钥Kr\"+(i+1));\n\t\t\tKr[i]=Ks[i].CRT(key,m,i+1);//根据CRT生成总密钥Kr,Ks是对应会话密钥,m是模数,(i+1)是等级\n\t\t\tSystem.out.println(\"Kr\"+(i+1)+\"=\"+Kr[i].get());\n\t\t}\n\t\ttry {Thread.sleep(1000);}\n\t\tcatch(Exception e) {};\n        //展示CRT分级管理后的效果\n\t\tSystem.out.println(\"测试：各等级用户能得到的密钥——请输入你想看的文件等级:\");\n\t\trank=cin.nextInt();\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tBigInteger result=Kr[rank-1].get().remainder(key[i].get());\n\t\t\tSystem.out.println(\"第\"+(i+1)+\"级用户得到的会话密钥是\"+result);\n\t\t}\n\t\tint k=2;\n\t\twhile(k>0)\n\t\t{\n\t\t\tSystem.out.println(\"新建用户\");\n\t\t\tUser a=new User();\n\t\t\tint j=2;\n\t\t\twhile(j>0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"请输入你想看的文件级别:\");\n\t\t\t\trank=cin.nextInt();\n\t\t\t\tBigInteger result=Kr[rank-1].get().remainder(key[a.rank-1].get());\n\t\t\t\tSystem.out.println(\"用户得到的密钥是\"+result);\n\t\t\t\tSystem.out.println(\"测试：第\"+rank+\"级文件会话密钥:\"+Ks[rank-1].primekey);\n\t\t\t\t//System.out.println(\"是否继续？除y之外任意键退出查看文件并注销用户。\");\n\t\t\t\tj--;\n\t\t\t\ttry {Thread.sleep(5000);}\n\t\t\t\tcatch(Exception e) {};\n\t\t\t}\n\t\t\t//用户注销，执行析构函数\n\t\t\tSystem.out.println(\"用户注销，密钥将自动更新\");\n\t\t\tint userank=a.get();\n\t\t\t\n\t\t\tfor(int i=0;i<userank;i++)\n\t\t\t{\t\n\t\t\t\tKs[i]=new KEY(30);//生成会话密钥\n\t\t\t\t//System.out.println(\"会话密钥已更新\");\n\t\t\t\tkey[i]=new KEY(32);\n\t\t\t\t//System.out.println(\"等级私钥已更新\");\n\t\t\t\tSystem.out.println(\"更新后的等级密钥: key\"+(i+1)+\"=\"+key[i].primekey);\n\t\t\t\ttry {Thread.sleep(300);}\n\t\t\t\tcatch(Exception e) {};\n\t\t\t}\n\t\t\tfor(int i=0;i<5;i++)\n\t\t\t{\n\t\t\t\t//第i+1级文件的CRT\n\t\t\t\tSystem.out.println(\"重新根据文件等级生成传输密钥Kr\"+(i+1));\n\t\t\t\tKr[i]=Ks[i].CRT(key,m,i+1);//根据CRT生成总密钥Kr,Ks是对应会话密钥,m是模数,(i+1)是等级\n\t\t\t\tSystem.out.println(\"新的Kr\"+(i+1)+\"=\"+Kr[i].get());\n\t\t\t\ttry {Thread.sleep(100);}\n\t\t\t\tcatch(Exception e) {};\n\t\t\t}\n\t\t\t/*System.out.println(\"是否继续？除y之外任意键退出。\");\n\t\t\tString str=cin.toString();\n\t\t\tstr=cin.toString();\n\t\t\tif(str.charAt(0)!='y')\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}*/\n\t\t}\n\t\tk--;\n\t\ttry {Thread.sleep(3000);}\n\t\tcatch(Exception e) {};\n\t}\n\n}\nclass User\n{\n\tint rank;\n\t//用户登录,输入密码,获得用户等级\n\tUser()\n\t{\n\t\tScanner ci=new Scanner(System.in);\n\t\tSystem.out.println(\"请输入用户等级:\");\n\t\trank=ci.nextInt();//测试用，手动输入用户等级,貌似有错误输入\n\t}\n\tint get()\n\t{\n\t\treturn rank;\n\t}\n\t\n}\nclass MOD\n//生成模数\n{\n\tBigInteger primemod;\n\tMOD()\n\t{\n\t\tRandom rand=new Random();\n\t\tbyte []rand_byte=new byte[35];\n\t\trand.nextBytes(rand_byte);\n\t\trand_byte[0]=1;//为了让模数大于密码\n\t\tBigInteger a=new BigInteger(rand_byte),b=new BigInteger(rand_byte);\n\t\tprimemod=a.multiply(b);\n\t\tprimemod=primemod.nextProbablePrime();\n\t}\n\tBigInteger get()\n\t{\n\t\treturn  primemod;\n\t}\n}\nclass KEY\n//密钥生成\n{\n\tBigInteger primekey;\n\tKEY()\n\t{\n\t\tRandom rand=new Random();\n\t\tbyte []rand_byte=new byte[32];\n\t\trand.nextBytes(rand_byte);\n\t\tBigInteger a=new BigInteger(rand_byte);//随机大正数\n\t\ta=a.abs();\n\t\tprimekey=a.nextProbablePrime();\n\t}\n\tKEY(int i)\n\t{\n\t\tRandom rand=new Random();\n\t\tbyte []rand_byte=new byte[i];\n\t\trand.nextBytes(rand_byte);\n\t\tBigInteger a=new BigInteger(rand_byte);//随机大正数\n\t\ta=a.abs();\n\t\tprimekey=a.nextProbablePrime();\n\t}\n\tBigInteger get()//输出\n\t{\n\t\treturn  primekey;\n\t}\n\tKEY(BigInteger a)\n\t{\n\t\tprimekey=a;\n\t}\n\tvoid push(BigInteger b)//修改\n\t{\n\t\tprimekey=b;\n\t}\n\tKEY CRT(KEY key[],MOD m,int rank)\n\t{\n\t\tKEY Kr=new KEY(BigInteger.ZERO);\n\t\tBigInteger []x=new BigInteger[5];\n\t\tfor(int i=1;i<=5;i++)//把密钥分发给需要的人\n\t\t{\n\t\t\tif(i<rank)//比如等级是三级的文件，1，2级不能看，密钥填0\n\t\t\t{\n\t\t\t\tx[i-1]=BigInteger.ZERO;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx[i-1]=primekey;//Ks[i]，即对应的会话密钥\n\t\t\t}\n\t\t}\n\t\tBigInteger p=m.get();\n\t\tBigInteger Mn=BigInteger.ONE;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tMn=Mn.multiply(key[i].get());\n\t\t}\n\t\tBigInteger []W=new BigInteger[5];\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tW[i]=Mn.divide(key[i].get());\n\t\t}\n\t\tBigInteger []T=new BigInteger[5];//开辟了数组空间\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tT[i]=W[i].modInverse(key[i].get());\n\t\t}\n\t\tBigInteger result=BigInteger.ZERO;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tresult=result.add(x[i].multiply(W[i].multiply(T[i])));\n\t\t}\n\t\tresult=result.remainder(Mn);//咋变成0了\n\t\t//result=result.remainder(p);\n\t\tKr.push(result);\n\t\treturn Kr;\n\t}\n}\n```\n\n在测试中，我们的展示流程是这样的：\n\n初始化群用户密钥并生成每类文件的会话密钥。\n\n![](4.png)\n\n自动生成每类等级文件密钥的加密信息。\n\n![](5.png)\n\n测试CRT定理对密钥分发的有效性：\n\n每个级别的用户对于某个文件等级的文件，能获取到的密钥(样例文件等级为3)：\n\n![](7.png)\n\n用户入群后，随意访问文件密钥，但是只能看到安全等级比较低的文件，不能访问安全等级比自己等级高的文件。\n\n![](6.png)\n\n密钥更新部分，密钥更新产生了新的会话密钥，老用户不再能使用之前的密钥。(PPT没有截图，具体实现可以看代码)\n\n#### 质疑与争论\n\n**我的质疑**：\n\n在答辩前，我写了一份有关这个项目的优势和劣势的一些分析并交予小组成员一起讨论，主要有如下几点：\n\n1.在鱼龙混杂的qq群中，如果管理员真的愿意耐心的给每一个人和文件分配权限的话，那么权限比较低的人看不到权限比较高的文件。那么如果是权限比较高的人出了问题呢？比如管理员的号被盗了怎么办？\n\n2.我们给他足够高的权限意味着我们足够相信他，但是泄密者不一定是本人，也不一定是前员工，如果只是qq号被攻击者窃取了，那么别人是可以在管理员不知情的情况下获取文件内容的。如果文件内容被获取，那么截图或者下载，总有可能是会泄露的。\n\n3.如果我们实在担心文件的安全，为什么还一定要把文件上传到qq而不通过其他方式分享文件？\n\n4.不可否认，通过入群的认证,离开群后更新密钥和分级管理是可以起到一定保护作用。但这种方式的性价比真的高吗，真的值得吗？\n\n不可否认，我可能想得有点多，但是关于上述几个问题，的确值得商榷，最让我担心的还是项目的性价比和应用前景。\n\n**团队总结的遗留问题：**\n\n经过一番讨论，我们在答辩过程中提出了如下的不足之处和创新点：\n\n![](8.png)\n\n![](9.png)\n\n**老师的质疑：**\n\n项目答辩的时候，老师也问了这个项目的应用前景，他们觉得没有这个必要。因为完全可以建一个小一些的Q群，或者使用更安全的公司内部网络。他们建议，我们把这个问题上升到公司内部文件系统的安全上面去，不然看着觉得很好，但是想着又觉得又有点虚。\n\n---\n\n2020.4.21随想\n\n有时候人性的弱点带来的危险最大，我之前虽然会看入群验证但很少核实信息是否真实。所以我觉得一个应用，最主要的还是要解决人的问题，方便人的生活，同时自然就能保证安全了。\n\n","tags":["project"],"categories":["project"]},{"title":"对信息安全的全方位透视——读杨义先、钮心忻《安全简史》有感","url":"/2020/04/07/对信息安全的全方位透视——读杨义先、钮心忻《安全简史》有感/","content":"\n创作时间：2017-2018年寒假。\n\n《安全简史》这本书，是我们班导师推荐读的。相比这个假期看的另外一本书《数学之美》，它们显然都是科普类读物。但和《数学之美》不同，它不是只从数学角度介绍计算机方面的知识，而是从各个角度去透析信息安全这个新兴学科，它的目的是通过这本“外行不觉深，内行不觉浅的书”来“抛砖引玉”，正如书中所强调，希望有人来填补信息安全XX方面的学科空白“为学科开通论”。\n\n最近几天，总是听到学长和同学吐槽这本书，说它写作思路不清，语言啰嗦话题太分散，还有就是技术等“硬件”太少，只看了三十多页就不看了。可我却坚持读了下来，因为我深知，这本书之所以那么多“废话”，主要是为了让复杂的知识更加简单，然我们不至于疲乏。\n\n而之所以说它没技术，是因为他们只看了前面几章，谁都知道，隐私是怎么产生的，谁都知道，大数据时代，人的隐私泄露的多么厉害；谁都知道，病毒无处不在，对于我们专业的学生而言，“震网病毒”“蠕虫病毒”更是早有耳闻；谁都知道，那一位位著名的黑客，与“伊朗核电站”被攻击的事件和“勒索病毒”等攻击事件；稍加预习也可以知道凯撒密码和维吉尼亚密码了。然而书中前五章，花了四章篇幅论述这些，不就是为了面对广大读者，拉近其与广大读者的距离嘛。这几章选取了很多生活场景，让文章本身更加“接地气”，虽然浅显，但是易懂，何尝不是好事？\n\n这本书为了浅显易懂，还有一大显著的特点，就是跨学科。语文，数学，哲学，历史，物理，生物，社会学，经济学，管理学，乃至英语，化学，一切应有尽有。比如说到语文，先别说那些幽默的句子，首先说说每一节后面的那些改编汪国真，唐婉，苏轼等等小诗而做的章节小节吧。虽然那些诗确实被改编得让人有些啼笑皆非，不过这更刺激了我看这些大作原作的动力。看到唐婉的《钗头凤》，我忍不住记起了苏轼的另一首《钗头凤》，还有他们爱情的悲剧并查阅了相关资料；看到余光中的《乡愁》，我想起了这位刚刚逝世的伟大诗人，并期盼两岸早日统一，再说说书中引用的中外神话，从盘古开天到孙猴子取经归来；从人类被赶出伊甸园，到上帝创造语言阻止人类造“通天塔”。\n\n后面的章节，就和前面的章节不大一样了，从第六章认证开始，话题开始逐步深入，从十一章灾备开始，话题开始变得复杂。而到了十八章“系统与安全”时，话题达到了“专业级”水平。文章花尽篇幅讲述了哲学上的“整体性”思想，还引用了大量的逻辑悖论，最后给出了整体性在系统安全中的应用。因此，对于我了解过得知识和过于专业的知识，我是一行一行地看的，但对于适合我的章节，我却是一个字一个字地看的，这本书中，最让我向往的两个章节，就是《安全管理学》和《安全心理学》。管理、心理和哲学，一直都是我想选修的课。这不能说是专业知识，只能说是人应该有的技能，而且是跨学科的，甚至有与理工科不同的“感性”。看了这两章，我觉得自己更加明确信息安全专业及相关企业对自己人格的要求，并且要促使自己去塑造自己的性格、锻炼自己的能力，成为一个合格的信安人。\n\n为什么我会喜欢《安全管理学》呢？因为，第一，一个软件的开发乃至一个系统的安全开发，都是要靠整体的，这离不开管理。比如我日思夜想想完成某游戏的改进版，那么确立“把游戏完好地从脑海搬到屏幕”这个“管理的任务”，就要做到协调，比如这里，就是各个设计人员的协调。首先，要让他们采用相同的编程语言，这个是硬性要求；第二就是任务的分配，即每个人该完成什么任务，要分配好，这又有要求：不重复，不缺少，让合适的人做合适的工作，比如高效率的人做多几个任务，善于沉思的人突破难关。然后，尽管每个人的编程方式都不一样，但是要把这些人的程序合在一起，形成文件，而且要提前做好找bug的工作，现在的一些小游戏，明明bug很明显又很多却从来不修改，调试工作十分不到位。\n\n其实书中这一章给我影响启发最大的，是那段动物们的“轮番表演”。它讲的，其实是哲学上的几个效应。第一个，蝴蝶效应，它告诉我们，一丁点管理的失误将会引发大事，现实意义大概就是，仔细检查程序，提高容错性，尽量减少bug的产生。边编程边编译。第二个，青蛙效应，它提醒我们不要积累问题，一些小bug如果积累，就像是基因突变，由量变最终变成质变。第三个，鳄鱼法则，它提醒我们，当危险发生，有时候，我们应当做出必要的牺牲，以保证剩余的部分完好无损，比如书中说到“网络隔离”等。第四，鲇鱼效应，这提醒我们要勇于承认漏洞的存在，做出检测并加以填补。第五，羊群效应，坚持自己心中的准则，做事要有原则，敢于质疑权威，特别是编程，不能使用不规范的语言和危险的关键字，比如C语言中经常出现的“goto”，在熟练采用其他算法后应尽量摒弃。第六，刺猬效应，它提醒我们，凡事要找到合适的平衡点，为安全投入的成本要和效益相匹配。第七，手表定律，提示我们，做一件事的时候，专心致志，不要一心二用；或者不要同时确立多个目标；或者，管理的时候要定统一的规则，比如采用统一的语言等等。第八，“破窗理论”，说明环境可以对人产生强烈的暗示性和诱导性，这告诉我的，如同“打扫干净房子再请客”，就是说，如果是在一个团队，一个共同的环境中，我应当以身作则，不能放纵自己，然后把这种不羁传染给别人。第九，二八定律，马太效应，它告诉我们，安全管理要抓住那关键的少数，比如说，重大的漏洞，极有可能被攻击的地方。第十，木桶理论，它告诉我们，补好系统的短板，因为那些地方最容易被黑客攻击，就算再先进的（乃至量子）系统，都一定会有它的缺陷，这些缺陷往往决定了一个系统的成败，所以系统设计是，该知道它的长处但更改防备它的短处。第十一，鸟笼逻辑，这是指由于惯性思维，人买了鸟笼就会养鸟，它告诉我们，我们不要被惯性思维所困，比如量子学家，不应该因为量子“测不准”原理就担保“量子计算机系统是绝对安全的”，说不定黑客们会发现其他弱点呢？第十二，责任分散效应，它告诉我们，安全管理要明确责任，把责任落实到具体的人身上。第十三，习得性无助效应，如果尝试了很多次依然度不过的难关，他就会产生无助感。所以我们要做好安全，特别是未来人工智能方面的安全，不能让用户悲观绝望。\n\n安全心理学，主要研究网络空间建设者，破坏者，和使用者的“不安全”心理。而这其中最重要的，应该还是网络空间建设者的心理，这也是对我们信安人的要求。给我印象比较深的，是省能的心理，就是建设者们愿意投入的成本太小。比如我们现在编程的时候，不愿意投入太多的时间成本，使得程序的逻辑思维不严谨，容错性不高，要很多漏洞可寻；再比如公司投入的人力、物力不够多，导致信息安全领域的漏洞没有被充分检查。这提醒我们，要舍得投入时间和金钱到计算机系统乃至网络的建设中，问题解决的越早，成本就越少。还有就是“注意力”，这提醒我在日后的工作中，要劳逸结合，以最饱满的精神状态迎接工作，而且工作时要仔细小心，不放过任何一个漏洞。 \n\n不利于安全的性格中，给我印象比较深深的，第一是性格孤僻，因为这种性格不善于交际，其实我也不能算孤僻，不过小的时候某些东西改变了我的价值观，让我有了很多“原则”，所以显得不太合群，大学学习的过程其实也是我努力摆脱自己这个性格缺陷的过程，我尝试和更多的同学玩在一起，不管是平时还是假期。第二是不易平静，其实我也不能算这种性格，因为在初中的时候我已经是一个很享受孤独的人，文三金老师的话给了我很大的影响，那就是“睡前多思考”，我喜欢在自然中，或在睡前的平静中，或听着轻音乐思考人生，然而这却给了我更多的不平静，也是我初中高中失眠的主要原因。到了大学，开朗了，失眠的症状好了，但是却少了一丝深入的思考与钻研的劲儿，看来两者之间，找个平衡点，也挺难的。\n\n在提及的四个良好的意志品质方面，给我印象比较深的，莫过于“果断性”，我这方面还真的有点欠缺，所以18岁以后，我才让自己鼓起勇气，变得更加主动，而且我的高三舍友，我也特地挑了以为果断的学霸，尽管我们的性格时有碰撞，但是最终，我还是从他身上学到了很多，我们一直都还是很好的朋友，所以，在这里，我谢谢他啦！\n\n遗憾的是，至今安全心理学和安全管理学还没有相关的教材，希望这方面的空缺能马上填补，在国家大力推崇信息安全的时候，希望他们可以加大这方面的投入。另外其他章节也给我提供了很多知识，比如让我了解了社会工程学，认证，信息隐藏，防火墙，灾备的过程；也提出了很多很专业的知识，比如赛博学，区块链，安全熵，虽然现在还不甚了解，但是，随着专业学习的深入，我一定还会在翻开重看的。\n\n不得不说，《安全简史》是本好书，它从各个方面来描写信息安全，这样，各个领域的人，各个年龄层次和知识层次的人，都能找到自己喜欢的部分，可以说，它就是一部360度全景摄像机，让我们完整的领略了信息安全这个庞大的家族，更坚定了我学习信息安全的决心。\n\n ","tags":["article"],"categories":["article"]},{"title":"极光实验室战队考核密码学部分考察点与题解","url":"/2020/04/01/极光实验室战队考核密码学部分考察点与题解/","content":"\n关键词：DH密钥交换协议，Coppersmith攻击，混合密码通信，rsa及aes编程。\n\n#### 题目\n\n![image-20200404204929407](image-20200404204929407.png)\n\n#### 出题思路\n\n由于是战队考核，这次的题目应出得相对综合，也更考验同学们的知识面和对各方面加密的理解和把握能力。同时，题目应当结合密码学的实际应用，有生动的背景和场景。\n\n出题前，我在网上做了两三道rsa和aes的题目，觉得出题点还是比较单一，于是联想了一下之前做过的一些印象深刻的密码学题目，于是我想到了把密码学实验和aes，rsa结合起来，出一次改进版的中间人攻击，作为密码学实验的补充。之所以要和aes，rsa结合，是因为通过混合密码通信的安全性更高，效率也更好。我们段老师的PPT是这么说的：\n\n![image-20200402112220312](image-20200402112220312.png)\n\n但是，如果rsa加密过程中存在某些问题呢？假如rsa私钥部分泄露呢？那面对中间人的攻击，这种通信方法也难以保证它的安全性。见如下[参考论文](王小云,刘明洁.格密码学研究[J].密码学报,2014,1(01):13-27.):\n\n![7](.\\极光实验室战队考核密码学部分考察点与题解\\7.png)\n\n在题目环境中，我就让私钥最低位的一半比特泄露出来，这是足够解对称密码私钥的了。根据等式：\n$$\ne * d == 1 mod phi(N)\n$$\n我们引入常数k，使得:\n$$\ne * d - k * phi(N) == 1\n$$\n由于e模phi的逆：\n\n```python\nd = gmpy2.invert(e,phi)\n```\n\n所以对于上述等式，有：\n\n$$\nphi(N) > d\n$$\n\n那么就有：\n$$\nk<e\n$$\n由于e一般在16位以下（题目中不超过1024），所以k是可爆破的。\n\n我们对等式两边都模上2的1050次方，并化简：\n$$\n(e * d - k * phi(N)) mod 2**1050 == 1 mod 2**1050\n$$\n\n$$\n((e mod 2**1050) * (d mod 2**1050) - k * phi(N) ) mod 2**1050 == 1 mod 2**1050\n$$\n\n$$\n(e * d0 - k*phi(N)) mod 2**1050 == 1 mod 2**1050\n$$\n\n$$\ne * d0 - k*phi(N) == 1 mod 2**1050\n$$\n\n方程两边同乘q，并代入等式：\n$$\nphi(N)==(p-1)*(q-1)\n$$\n以及\n$$\nN==p*q\n$$\n可以得到：\n$$\ne*d0*p - k*(n*p-p*p-n+p) == p mod 2**1050\n$$\n所以只需要对k进行遍历，然后对每一个k通过sage解同余方程即可。\n\n\n获取了对称密码的私钥以后，消息明文便不难获取了。同时，和密码学实验一样，我们假设中间人有着足够的能力完成近乎实时的通信，在没有认证机制的DH通信协议中，他就可以冒充通信双方进行欺骗。*这里为了保证实时性，本来应该进行时间限制的，这样大家就只能通过python的pwntools工具来进行交互了。但是考虑到考点比较综合，任务量大，在12小时之内能写出这么多脚本的可能性不太大，所以就不限制时间了。*\n\n#### 考察点\n\nAES(CBC和ECB）加解密， 铜匠攻击，DH通信协议，中间人攻击，base64加解密\n\n#### 出题过程\n\n首先，还是建立两个文件，Arica.py和conversation.py，保存一些不想公布的变量值:\n\n```python\n#Arica.py\nkey=b'grzu7KTaDuiiBVWL'\nflag=b'ACTF{You_have_got_the_flag!That_is_impossible!}'\n```\n\n```python\n#conversation.py\nquestions = [\n    b\"Who are you?\",\n    b\"Oh my dear Brooke, I miss you so much!\",\n    b\"Brooke, I was so lonely during the outbreak of Novel coronavirus!\",\n    b\"Brooke, do you mind me asking you a few more question?\",\n    b\"What can I do for you?\"]\nanswer = [\n    b\"I'm Brooke.\",\n    b\"I miss you too.\",\n    b\"Me too! I wanna go out for dance!\",\n    b\"Not at all.\",\n    b\"Nothing.\"]\nfake_answer=b\"I want to get my AES-key.\"\nsaying_key=b\"Here is the key: \"\n\n```\n\n然后在windows上写了针对key的加密函数(aes-cbc)和针对flag的加密函数(泄露私钥的rsa函数)。\n\n```python\n#encryption.py\nfrom Cryptodome.Cipher import AES\nfrom Arica import key,flag\nimport base64\nimport gmpy2\n\nfrom Cryptodome.Util.number import (\n    bytes_to_long,\n    long_to_bytes,\n    str2long,\n    long2str,\n    getPrime\n)\nfrom Cryptodome.Random.random import (\n    getrandbits,\n    randint\n)\n\np = 217534615279223294476101434763509239207\ng = 2\n\ndef encrypt_flag():\n    global flag\n    aes = AES.new(key, AES.MODE_ECB)\n    flag = adaptmessage(flag)\n    c = aes.encrypt(flag)\n    print(\"Here is the encrypted flag: \"+str(base64.b64encode(c)))\n    #b'gTAmtDzEDIYdzs6j55csresodxpsKJlOVMOmzLq8/39Vm0lJZvnrGtPBW6IKUpML'\ndef encrypt_key():\n    e = 1667\n    p = getPrime(700)\n    q = getPrime(1400) \n    n = p*q\n    print(\"\"\"+------------------------------------------------------+\n|Attension! Through soical engineering, you got this: |\n+------------------------------------------------------+\"\"\")\n    phi = (p-1)*(q-1)\n    d = gmpy2.invert(e,phi)\n    print(\"n = \"+str(n))\n    #print(d)\n    print(\"Brooke's partial d: \"+ str(int(d) % (2**1050)))\n    enc = pow(bytes_to_long(key), e, n)\n    return enc\n\ndef generateDH(exp):\n    return pow(g, exp, p)\n\ndef adaptmessage(message):\n    return message.ljust(16-len(message)%16+len(message), b\"\\x00\")\n\ndef aricaSay(*args):\n    print(\"\"\"+-------------------+\n|    Arica said:    |\n+-------------------+\"\"\")\n    print(\" \".join(map(str,args)))\n\ndef brookeSay(*args):\n    print(\"\"\"+--------------------+\n|    Brooke said:    |\n+--------------------+\"\"\")\n    print(\" \".join(map(str,args)))\n\ndef say2arica(*args):\n    print(\"\"\"+---------------------+\n|    Say to Arica:    |\n+---------------------+\n\"\"\"+ \" \".join(map(str,args)), end=\"\")\n    return input()\n\ndef say2brooke(*args):\n    print(\"\"\"+----------------------+\n|    Say to Brooke:    |\n+----------------------+\n\"\"\" + \" \".join(map(str,args)), end=\"\")\n    return input()\n\n```\n\n然后把DH通信的脚本和题目情景写好：\n\n```python\n#server.py\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom encryption import *\nfrom conversation import *\n\nbanner = \"\"\"\n+--------------------------------------------------+\n|HELLO CHALLENGER!                                 |\n|                                                  |\n|Have you ever seen movies like MISSION IMPOSSIBLE?|\n|Unfortunately, You have got a mission that seemed |\n|impossible to finish!                             |\n|                                                  |\n|In the task, you are required to decrypt the      |\n|'Most secret' message of Arica, the bank clerk.   |\n|                                                  |\n|Fortunately, after social engineering you have    |\n|hacked in her communication with her boyfriend    |\n| Brooke and you have got Brooke's partial         |\n|RSA-private-key.                                  |\n|                                                  |\n|To get the message, you must first establish      |\n| communication with Arica through 'DH key exchange|\n| protocol', chat with her by saying what Brooke   |\n|said, but you need to send the message            |\n| \"I want to get my AES-key.\" and the timestamp    |\n| after Arica said \"What can I do for you?\",       |\n|then she will give the AES-key encrypted with her |\n| RSA-public-key，this message should be start with|\n| \"Here is the key:\".                              |\n+--------------------------------------------------+\n\"\"\"\n\ndef main():\n    print(banner)\n    encrypt_flag()\n    enc = encrypt_key()\n    expA = getrandbits(128)\n    expB = getrandbits(128)\n    A = generateDH(expA)\n    B = generateDH(expB)\n    aricaSay(\"A:\", A)\n    AC = int(say2brooke(\"A: \"))\n    brookeSay(\"B:\", B)\n    BC = int(say2arica(\"B: \"))\n    keyC = pow(AC, expB, p)\n    keyS = pow(BC, expA, p)\n    keyC = long_to_bytes(keyC).rjust(16, b\"\\x00\")\n    keyS = long_to_bytes(keyS).rjust(16, b\"\\x00\")\n    cipherC = AES.new(keyC, AES.MODE_ECB)\n    cipherS = AES.new(keyS, AES.MODE_ECB)\n    for _i in range(5):#5\n        index=_i\n        randomnum = randint(0, 256)\n        messageA = questions[index]\n        messageA = adaptmessage(messageA)\n        cS = bytes_to_long(cipherS.encrypt(messageA))\n        aricaSay(\"A:\", \"{:032x}\".format(cS))\n        s = int(say2brooke(\"A: \"), 16)\n        s = long_to_bytes(s)\n        q = cipherC.decrypt(s)\n        if q != messageA:\n            print(\"Brooke does't get your words and realize something, U FAILED...\")\n            exit(0)\n        randomnum = randint(0, 256)\n        messageB = answer[index]\n        messageB = adaptmessage(messageB)\n        cC = bytes_to_long(cipherC.encrypt(messageB))\n        brookeSay(\"B:\", \"{:032x}\".format(cC))\n        s = int(say2arica(\"B: \"), 16)\n        s = long_to_bytes(s)\n        a = cipherS.decrypt(s)\n        if(_i==4):\n            messageB = fake_answer\n            messageB = adaptmessage(messageB)\n        if a != messageB:\n            print(\"Arica does't get your words and realize something, U FAILED...\")\n            exit(0)\n        \n    randomnum = randint(0, 256)\n    messageA = saying_key+long_to_bytes(enc)\n    messageA = adaptmessage(messageA)\n    cS = bytes_to_long(cipherS.encrypt(messageA))\n    aricaSay(\"A:\", \"{:032x}\".format(cS))\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n在出题过程中，根据自己的测试又稍微对题目更改了一下。\n\n首先，在对aes私钥进行rsa加密的时候，一开始的e比较大，在1500左右，在测试中发现对于不同的d0值和n值，脚本的运行时间需要10分钟-3个小时，而3个小时在12个小时比赛时间里面所占比例太大，所以把e限制在1024以内，且设置为动态可变的数值。但是为了不增加难度，aeskey是固定的。\n\n```python\ndef encrypt_flag():\n    global flag\n    aes = AES.new(key, AES.MODE_ECB)\n    flag = adaptmessage(flag)\n    c = aes.encrypt(flag)\n    print(\"Here is the encrypted flag: \"+str(base64.b64encode(c)))\n    #b'gTAmtDzEDIYdzs6j55csresodxpsKJlOVMOmzLq8/39Vm0lJZvnrGtPBW6IKUpML'\ndef encrypt_key():\n    #e = 1667\n    p = getPrime(700)\n    q = getPrime(1400) \n    n = p*q\n    print(\"\"\"+------------------------------------------------------+\n|Attension! Through soical engineering, you got this: |\n+------------------------------------------------------+\"\"\")\n    phi = (p-1)*(q-1)\n    while(1):\n        e=getPrime(10)\n        if(phi%e!=0):\n            print(\"e = \"+str(e))\n            break\n    d = gmpy2.invert(e,phi)\n    print(\"n = \"+str(n))\n    #print(d)\n    print(\"Brooke's partial d: \"+ str(int(d) % (2**1050)))#d有问题\n    enc = pow(bytes_to_long(key), e, n)\n    return enc\n```\n\n另外由于DH的g为2，所以公钥应当为大于0的整数(不管你是1或者g**y%p，都不可能是0)，所以加入了一段代码检验：\n\n```python\n    #之所以要做出这个判断，是因为公钥真的不可能为0或负数\n    if(AC <=0):\n        brookeSay(\"You are not Arica! Her public key should not be:\", AC)\n        exit(0)\n    brookeSay(\"B:\", B)\n    BC = int(say2arica(\"B: \"))\n    if(BC <=0):\n        aricaSay(\"You are not Brooke! His public key should not be:\", BC)\n        exit(0)\n```\n\n另外，为了考察大家有没有细读message里面的内容，我在每条message后面都附带一个随机timestamp。每一次都需要更改这个timestamp，使得newtimestamp = (oldtimestamp+1)%256，程序里加上相应举例与提示：\n\n```python\n+---------------------------------------------------------+\n| PS:                                                     |\n| All message should be followed with new timestamp!!!    |\n| newtimestamp = (oldtimestamp+1)%256                     |\n| Please don't stuck with it:(                            |\n| For example, when you decrypt what Arica said like this:|\n| +--------------------+                                  |\n| |    Brooke said:    |                                  |\n| +--------------------+                                  |\n| I'm Brooke.                                             |\n| timestamp:112                                           |\n| You should encrypt this message to Arica:               |\n| +---------------------+                                 |\n| |    Say to Arica:    |                                 |\n| +---------------------+                                 |\n| I'm Brooke.                                             |\n| timestamp:113                                           |\n+---------------------------------------------------------+\n```\n\n请大家不要太纠结timestamp的意义，这个机制是Arica和Brooke确保不被中间人攻击的机制，假设Arica和Brooke的时戳是同步的，对话中每次附加一个时戳值，通过验证时戳与当前时间是否相同来过关。但是如果是采用真正的时间的话，攻击成功的概率就更小了，所以简化一下，就生成一个固定的256位随机数。同时，中间人修改信息需要时间，并把修改后的时间替换发给另一方。这时候我们假设中间人接收并重发消息的时间代价为1s，所以我们要将时戳加一。举例代码如下：\n\n```python\n#server.py\nmessageA = questions[index]+b\"\\ntimestamp:\"+bytes(str((randomnum+1)%256),encoding='utf-8')\nmessageA = adaptmessage(messageA)\n```\n\n#### Writeup样例\n\n首先，改编server.py为client.py，和服务器进行交互。这里由于交互程序变动较大，我直接通过手动输入把Arica和Brooke的密文信息传进去，等到解出明文以后手动修改timestamp。另外为了方便起见，我传递过去的公钥为1(即私钥为0)，这样的话和Brooke以及Alice的会话密钥都是1，就比较简单了。\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom encryption import *\n\ndef main():\n    keyC = 1\n    keyS = 1\n    keyC = long_to_bytes(keyC).rjust(16, b\"\\x00\")\n    keyS = long_to_bytes(keyS).rjust(16, b\"\\x00\")\n    cipherC = AES.new(keyC, AES.MODE_ECB)\n    cipherS = AES.new(keyS, AES.MODE_ECB)\n    for _i in range(0):#5\n        #Arica说话了\n        s = int(say2brooke(\"A: \"), 16)#输入Arica说的话\n        s = long_to_bytes(s)\n        q = cipherC.decrypt(s)\n        print(q)\n        #这里还是直接从外头输入吧\n        messageA = bytes(input(),encoding='utf-8')\n        messageA += b\"\\n\"\n        messageA += bytes(input(),encoding='utf-8')\n        messageA = adaptmessage(messageA)\n\n        s=cipherC.encrypt(messageA)\n        print(hex(bytes_to_long(s))[2:])#对Brooke说的话\n\n        #Brooke说话了\n        s = int(say2arica(\"B: \"), 16)#输入Brooke说的话\n        s = long_to_bytes(s)\n        a = cipherS.decrypt(s)\n        print(a)\n        #这里还是直接从外头输入吧\n        messageB = bytes(input(),encoding='utf-8')\n        messageB += b\"\\n\"\n        messageB += bytes(input(),encoding='utf-8')\n        messageB = adaptmessage(messageB)\n        \n        s=cipherS.encrypt(messageB)\n        print(hex(bytes_to_long(s))[2:])#对Arica说的话\n        \n        \n    #Arica说出key了\n    s = int(say2brooke(\"A: \"), 16)#输入Arica说的话\n    s = long_to_bytes(s)\n    q = cipherC.decrypt(s)\n    key = q[17:]\n    for i in range (len(key)):\n        if(key[i:i+10]==b'\\ntimestamp'):\n            key=key[:i]\n            break\n    print(q)\n    print(key)\n    print(bytes_to_long(key))#key\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n然后开始运行，运行截图如下：\n\n首先收到服务器的消息:\n\n![](1.png)\n\n这些就是rsa的公钥，模数和泄露的私钥，先保存住，然后开始通信。\n\n首先，传递的公钥都为1。然后把Arica said的内容decryption，修改timestamp后把输出给回say to Brooke。\n\n服务器端界面：\n\n![2](2.png)\n\ndecryption.py运行界面：\n\n![image-20200402131956740](image-20200402131956740.png)\n\n一直运行下去：\n\n![3](3.png)\n\n直到最后得到key:\n\n![4](4.png)\n\n把key的部分截取下来，转换为数字，然后根据已有的e，n，partial d来解出aeskey：\n\n```python\ne=863\nn = 100518394843898371534434468452366727877002363101196571557097132988734353726584916462381290904798733002716305256677572628142627545744681541293793069726231800754314572981168235829239563613754713724345581918566947492170647540708428013292098065584617876680109166595710006367308500341766024651457023537770009981295726110940010220082434490215229951191714998895277291076151298363584672162765486380515325199053994651202708865071379999942193926154807059329464291992287421875356468218685095369057734586073271903432589401520355996027480658214090147502829069822606753125953586123331154015992246394834867237734405963056883227552074835515815968441\nc=86032824638305503499105979004374728344861493802341583733786447138684660694449673826205271902766363026345759436852747743967254218765160248630402258125202844303276381357264903281385470521070161164325276902001627351570675438339067652784355957225763207341000628151024518554862922220201109512940053316358078220681816224518400117972877854801506805929902506832781106133167532327833813179558969694268634413548545525533605595649634856393268111552838570383386406869870266457914799472663817890880697043874427042958587244568923338441053981863674366842769379075373006984522023718553749977766836594738859315852333132093474709715377682153430675891\nd0=8429433927120666131169351623736961178529851960373209550653840828920672665447032524933438956407503522388445988812739437427277858013428300926608147855795349674824173869269407061090165202002106353884034590344852857623737262477675587193006629765892565228448265429521617733861051151345083787592170864896543517637252788111\n\nd = 0\nfor k in range(0,e):\n    print k\n    X = var('X')\n    results = solve_mod([e*d0*X - k*(n*X-X*X-n+X) == X], 2**1050)\n    for x in results:\n        p0 = ZZ(x[0])\n        if is_prime(p0) and gcd(n,p0)!=1:\n            print p0\n            q0 = n//p0\n            phi=(q0-1)*(p0-1)\n            d = inverse_mod(e,phi)\n            break\n    if(d!=0):\n        break\nprint d\nm = pow(c,d,n)\nprint m\n```\n\n运行结果如图：\n\n![5](5.png)\n\n得到aeskey以后解密flag，脚本如下：\n\n```python\nfrom Cryptodome.Cipher import AES\nimport base64\nfrom Cryptodome.Util.number import (\n    bytes_to_long,\n    long_to_bytes,\n)\nkey_in_num = 137504889148498708381160600835355727692\nencryptedflag = b'gTAmtDzEDIYdzs6j55csresodxpsKJlOVMOmzLq8/39Vm0lJZvnrGtPBW6IKUpML'\nc = base64.b64decode(encryptedflag)\nkey = long_to_bytes(key_in_num)\nprint(key)\naes = AES.new(key, AES.MODE_ECB)\nflag = aes.decrypt(c)\nprint(\"Here is the decrypted flag: \"+str(flag))\n```\n\n最终得到flag\n\n![6](6.png)\n\n\n\n###### 参考资料：\n\n[1]王小云,刘明洁.格密码学研究[J].密码学报,2014,1(01):13-27.\n\n","tags":["project","competition","auroralab"],"categories":["auroralab"]},{"title":"Coppersmith攻击方式小结","url":"/2020/03/29/Coppersmith攻击方式小结/","content":"\n关键词：rsa，coppersmith攻击。\n\nCopperSmith攻击的种类真的很多，以下是我归纳的几种常见形式：\n\n#### 一道新的例题——p的高位和地位泄露\n\n摘自：Securinets CTF Quals 2020 - Destruction\n\n题目中提及MSB寓意即最高比特位，LSB即最低比特位，根据铜匠攻击即可,sage脚本：\n\n```python\nsize = 512\nsizep=256\nknownbits= 134\nN=14086160291425342283520344380411983364812792954622400251334758082442316624175006850950987254617679940795136231914925367368535278968830499182004816257654049\n\n#we need to define an polynomial == 0 (mod p) that gives us the missing part (x)\n# f_p(x) = x*2**(knownbits/2) + p_msb + p_lsb\n# it's not monic so we need to divide by 2**(knownbits/2)\n# set R = 2**(knownbits/2) and invert it modulo N\n\nR = 2**(knownbits/2)#从第68位开始测试\ninvR = inverse_mod(R,N)\n#补齐两边\np_msb = 251000163339563476196 << (sizep-knownbits/2-1)\np_lsb=int('2567fcb8c35e6dc63',16)\n#setup coppersmith\nF.<x> = PolynomialRing(Zmod(N))\n#define the poly in x modulo p\nf = x + (p_msb+p_lsb)*invR\n#solve it\nx0 = f.small_roots(X=2^(sizep-knownbits)-1, beta=0.44, epsilon=1/64)[0]\n\n \n\nprint (\"reconstructed p: {:x}\".format(Integer(x0*R)+p_msb+p_lsb))\n```\n\n在这道题目中，p的高位和地位比特都被泄露，可以解出rsa明文。\n\n#### 引申与补充\n\n除了上述例题所述的情况外，我目前至少见过四种coppersmith攻击模式。\n\n#### 2019强网杯-RSA-Coppersmith\n\n1.challenge 1\n\n**已知明文的高位，是Stereotyped messages攻击 或 Lattice based attacks** \n\n```python\nn = #输入n  \ne = 3\nm = randrange(n)\nc = pow(m, e, n)\nbeta = 1\nepsilon = beta^2/7\nnbits = n.nbits()\nkbits = floor(nbits*(beta^2/e-epsilon))\nmbar = m & (2^nbits-2^kbits)\nc = 0x1f6f6a8e61f7b5ad8bef738f4376a96724192d8da1e3689dec7ce5d1df615e0910803317f9bafb6671ffe722e0292ce76cca399f2af1952dd31a61b37019da9cf27f82c3ecd4befc03c557efe1a5a29f9bb73c0239f62ed951955718ac0eaa3f60a4c415ef064ea33bbd61abe127c6fc808c0edb034c52c45bd20a219317fb75\n \nprint \"upper %d bits (of %d bits) is given\" % (nbits-kbits, nbits)\nPR.<x> = PolynomialRing(Zmod(n))\nf = (mbar + x)^e - c \nprint m\n \nx0 = f.small_roots(X=2^kbits, beta=1)[0]  # find root < 2^kbits with factor = n1\n \nprint mbar + x0\n \n```\n\n2.challenge 2\n\n**已知p的高位，Factoring with High Bits Known**\n\n```python\nn = 0x5894f869d1aecee379e2cb60ff7314d18dbd383e0c9f32e7f7b4dc8bd47535d4f3512ce6a23b0251049346fede745d116ba8d27bcc4d7c18cfbd86c7d065841788fcd600d5b3ac5f6bb1e111f265994e550369ddd86e20f615606bf21169636d153b6dfee4472b5a3cb111d0779d02d9861cc724d389eb2c07a71a7b3941da7dL\np_fake = 0x5d33504b4e3bd2ffb628b5c447c4a7152a9f37dc4bcc8f376f64000fa96eb97c0af445e3b2c03926a4aa4542918c601000000000000000000000000000000000L\n \n \n \n \n#pbits = 2048\npbits = p_fake.nbits()\n#kbits = 900\nkbits = 128  #p失去的低位\npbar = p_fake & (2^pbits-2^kbits)\nprint \"upper %d bits (of %d bits) is given\" % (pbits-kbits, pbits)\n \nPR.<x> = PolynomialRing(Zmod(n))\nf = x + pbar\n \nx0 = f.small_roots(X=2^kbits, beta=0.4)[0]  # find root < 2^kbits with factor >= n^0.3\np= x0 + pbar\nprint p\n```\n\n3.challenge 3\n\n**已知私钥的512位的低位 Partial Key Exposure Attack(部分私钥暴露攻击)**\n\n```python\ndef partial_p(p0, kbits, n):\n    PR.<x> = PolynomialRing(Zmod(n))\n    nbits = n.nbits()\n    f = 2^kbits*x + p0 \n    f = f.monic()\n    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root < 2^(nbits//2-kbits) with factor >= n^0.3\n    if roots:\n        x0 = roots[0]\n        p = gcd(2^kbits*x0 + p0, n)\n        return ZZ(p)\n\ndef find_p(d0, kbits, e, n):\n    X = var('X')\n \n    for k in xrange(1, e+1):\n        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)\n        for x in results:\n            p0 = ZZ(x[0])\n            p = partial_p(p0, kbits, n)\n            if p:\n                return p\n \n \nif __name__ == '__main__':\n    n = 0xd463feb999c9292e25acd7f98d49a13413df2c4e74820136e739281bb394a73f2d1e6b53066932f50a73310360e5a5c622507d8662dadaef860b3266222129fd645eb74a0207af9bd79a9794f4bd21f32841ce9e1700b0b049cfadb760993fcfc7c65eca63904aa197df306cad8720b1b228484629cf967d808c13f6caef94a9\n    e = 3\n    d = 0x603d033f2ef6c759aec839f132a45215fc8a635b757f3951a731fe60bc6729b3bcf819b57abfcaba3a93e9edef766c0d499cad3f7adb306bcf1645cfb63400e3\n    beta = 0.5\n    epsilon = beta^2/7\n    nbits = n.nbits()\n    print \"nbits:%d:\"%(nbits) \n    #kbits = floor(nbits*(beta^2+epsilon))\n    kbits = nbits - d.nbits()-1\n    print \"kbits:%d\"%(kbits)\n    d0 = d & (2^kbits-1)\n    print \"lower %d bits (of %d bits) is given\" % (kbits, nbits)\n    p = find_p(d0, kbits, e, n \n    print \"found p: %d\" % p\n    q = n//p\n    print d\nprint inverse_mod(e, (p-1)*(q-1))\n```\n\n#### 私钥泄露\n\n这部分学习的是在[网上]( https://ctftime.org/tasks/?tags=crypto&hidden-tags=crypto )看到的一道题目的一篇[wp](https://github.com/p4-team/ctf/tree/master/2019-09-21-dragonctf/rsachained)写的，都说密钥时现代密码的弱点，所以rsa私钥部分泄露原来也可以导致对rsa的铜匠攻击！这部分的方程倒不难推算，因此我也出了一道和私钥泄露有关的题目,[题解](../极光实验室战队考核密码学部分考察点与题解)也在博客里。这里把sage脚本也放出来吧。\n\n```python\ne=863\nn = 100518394843898371534434468452366727877002363101196571557097132988734353726584916462381290904798733002716305256677572628142627545744681541293793069726231800754314572981168235829239563613754713724345581918566947492170647540708428013292098065584617876680109166595710006367308500341766024651457023537770009981295726110940010220082434490215229951191714998895277291076151298363584672162765486380515325199053994651202708865071379999942193926154807059329464291992287421875356468218685095369057734586073271903432589401520355996027480658214090147502829069822606753125953586123331154015992246394834867237734405963056883227552074835515815968441\nc=86032824638305503499105979004374728344861493802341583733786447138684660694449673826205271902766363026345759436852747743967254218765160248630402258125202844303276381357264903281385470521070161164325276902001627351570675438339067652784355957225763207341000628151024518554862922220201109512940053316358078220681816224518400117972877854801506805929902506832781106133167532327833813179558969694268634413548545525533605595649634856393268111552838570383386406869870266457914799472663817890880697043874427042958587244568923338441053981863674366842769379075373006984522023718553749977766836594738859315852333132093474709715377682153430675891\nd0=8429433927120666131169351623736961178529851960373209550653840828920672665447032524933438956407503522388445988812739437427277858013428300926608147855795349674824173869269407061090165202002106353884034590344852857623737262477675587193006629765892565228448265429521617733861051151345083787592170864896543517637252788111\n\nd = 0\nfor k in range(0,e):\n    print k\n    X = var('X')\n    results = solve_mod([e*d0*X - k*(n*X-X*X-n+X) == X], 2**1050)\n    for x in results:\n        p0 = ZZ(x[0])\n        if is_prime(p0) and gcd(n,p0)!=1:\n            print p0\n            q0 = n//p0\n            phi=(q0-1)*(p0-1)\n            d = inverse_mod(e,phi)\n            break\n    if(d!=0):\n        break\nprint d\nm = pow(c,d,n)\nprint m\n```\n\n#### 其他题目\n\n除此以外，印象中还存在另外一些coppersmith题目，印象中我把所有解方程有关的题目都当成coppersmith了。我新人赛的时候也心血来潮自创了一题，打算放到校赛用。反正最基础的办法就是：**找齐足够的方程，代入消元求解。**","tags":["exploration"],"categories":["auroralab"]},{"title":"安卓反混淆软件探索-deobf","url":"/2020/03/19/安卓反混淆软件探索-deobf/","content":"\n关键词：代码混淆，代码反混淆及其原理，代码反混淆软件测试与性能对比。\n\n## 前言\n\n我们的大创项目其实是分两方面进行的，一方面，我们从代码混淆的角度比较各种软件对安卓程序的加固能力；另一方面，我们着重针对OLLVM进行反混淆测试。OLLVM集成了代码混淆的几种最基本的方法：控制流平坦化，虚假控制流，指令替代等三种方式；其中控制流平坦化和虚假控制流可以混淆各个基本块之间的执行顺序，使得程序的执行流程更难读懂，但是它们有一个致命的攻破方法——符号执行。这不仅成为了每一位资深逆向人员必备的技能，而且也逐渐被开发成了自动化反混淆工具。目前市面上开源的自动化反混淆工具很少，有一款是[针对安卓应用的simplify](https://github.com/CalebFenton/simplify) ，另外我在github上面搜寻了OLLVM的反混淆软件，排除大部分无用的项目，最终只发现了这两个有实际价值的项目。\n\n#### [ollvm_de_fla]( https://github.com/sfwishes/ollvm_de_fla)\n\n针对控制流平坦化的反混淆工具，不足之处就是只适用于带thumb2指令的ios macho格式文件，因此它的平台普适性不高，应用范围极其窄。 该项目于两年前便停止更新。\n\n#### [deobf](https://github.com/maiyao1988/deobf )\n\ndeobf主要也是针对控制流平坦化这种主流的代码混淆方式。相比ollvm_de_fla，deobf的优势多很多。首先，这是一个新兴项目，创建于大约四个月前，在四天前还曾发布了重大更新。另外，这个项目适用于linux和windows等大众平台，可以不限于thumb指令的使用，有着广泛的应用前景。在项目的说明文档中，很清楚的说明了项目的拷贝方法，安装方法和运行参数。**不仅可以反混淆一般的so文件，也可以针对性的处理抖音的libcms.so文件。**\n\n但是这个项目依然有着自己的不足，只适用于python3.7版本，更低级的版本不能兼容。\n\n## 下载与安装\n\n由于deobf需要python3.7环境支持，所以需要下载python3.7，在linux下默认的环境没有python3.7，升级步骤可以参考一篇不错的[文章]( https://blog.csdn.net/u014775723/article/details/85213793) 。后来在windows下也安装了一个，按照[项目链接](https://github.com/maiyao1988/deobf )下第二步的详细做法完成即可。但是这里建议把32位和64位的keystone都下下来（当然32位的比较重要）。如果运行报错很有可能是dll的原因，两个dll混搭着用应该就没有问题。\n\n## deobf反混淆原理初探\n\n#### 基于OLLVM的反混淆框架的实现\n\n一般的反混淆软件都会有以下几个模块:\n\n1）**基本块识别模块** ：识别出有用块和无用块。经 OLLVM 控制流平展化混 淆的程序中会增加很多无用的基本块以混淆程序逻辑，这就 需要设计有效的基本块识别算法，找出有用的基本块和无用 的基本块。\n\n 2）**与程序执行流程相关模块** ：确定有用块之间的前后关系，得到真实有效的程序执行路径，因为混淆程序中的很多基本块跳转逻辑并不是程序的实际执行流程。 一般采用符号执行技术。\n\n3）**指令修复模块** ：修复二进制程序。在使用 NOP 指令填充无用基本块 后，为使程序正常运行，我们需要对跳转指令的跳转偏移量 进行修正；同时，还需要将 cmov 条件传送指令改写成相应 的条件跳转指令，并在其后添加一条 jmp 指令，使其跳向另 一分支。 \n\n*参考文献*\n\n*[1]肖顺陶,周安民,刘亮,贾鹏,刘露平.[基于符号执行的OLLVM反混淆框架](http://kns.cnki.net/kcms/detail/51.1307.TP.20180319.1531.012.html.)[J/OL].计算机应用:1-6[2020-03-22].*\n\n*[2]肖顺陶,周安民,刘亮,贾鹏,刘露平.基于符号执行的底层虚拟机混淆器反混淆框架[J].计算机应用,2018,38(06):1745-1750.*\n\n#### 通过IDA调试确定基本块的前后关系\n\n这是deobf的一个突出特点，它是根据一个IDA-python脚本直接对软件执行调试，通过这里确定程序的执行流程。[参考脚本 ](**https://github.com/maiyao1988/IDAScripts/blob/master/trace.py**)。\n\n这也就意味着，和传统采用的符号执行不同，**deobf不需要虚拟执行的结果，而是实打实的进行了调试。但是这样的缺点就是不能抗反动态调试。万一一个程序加入了很多的动态调试函数，那么讲给deobf的运行效果带来很大的挑战。**\n\n## deobf反混淆效果\n\n#### 参考\n\n由于deobf的软件的基本框架和上述论文中的反混淆框架在思路上完全一致，除了确定基本块以外其他方面的实现方案上大致相同，因此在这里先引用一下论文中有关混淆效果的数据，如下：\n\n![image-20200322231048178](image-20200322231048178.png)\n\n\n\n\n\n![image-20200322231036631](image-20200322231036631.png)\n\n#### 验证\n\n为了验证OLLVM的反混淆效果是否真的和论文一致，我使用项目中提供给测试使用的so文件进行混淆，这个项目运用了\n\nida查看混淆后的控制流图，十分复杂庞大：\n\n![image-20200320000323204](image-20200320000323204.png)\n\n而反编译后的伪C代码如下，十分复杂，出现多个嵌套的while循环和if分支语句：\n\n```c\nint __fastcall JNI_OnLoad(int a1)\n{\n  int v1; // r0\n  signed int v2; // r6\n  int v3; // r11\n  signed int v4; // r5\n  bool v5; // zf\n  signed int i; // r0\n  int result; // r0\n  int v8; // [sp+8h] [bp-30h]\n  int v9; // [sp+Ch] [bp-2Ch]\n  int v10; // [sp+10h] [bp-28h]\n  int v11; // [sp+14h] [bp-24h]\n  int v12; // [sp+18h] [bp-20h]\n\n  v10 = 0;\n  v1 = (*(int (**)(void))(*(_DWORD *)a1 + 24))();\n  v2 = 189500648;\n  v8 = v1;\n  while ( 1 )\n  {\nLABEL_3:\n    while ( 1 )\n    {\n      v3 = v1;\n      v4 = v2;\n      if ( v2 > 941059666 )\n        break;\n      if ( v2 > -526232813 )\n      {\n        if ( v2 == -526232812 )\n        {\nLABEL_2:\n          v2 = 1535406375;\n          v1 = -1;\n          continue;\n        }\n        if ( v2 == 189500648 )\n        {\n          v2 = 2058077166;\n          if ( v8 )\n            v2 = 1482189424;\n        }\n      }\n      else\n      {\n        v2 = 1535406375;\n        v1 = 65540;\n        if ( v4 == -1125020146 )\n          continue;\n        v5 = v4 == -724953770;\nLABEL_10:\n        v1 = v3;\n        v2 = v4;\n        if ( v5 )\n          goto LABEL_2;\n      }\n    }\n    if ( v2 <= 1535406374 )\n    {\n      if ( v2 == 941059667 )\n      {\n        v11 = (*(int (__fastcall **)(int, const char *))(*(_DWORD *)v9 + 24))(v9, \"com/douyu/lib/http/JniMakeUrl\");\n        for ( i = 1448204801; ; i = 1422645221 )\n        {\n          v2 = -1125020146;\n          if ( i > 1398646745 )\n            goto LABEL_36;\nLABEL_33:\n          while ( i == 193258894 )\n          {\n            v5 = (*(int (__fastcall **)(int, int, char **, signed int))(*(_DWORD *)v9 + 860))(v9, v11, off_45004, 7) == 0;\n            i = -686378191;\n            if ( !v5 )\n              i = -986576434;\n            if ( i > 1398646745 )\n            {\nLABEL_36:\n              while ( 2 )\n              {\n                while ( i == 1448204801 )\n                {\n                  i = 193258894;\n                  if ( !v11 )\n                    i = 1398646746;\n                  if ( i <= 1398646745 )\n                    goto LABEL_33;\n                }\n                if ( i == 1398646746 )\n                {\nLABEL_32:\n                  i = 1422645221;\n                  v2 = -724953770;\n                  continue;\n                }\n                break;\n              }\n              if ( i == 1422645221 )\n              {\n                v1 = v3;\n                goto LABEL_3;\n              }\n              while ( 1 )\nLABEL_47:\n                ;\n            }\n          }\n          if ( i == -986576434 )\n            goto LABEL_32;\n          if ( i != -686378191 )\n            goto LABEL_47;\n        }\n      }\n      v5 = v2 == 1482189424;\n      goto LABEL_10;\n    }\n    if ( v2 != 2058077166 )\n      break;\n    v2 = 941059667;\n    v9 = v10;\n    if ( !v10 )\n      v2 = -526232812;\n  }\n  if ( v2 != 1535406375 )\n    goto LABEL_3;\n  result = _stack_chk_guard - v12;\n  if ( _stack_chk_guard == v12 )\n    result = v3;\n  return result;\n}\n```\n\n执行如下反混淆指令，反混淆其中的JNI_Onload函数：\n\n` python deobf.py libmakeurl2.4.9.so url.so ins-url.trc 0x0000342C 0x00003668 1 `\n\n以下是对各个参数的注释：\n\n待处理的混淆文件：libmakeurl2.4.9.so\n\n反混淆后输出的文件：url.so\n\n 通过ida调试时产生的目标函数的跟踪文件（可以跟踪关键指令或函数） ：ins-url.trc\n\n混淆代码段起始部分偏移：0x0000342C（JNI_Onload函数开头）\n\n混淆代码段结束部分偏移：0x00003668（JNI_Onload函数结尾）\n\n目标函数是否是thumb：是\n\n反混淆后的控制流图，程序执行流程变得十分清晰：\n\n![image-20200320000158559](image-20200320000158559.png)\n\n反混淆后的函数也变得简短易懂：\n\n```c\nint __fastcall JNI_OnLoad(int a1)\n{\n  int v1; // r11\n  int v2; // ST0C_4\n  int result; // r0\n  int v4; // [sp+10h] [bp-28h]\n  int v5; // [sp+14h] [bp-24h]\n  int v6; // [sp+18h] [bp-20h]\n\n  v4 = 0;\n  (*(void (**)(void))(*(_DWORD *)a1 + 24))();\n  v2 = v4;\n  v5 = (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 24))(v4);\n  (*(int (__fastcall **)(int, int, char **, signed int))(*(_DWORD *)v2 + 860))(v2, v5, off_45004, 7);\n  result = _stack_chk_guard - v6;\n  if ( _stack_chk_guard == v6 )\n    result = v1;\n  return result;\n}\n```\n\n## 其他OLLVM反混淆软件常用技术\n\n#### 符号执行\n\ndeobf的反混淆主要借助与符号执行技术，符号执行技术的核心思想是使用符号值来表示程序的输入数据，并将程序的运算过程逐指令或逐语句地转换为数学表达式，在CFG的基础上生成符号执行树，并为每一条路径建立一系列以输入数据为变量的符号表达式。在符号执行过程中，每当遇到判断与跳转语句时，deobf便会将当前执行路径的路径约束收集到该路径的约束集合中。通过使用约束求解器对约束集合进行求解，可以得到该条路径的可达性：如果约束求解的结果有解，表示该条路径可达，否则表示该条路径不可达，在时间与计算资源足够的理想情况下，符号执行能够遍历目标程序的所有路径并判断其可达性。\n\n其中，路径约束是指程序分支指令中与输入符号相关的分支条件的取值，是一系列不具有量词的布尔型公式。而路径约束集合则被用来存储每一条程序路径上收集到的约束，用“与”操作进行连接。\n\n借用软件安全课程的图片，对于下图示例程序1：\n\n![image-20200319232030997](image-20200319232030997.png)\n\n首先画出控制流图，切割基本块。然后计算得函数外部的输入变量数为2，我们只需要设置两个输入变量X,Y。程序中的所有都用与X,Y相关的式子代替。\n\n![image-20200319233648011](image-20200319233648011.png)\n\n然后进入函数顺序执行第2-4行，不出现分叉，在第五行代码时，由于是判断语句，符号执行树出现分支，满足分支条件的作为左子树，不满足的作为右子树，左右子树又继续根据路径约束进一步细化，出现更多分支。最终扩展出的符号执行树如图：\n\n![image-20200319233036906](image-20200319233036906.png)\n\n最后，通过将X、Y变量代入，计算叶子节点的约束集合是否为真，则可以知道哪些路径是可达的。\n\n","tags":["project"],"categories":["project"]},{"title":"记一次安卓代码加固软件的测试过程","url":"/2020/03/13/记一次安卓代码加固研究过程/","content":"\n关键词：代码加固，软件测试，原理分析，过程分析。\n\n在大创项目的实践中，我们对市面上的一些安卓代码加固软件进行了采集，经过搜集，发现了几类代码加固方法并分组进行研究。我发现很多代码加固软件都是对java字节码进行混淆与加固，另外一些则选择对原生语言和so文件进行加固，而我打算研究的这一款软件，则是对资源文件进行加固，它就是[AndResGuard]( https://github.com/shwenzhang/AndResGuard/blob/master/README.zh-cn.md )。\n\n### 混淆原理\n\n大致上来说就是apk在调用资源的时候不是通过资源名来调用的，而是通过一个资源ID值来调用的，因此资源名和资源ID存在一种映射关系，保存在 resources.arsc 中。而由于资源名是一种相对独立的存在方式，仅仅是为了源码的易读性，所以可以用用更短的资源名取代，从而减少apk文件的体积；而新的代号没有任何语义上的可读性，所以可以达到混淆的目的。而且由于这种映射关系是独立于安卓编译过程的，所以我们可以在整个apk的基础上进行操作，通过实现对apk的解压并修改资源文件和 resources.arsc 进行混淆。\n\n项目贡献者的说明文章见[这里](https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=208135658&idx=1&sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd )。\n\n### 混淆过程\n\n为了统一研究对象，采用的混淆软件是我第六次安卓作业后生成的apk文件:\n\n![](1.png)\n\n下载完整个项目以后，最重要的文件是箭头所指的jar文件，这个其实就是源码编译以后的可执行文件了：\n\n![](2.png)\n\n不过还需要输入一些参数才可以运行，包括待混淆apk，混淆配置文件，输出路径，甚至可以加入签名库的路径。\n\n#### 配置\n\n输入参数前，先更改一下混淆配置文件，打开config.xml后，我根据实际研究的情况作了如下更改。\n\n1.**设置不采用7z压缩。**显然，7z压缩是这个软件集成的外部功能，一方面能更加减小程序的空间，另一方面也可以提高程序表观上的复杂程度。但是需要指出的是，7z压缩在AndResGuard中是一个比较独立的组成部分，首先在技术原理和实现方式上就有很大的不同，而且7z压缩更像是对混淆后资源文件的一种打包技术，就像是把安卓源码混淆后再进行打包一样，有着独立的压缩和解压方法，并不涉及任何混淆的思想，也不需要任何的反混淆技术。而如果采用7z压缩后再进行分析，就相当于采用两种技术加固软件后和其他采用一种技术加固软件的方法进行优劣比较，这种方法是不合理的。\n\n![](3.png)\n\n2.**设置不采用签名。**由于混淆前的软件没有采用签名技术，因此作为对照组，混淆后的软件也不应该采用签名技术。\n\n![](4.png)\n\n#### 混淆\n\nAndResGuard的混淆是针对整个文件进行的，只需要输入如下参数即可：\n\n![](5.png)\n\n耗时不到5秒即完成。\n\n#### 混淆效果测试\n\n混淆后，从程序体积，代码可读性等两方面分析混淆效果，主要出现了如下变化：\n\n1.**体积变小。**混淆后生成了另一个apk，把两个apk放在一起，可以明显的看到混淆后的apk文件体积变小，从2511kb变为2104kb。\n\n![](6.png)\n\n2.**资源文件的可读性变复杂，资源名的失去了原有的语义。**采用apk-tool对混淆前后的apk文件进行反编译。这款软件的优势在于可以把apk的文件转变为smali中间代码和资源文件源码，把 resources.arsc还原为原来的res文件夹。通过Android Studio对比整个res文件夹的结构，我们可以发现如下变化：\n\n(1)资源名称出现变化\n\n资源文件总量不变，名称被更短的代号取代。\n\n以Layout文件夹为例，混淆前的前四个资源文件名称如下：\n\n![](7.png)\n\n而混淆后的资源文件名则被更简短的代号取代。以Layout文件夹为例，混淆后的前四个资源文件名称如下：\n\n![](8.png)\n\n点击混淆前和混淆后最上方的文件，发现文件的内容已经不再对应，所以可以认为这是一种无规律的命名，打乱了各个资源文件名的对应关系。\n\n（2）资源文件中所有的引用名都被修改\n\n在res文件夹下所有的所有资源引用中，资源名都被更改，以res\\values\\attrs.xml为例，混淆前我们可以获取完整的资源名称，如图：\n\n![](9.png)\n\n而混淆后，所有的资源名都变为了简短的代号。\n\n![](10.png)\n\n3.**值得注意的是，源代码中所有的内容都不曾被改变，这说明AndResGuard不依赖于smali代码和编译过程。**首先把apk的后缀改为rar并解压，取出dex文件采用dex2jar进行反编译，再使用jd-gui打开生成的jar文件，我们可以发现，混淆前的jar包和混淆后的jar包是完全一致的，以MainActivity为例，混淆前后完全看不出任何区别。混淆前代码如下：\n\n![](11.png)\n\n混淆后代码如下：\n\n![](12.png)\n\n#### 运行性能测试\n\n首次运行混淆后的程序时，出现如下报错：\n\n![](13.png)\n\n查阅[资料]( https://blog.csdn.net/almosti/article/details/88586873 )后猜测报错原因.\n\n但测试了一遍ARM框架的软件还是不行，那么我推测，报错的原因很有可能是因为资源文件被打乱，导致虚拟机无法识别。我尝试用华为手机下载，里面的报错是：该安装包未包含任何证书，因此我可能需要考虑一下运行参数的问题了。但是在测试了除了签名之外的参数后，发现依然无法运行。但是用.android目录下的debug.keystore签名时出现报错，报错情况如下：\n\n![](14.png)\n\n目前暂不知错误，正在分析中。**希望大家可以帮帮我！**不知道是否需要其他什么文件呢。\n\n### 总结\n\n其实AndResGuard就是对apk包的资源 resources.arsc进行更改，使得原有的资源文件中的资源名变得更加简短而不可读。这增加了安卓逆向人员的分析难度，实现了代码混淆。","tags":["project"],"categories":["project"]},{"title":"对OLLVM代码加固技术的改进","url":"/2020/03/08/对OLLVM代码加固技术的改进/","content":"\n### 1．反静态调试\n\n反静态调试可以通过花指令，代码加密，代码加壳等方式实现。\n\n请看图1所示的一段反调试代码：\n\n![img](clip_image002.jpg)\n\n​                                                          <center>图1 花指令代码</center>\n\n这段代码无论如何都会跳转到bb的位置，但是加入0x80以后，会让IDA产生错误的分析，从而无法还原正确的汇编代码和整个函数，在使用IDA查看汇编代码后，结果如图2：\n\n![img](clip_image004.jpg)\n\n​           <center>图2 加入花指令代码后干扰了逆向工具对汇编代码的分析</center>\n\n### 2．反动态调试\n\n请看图3的代码：\n\n![img](clip_image006.jpg)\n\n​                                                     <center>图3 反动态调试代码示例</center>\n\n在这个函数中，通过CheckRemoteDebuggerPresent函数观察程序是否是在被调试状态。也可以通过INT 3达成类似功能。另外还可以通过signal函数，在程序未被响应的一定时间后跳出执行。\n\n### 3．反虚拟机\n\n请看如下代码：\n\n![img](clip_image008.jpg)\n\n​                                                  <center> 图4 反虚拟机代码示例</center>\n\n该代码利用虚拟机CPU时间周期比物理机时间周期长的特点，其中rdtsc指令读取CPU 时钟周期数，一句 cmp $0x16,%eax 的指令就是来把所处环境的时钟周期与正常物理机的时钟周期进行比较的。","tags":["project"],"categories":["project"]},{"title":"安卓开发中遇到的坑坑洼洼","url":"/2020/03/01/安卓开发中遇到的坑坑洼洼(持更中)/","content":"\n关键词：安卓开发，软件测试，错误排查。\n\n大三下学期选修了十分重要的安卓开发课程，老师让我们编写编译书中的程序并完成书后的挑战练习。但是由于Android Studio的版本问题和gradle脚本以及主程序的命名与书中不同，这次编程还是遇到了一点坑，这迫使我上网查资料，并且认真研读资源目录和gradle的源代码，以找到出错的地方。以下是我的一些发现和遇到的一些坑：\n\n#### 版本要匹配\n\n千万不要随便改变项目根目录和app目录下的build.gradle，我更改了几个参数，导致编译通过后打包失败：\n\n1.项目根目录下的插件版本“build:gradle:3.4.1”，这个版本号不能随便改，原因是你的AS版本不一定支持对应的gradle版本和插件版本，当然，当AS更新以后，可能旧项目中的版本不能被支持，这个时候你就需要去更改以下几个地方：\n\n（1）项目根目录下的插件版本号，这个和AS的版本应该是一致的\n\n（2）gradle-wrapper.properties下的distributionUrl，一定要找到这个插件版本号对应的Gradle版本号，具体参考 [这里](https://blog.csdn.net/sqf251877543/article/details/101281308)\n\n（3）下载对应的gradle版本，网址就是distributionUrl的地址。\n\n2.在app目录下的build.gradle也涉及到一些版本的问题，一是compileSdkVersion不能小于某个值，否则会报错；二是minSdkVersion的更改可能会导致在某些手机上不适配，我曾经把minSdkVersion由16改为\"R\",结果在虚拟机上就不能运行了，据网上资料说，只要把minSdkVersion值设为19以下，就可以适配95%以上的安卓手机。\n\n3.版本不匹配会出现如下报错:\n\n(1)Invalid escape sequence at line 1 column xx path $[0].name\n\n(2)gradle project sync failed\n\n(3)Could not find method google() for arguments [] on repository container\n\n4.但是有时候报上述第3点的第（1）条错误时不一定是版本问题，若版本正确仍出现如上问题，应当考虑 开File->Setting->找到instant run（或者搜索）->取消Enable instant run。然后应用即可。 \n\n5.同样的，**虚拟机版本的不同**也可能导致一些问题。比如对于第三章，有的手机屏幕旋转了以后会改变设备配置，从而改变Activity生命周期，但有些却不行。在测试中，Nexus 5 API 29(Android 9+)旋转不会改变Activity生命周期，也不会改变设备配置，但Nexus 5 API 27(Android 8)会。\n\n#### 提示无法执行\n\n1.遇到了一个问题，当我使用Log.d的时候安卓提示要导入android.util.log，但是无法点击，手动输入也不行，后来发现util下面用的是Log这个包，所以有时候提示也是不正确的。\n\n#### 类名的对应\n\n1.在主控制器中，private static final String TAG这个字符串对应的值应该和主控制器名称对应，虽然在第一第二章的时候问题不大，但是使用logcat测试后会发现有很严重的异常报错。\n\n#### 覆盖@Override\n\n1.必须调用父类的同名方法，否则报错：\n\n> Overriding method should call super.onActivityResult less... (Ctrl+F1) \n> Inspection info:Some methods, such as View#onDetachedFromWindow, require that you also call the super implementation as part of your method.  Issue id: MissingSuperCall\n\n#### 中文路径\n\n1.安卓虚拟机最好不要放在有中文的路径下，否则录屏出现如下报错：\n\n>  Emulator: emulator: ERROR: FfmpegRecorder.cpp:267: Could not open [C:\\Users\\?????\\.android\\avd\\Nexus_5_API_27.avd\\tmp.webm]: Invalid argument \n\n这些问号就是中文字符\n\n#### Android Studio平台的一些问题\n\n1.虚拟机默认装C盘，我刚刚清出的一点空间，开了三个虚拟机，结果全满了，占了我C盘一半的空间！[解决方法](https://blog.csdn.net/geekqian/article/details/60145357 )\n\n2.新版的Android Studio找不到DDMS, 如果只是需要查看文件，可以在View->Tools WIndows下选Device File Explorer.\n\n#### LogCat过滤关键词\n\n1.关键错误：FATAL EXCEPTION\n\n#### 空指针问题\n\n在水平方向上运行安卓没问题，竖直方向运行安卓的时候程序终止，明显是布局的问题。LogCat报错如下：\n\n> 2020-03-07 18:49:45.296 3434-3434/com.example.geoquiz E/AndroidRuntime: FATAL EXCEPTION: main\n>     Process: com.example.geoquiz, PID: 3434\n>     java.lang.RuntimeException: Unable to start activity ComponentInfo{com.example.geoquiz/com.example.geoquiz.MainActivity}: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object reference\n> \t……\n>     Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object reference\n>         at com.example.geoquiz.MainActivity.onCreate(MainActivity.java:54)\n>        ……\n\n上网查资料，[参考文章](https://blog.csdn.net/qq_42618969/article/details/81141895 )\n\n先去看看布局文件里面有没有id，很有可能是因为这样导致的空指针，结果发现 不知道为什么两个button的布局代码没了， 所以找不到按钮的地址 ， 形成了空指针  。\n\n","tags":["study"],"categories":["study"]},{"title":"OLLVM代码加固机制分析","url":"/2020/02/24/OLLVM代码加固机制分析/","content":"\n我们通过自己编写测试代码，再用OLLVM的不同指令进行加固，并逆向查看加固效果，加深对代码加固机理的了解。OLLVM目前提供的功能包括控制流平坦化（fla指令），指令替代（sub指令），代码虚拟化（bcf指令）以及虚假控制流（obf指令），接下来,我们团队对各个指令的机理进行详细的分析。\n\n### 1．控制流平坦化\n\n控制流平坦化的主要思想，就是把原本顺序执行的代码变成一个一个的基本块，并复杂化各个代码块之间的关系，使得代码的执行流程不再清晰。\n\nOLLVM的控制流平坦化功能实现于Flattening.cpp中，主要有以下两个步骤。 \n\n第一步：判断是否能够平展。若可以，则跳入flatten方法中执行。在函数开始，使用LowerSwitchPass去除switch，将switch结构换成if结构。保存所有的基本代码块，如果只有一个基本代码块，则不进行处理；如果第一个基本块的末尾是有条件的跳转指令，那么需要将它分割开，并且将它保存到origBB。\n\n```c++\n// Lower switch\n  FunctionPass *lower = createLowerSwitchPass();\n          lower->runOnFunction(*f);\n```\n\n第二步：创建两个基本块，存放循环头和尾的指令。然后将first bb移到到loopEntry的前面，并且创建一条跳转指令，从first bb跳到loopEntry。紧接着创建了一条从loopEnd跳到loopEntry的指令。最后，创建了switch指令和switch default块，并且创建相应的跳转。\n\n```c++\n// Create main loop\n  loopEntry = BasicBlock::Create(f->getContext(), \"loopEntry\", f, insert);\n  loopEnd = BasicBlock::Create(f->getContext(), \"loopEnd\", f, insert);\n  load = new LoadInst(switchVar, \"switchVar\", loopEntry);\n  // Move first BB on top\n  insert->moveBefore(loopEntry);\n  BranchInst::Create(loopEntry, insert);\n  // loopEnd jump to loopEntry\n  BranchInst::Create(loopEntry, loopEnd);\n  BasicBlock *swDefault =\n      BasicBlock::Create(f->getContext(), \"switchDefault\", f, loopEnd);\n  BranchInst::Create(loopEnd, swDefault);\n  // Create switch instruction itself and set condition\n  switchI = SwitchInst::Create(&*f->begin(), swDefault, 0, loopEntry);\n  switchI->setCondition(load);\n\n```\n\n第三步，删除first bb的跳转指令，改为跳转到loopEntry,将所有的基本块加入switch结构.接下来是根据原先的跳转来计算switch变量。\n\n（1）若为没有后继（return BB）的基本块，直接跳过。\n\n（2）若为只有一个后继的基本块，首先删除跳转指令，并且通过后继基本块来搜索对应的switch case，根据case创建一条存储指令，达到跳转的目的。\n\n（3）两个后继的情况跟一个后继的处理方法相似，不同的是，创建一条select指令，根据条件的结果来选择分支。\n\n为了测试控制流平坦化混淆的效果，我们编写了如下代码：\n\n```c++\nint main()\n{\n    \n    while (n>0)\n    {\n        if(a[i%16]>0x60)\n        {\n            ........................\n        }\n        else\n        {\n            ........................\n        }\n        if(a[i%16]>0x70)\n        {\n            ........................\n        }\n        else\n        {\n            ........................\n        }\n\t\tif(a[i%16]>0x80)\n        {\n            ........................\n        }\n        else\n        {\n            ........................\n        }\n    ........................\n} \n\n```\n\n将该代码编译成exe文件，逆向后主函数的控制流程图如图1：\n\n![1573125852244](clip_image002.gif)\n\n​                                    <center> 图1 源程序逆向后主函数的控制流程图</center>\n\n可以看出，除了内嵌的几个选择结构以外，总体来说，程序的结构都是顺序结构，这样代码分析就十分容易，例如从while循环代码逆向后，我们仍然可以清晰的看到代码的执行原理，如图2所示：\n\n![1573126048613](clip_image004.gif)\n\n​                                  <center> 图2 源程序逆向所得C代码</center>\n\n除了变量名有所不同以外，我们能轻易的看到各个条件分支的选择条件，以及各条异或操作代码的先后顺序。\n\n而被混淆后，代码的执行流程就完全不同了，所有代码块的先后顺序都被打乱，代之以各种分发器决定代码执行的先后顺序，如图3所示：\n\n![1573126374237](clip_image006.gif)\n\n​                                   <center>图3 控制流平坦化混淆后的控制流程图</center>\n\n具体到代码上，可以看到很多的while循环。而一个while循环内，各基本块之间也变成了平行关系，并通过一个分发器进行分发，如图4：\n\n![1573126820484](clip_image008.gif)\n\n​                                            <center> 图4 混淆后逆向所得C代码</center>\n\n从图中看出，变量v17控制整个执行流程，执行完一个基本块后通过改变v17的值跳到下一个基本块，例如图中标黄的v17==-1882529108，那么下一个块就是最上面的++v20,–v21。所以控制流平坦化主要是打乱代码块的先后顺序，让代码的执行流程没有这么明显、直接。\n\n### 2．指令替代\n\n通过把简单的指令变为更加复杂的指令，我们可以把汇编代码换为许多相似的指令，我们写了另一个类似的程序，并对其用指令替代进行混淆。这次，我们把重点放在以下几条C代码上：\n\n```c++\n........................\na[(i+1)%16]^=char(0x52);\n........................\n```\n\n对于异或语句，逆向后的汇编代码如图5：\n\n![1573130730912](clip_image010.gif)\n\n​                                     <center>图5 指令替代之前异或语句汇编代码</center>\n\nF5为C代码，如图6：\n\n![1573130812706](clip_image012.gif)\n\n​                                     <center>图6 指令替代之前异或语句反汇编代码</center>\n\n进行指令替代后语句汇编代码如图7：\n\n![1573130921334](clip_image014.gif)\n\n​                                       <center>图7 指令替代之后异或语句汇编代码</center>\n\nF5为C代码，如图8：\n\n![1573130948253](clip_image016.gif)\n\n​                                    <center>图8 指令替代之后异或语句反汇编代码</center>\n\n可以看到，整个代码的逻辑变得比较复杂，并不能看出来是异或0x52，给整个逆向分析带来了很大困难。\n\n### 3．虚假控制流\n\n和控制流平坦化类似，混淆控制流也是通过混淆控制流程以达到干扰程序分析的目的。但和控制流平坦化不一样，虚假控制流其实是通过增加一些完全无用的分支跳转以达到混淆控制流程的目的，在对上述程序进行修改后，我们首先在不加混淆的情况下进行逆向，得到的控制流图如图9：\n\n![1573216331690](clip_image018.gif)\n\n​                                          <center>图9 虚假控制流操作前的控制流程图</center>\n\n可以看到，整个程序的结构十分清晰，这样逆向分析起来也是十分容易的。\n\n现在我们对其进行虚假控制流混淆，混淆后的程序流程图如图10：\n\n![1573216442789](clip_image020.gif)\n\n​                                       <center>图10 虚假控制流操作后的控制流程图</center>\n\n可以看出，混淆后的程序不仅有了更多更复杂的分支，代码块也更加碎片化。图11中是反汇编为C语言后的代码：\n\n![1573216604570](clip_image022.gif)\n\n​                     <center>图11虚假控制流操作后的反汇编代码</center>\n\n 看到具体代码，我们可以发现这里面加了很多的标签（LABEL），还有不少的goto语句，正是这些跳转，使得程序流程更加复杂。而整个while循环和if语句的执行条件，更是加大了逆向分析的难度。","tags":["project"],"categories":["project"]},{"title":"对音频缓存加密的探讨","url":"/2020/02/17/对音频缓存加密的探讨/","content":"\n关键词：缓存解密，批量自动执行脚本，版权保护相关建议。\n\n![img](1.png)\n\n前段时间，某音乐被爆其缓存文件只使用了简单的异或加密，且容易得到加密密钥为0xa3。[原文链接点击这里]( https://forum.90sec.com/t/topic/38/9 )。以下是我的延伸探讨。\n\n## 1.对音频缓存的批量解密攻击\n\n抱着好奇的心理，我把手机里面该音乐的缓存转到了电脑上面，如图：\n\n![img](2.jpg)\n\n据分析这些UC！文件就是加密后的MP3文件。\n\n用010editor打开其中一个文件，发现存在很多0xa3的字符，如果我们断定网易云用的是异或加密，那么极有可能原文就是0x00，那么异或的密钥就是0xa3。还原得到可以被qq音乐播放的mp3文件：\n\n![img](3.jpg)\n\n通过010editor逐一分析，发现加密密钥的确都是0xa3。既然加密密钥都是同一个，那么用010editor手改上百个文件就太难受了，能否写一个脚本或者程序来跑一下呢？\n\n由于我刚学了java，觉得java文件流很不错，于是我就用java编写以下脚本：\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static FileInputStream fis;\n    static  FileOutputStream fos;\n    public static void main(String[] args) throws IOException {\n   // write your code here\n        String path = \"*********\";\n        travelfolder(path);\n    }\n    public static void travelfolder(String path) throws IOException {\n        File file = new File(path);\n        if (file.exists()) {\n            File[] files = file.listFiles();\n            if (null != files) {\n                for (File file2 : files) {\n                    if (file2.isDirectory()) {//文件夹\n                        System.out.println(\"进入文件夹:\" + file2.getAbsolutePath());\n                        travelfolder(file2.getAbsolutePath());//深度优先遍历算法\n                    }\n                    else {\n                        //普通文件\n                        if(file2.getName().substring(file2.getName().length()-3).equals(\"mp3\"))\n                        {\n                            //这些是已经改好的文件，不必修改\n                            System.out.println(\"MP3文件:\" + file2.getAbsolutePath());\n                        }\n                        else if(file2.getName().substring(file2.getName().length()-3).equals(\"uc!\"))\n                        {\n                            //这些文件还没修改\n                            System.out.println(\"UC!文件:\" + file2.getAbsolutePath());\n                            fis = new FileInputStream(file2);\n                            File newfile = new File(file2.getName().substring(0,file2.getName().length()-4));//把uc!文件变为mp3文件\n                            fos = new FileOutputStream(path+\"\\\\\"+newfile);\n                            byte[] buf = new byte[1024];//缓冲区\n                            int length = 0;\n                            while((length = fis.read(buf)) != -1){\n                                for(int i=0;i<length;i++)\n                                {\n                                    buf[i]^=0xa3;//还原\n                                }\n                                fos.write(buf);\n                            }\n                            fis.close();\n                            fos.close();\n                        }\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"文件不存在!\");\n        }\n    }\n}\n\n```\n\n于是开始运行这段代码：\n\n![img](4.jpg)\n\n运行后就得到了我们想要的mp3文件啦！\n\n![img](5.jpg)\n\n## 2.音频缓存加密过于简单的原因\n\n当然，音频的缓存文件是不可能太过于复杂的，我们听音频的时候，是很讲求时效性的，如果使用太复杂的加密方式，那么可能会导致播放器卡顿。使用异或的加密方式，虽然不太安全，但是还原起来还是很容易的。有时候，安全和性能往往会相互牵制，因此对产品开发者来说，需要把握好安全和性能间的平衡。当然，该音乐应用对安全的把握其实是不太好的，因为解密一首音乐，甚至可以不用写脚本。\n\n## 3.对音频缓存加密方式的建议\n\n其实该音乐应用可以改进加密算法，提高密钥空间的分析。\n\n市面上目前也有很多音乐应用，使用了比较好的加密算法。\n\n例如qq音乐采用了tea加密。如果tea加密比较复杂的话，我认为用维吉尼亚加密也可以，但是注意密钥要稍微长一些，不然通过对文件头的分析是可以把密钥给重新还原的。","tags":["project"],"categories":["project"]},{"title":"ACTF新人赛密码学部分考察点与题解","url":"/2020/02/16/ACTF新人赛密码学部分wp/","content":"\n关键词：密码学，CTF出题，题解。\n\n具体的题目，考点，题解请见[项目链接](https://github.com/CSUAuroraLab/ACTF_Junior_2020)。\n\n新生赛是我进入实验室以来参与出题的第一场比赛。为了这个比赛，我在平时还是做了一些积累，只有有灵感，我就着手开始写出题脚本和解题脚本，然后有一道自己完成不了的题目就麻烦DJ学长帮我写了一下，在这里感谢DJ学长啦！第二次在gitea上协作完成项目，无论是实验室的同学，学长，学弟还是河北师范的同学都给予了我很大的帮助。这次我吸取了之前密码学实验项目的教训，对于分支，调试，校对，发布的流程有了更多的了解。另外这次出题，在苏洋同学的帮助下我终于开始用git bash了，这也为我后面自学开博客打下了基础。最后，这次我也格外注重了文档的规范性，每一道题目都提前按格式把出题方向，题解，源代码，发布的题目，提示，题干，hint给写好了。![出题文件层次分明](1.png)\n说起这次题目的遗憾，就是有两道稍微有难度而又很有意思的题目没有放上来。看了大家的做题情况，密码学的题目基本上都还是几位同学在做。所以对于更加复杂的两道题目，我认为没有必要这么早放上来了，等到校赛吧，等着你们成长。我看到同学们也努力了，比如某位同学，辛辛苦苦终于解出了一道维吉尼亚，当然他一开始对维吉尼亚有些误解，也问了我，最后独立的把题目解了出来。我觉得不管能不能解出题目，只要题目足够有意思，大家足够享受这个过程，就够了。还有一个比较悲剧的，就是没想到杂项出题的学长会和我出了同一个考点，面对着90%以上的题目相似度，我觉得学长题目内容的确更简洁一些，而我的题干更好一些，于是我就放弃了我的那道题目，把自己的题干放到了杂项的那道题目那里。杂项密码学也有千丝万缕的联系呢，少一道也不亏。以下是同学们的完成状况：\n![2](2.png) ![3](3.png) ![4](4.png) ![5](5.png) ![密码学题目完成情况](6.png) ![杂项题目完成情况](7.png)\n从同学们的完成状况来看，密码学的确没有杂项，逆向和web那么受欢迎，究其原因，应该是密码学的就业面没这么大，而且理论相对深奥，难度较大。但是我认为密码学一直都是挺有意思的存在，多了解一些密码学的知识点总是好的，如果的确有能力，可以做做密码学的研究；觉得自己能力不够的话，退而研究算法，或者在信息安全的其他方面引入密码学的知识，活学活用也很不错。好了，接下来就是这次的wp，我觉得自己这次的题目还是偏简单了一些，和CTF有比较大的差别，另外为了使一道题目有更多的考点，也更加有趣，我的确准备了很多的压缩包密码，所以遭到了一些吐槽。不过也没关系啦，继续完善一下自己，争取校赛能提供更好的题目！\n\n## classic0\n\n#### 题干\n\n小Z用C语言编写了一个最简单的密码系统，里面都采用的是最简单的古典加密。但是他的源程序不幸泄露，聪明的你能否解读他采用的算法并进行解密？flag格式为actf{***}\n\n#### 考察点\n\n凯撒，异或，编程能力，生日字典\n\n#### hint\n\n字典\n\n#### writeup\n\n题目给出了密文还有一个生日字典加密后的加密脚本压缩包。如果你够厉害，当然你可以直接根据密文来解啦，不过就是两种加密合在一起，不是简单凯撒，所以有一定难度。\n\n不过如果你知道生日字典攻击的话，不妨拿个工具跑一下，那么很快就可以得到结果了，最后写出解题代码：\n\n```c\n#include<stdio.h>\n\nchar flag[25] = {\"Ygvdmq[lYate[elghqvakl}\"};\n\nint main()\n{\n\tint i;\n\tfor(i=0;i<25;i++)\n\t{\n\t\tflag[i] ^= 0x7;\n        flag[i] += 3;\n\t\tprintf(\"%c\",flag[i]);\n\t}\n}\n\n```\n\n注意，有个地方的字符不是空格也不是'.'！不过你是可以用winhex或者010editor看到它具体的值的，这个值是7f。\n\n#### 附：加密源代码\n\n```c\n#include<stdio.h>\n\nchar flag[25] = {\"actf{my_naive_encrytion}\"};\n\nint main()\n{\n\tint i;\n\tfor(i=0;i<25;i++)\n\t{\n\t\tflag[i] -= 3;\n\t\tflag[i] ^= 0x7;\n\t\tprintf(\"%c\",flag[i]);\n\t}\n\treturn 0; \n}\n\n```\n\n## classic1\n\n#### 题干\n\n维吉尼亚加密是极其经典的古典密码，flag格式为actf{}，明文中的字母均为小写\n\n#### 考察点\n\n键盘密码，维吉尼亚密码\n\n#### hint\n\n1.谜底就在谜面上\n\n#### writeup\n\n压缩包密码是一个键盘密码，稍微熟悉键盘的同学低下头看看，然后再看到密文里面“,.;”这一连串字符，应该会有些感觉。这些密文里面都是一个圈这样围在一起的，里面那个就是明文。key为circle。\n\n这里的维吉尼亚密码，由于密文比较短，频率分析不管用，看一下题干，flag的格式已经给出，稍微尝试一下，得到加密密钥的值为sp，然后即可解决。\n\n#### 附：加密源代码\n\n```c\n#include<stdio.h>\n#include<iostream>\n\n#define CYPHERLEN 31 \n#define KEYLEN 2\n\nusing namespace std;\n\nint main()\n{\n\tchar str[CYPHERLEN]={0};\n\tchar key[3]=\"sp\"; \n\tint i; \n\tfor(i=0;i<CYPHERLEN;i++)\n\t{\n\t\tscanf(\"%c\",&str[i]);\n\t}\n\tfor(i=0;i<CYPHERLEN;i++)\n\t{\n\t\tif(isupper(str[i])||islower(str[i]))\n\t\t{\n\t\t\tstr[i]=toupper(str[i]);\n\t\t\tstr[i]-='A';\n\t\t\tstr[i]+=(key[i%KEYLEN]-'a');\n\t\t\tstr[i]%=26;\n\t\t\tstr[i]+='A';\n\t\t}\n\t}\n\tfor(i=0;i<CYPHERLEN;i++)\n\t{\n\t\t\tprintf(\"%c\",str[i]);\n\t}\n\treturn 0;\n } \n```\n\n## des-mailbox\n\n#### 题干\n\n小Z自创了一套DES加密方法。他悄悄告诉你，这是你们传递秘密的信箱，所以想要获得他的秘密很简单，动动小脑袋瓜和小手指头就可以啦！flag格式为actf{***}\n\n#### 考察点\n\nC语言强制转换，DES相关编程\n\n#### hints\n\n1.type casting\n2.In fact, that is not completely how DES work. We divided the process into several steps.\n3.the keys are just overthere.\n\n#### writeup\n\n首先要知道这个是一个强制转换，把字符转为浮点数，我们用puts即可把浮点数转换为字符，解出key。\n\n```c\n#include<stdio.h>\n\n\nint main()\n{\n\tfloat f[]={\n\t72143238992041641000000.000000,\n    77135357178006504000000000000000.000000,\n    1125868345616435400000000.000000,\n    67378029765916820000000.000000,\n    75553486092184703000000000000.000000,\n    4397611913739958700000.000000,\n    76209378028621039000000000000000.000000\n    };\n\tputs((char*)f);\n } \n\n```\n\n然后就可以看到des.py，里面子密钥都给出了，解密不就只是安装一个密码学包然后再用回密钥解密就行了嘛。\n\n```python\nimport pyDes\nimport base64\nfrom FLAG import flag\ndeskey = \"********\"\nDES = pyDes.des(deskey)\nDES.setMode('ECB')\nDES.Kn = [\n\t\t\t[1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0],\n\t\t\t[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0], \n\t\t\t[0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0],\n\t\t\t[1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1], \n\t\t\t[0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n\t\t\t[0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0],\n\t\t\t[0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],\n\t\t\t[0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0],\n\t\t\t[1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0],\n\t\t\t[0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0],\n\t\t\t[0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1],\n\t\t\t[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0],\n\t\t\t[1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0],\n\t\t\t[1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1],\n\t\t\t[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1],\n\t\t\t[1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1]\n\t\t]\ncipher_list = b'vrkgBqeK7+h7mPyWujP8r5FqH5yyVlqv0CXudqoNHVAVdNO8ML4lM4zgez7weQXo'\nprint(DES.decrypt(base64.b64decode(cipher_list)))\n```\n\n#### 出题源代码\n\n**强制类型转换**（这个思路要感谢DJ学长，最初的出处请见afctf第一届初赛，我在此基础上对代码做了一些调整）\n\n```c\n#include <stdio.h> \nchar flag[32]=\"Interestring Idea to encrypt\";\n \nint main() \n{    \n\tfor(int i=0;i<7;++i)\n\t{        \n\t\tprintf(\"%20f\\n\",*(float*)(flag+i*4));    \n\t} \n\tprintf(\"%20f\\n\",*(float*)(\"\"))  ; \n\treturn 0; \n}\n\n```\n\n**des加密代码**（这个思路主要来自于湖湘杯2019）\n\n```python\nimport pyDes\nimport base64\nfrom FLAG import flag\ndeskey = \"********\"\nDES = pyDes.des(deskey)\nDES.setMode('ECB')\nDES.Kn = [\n\t\t\t[1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0],\n\t\t\t[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0], \n\t\t\t[0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0],\n\t\t\t[1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1], \n\t\t\t[0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n\t\t\t[0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0],\n\t\t\t[0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],\n\t\t\t[0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0],\n\t\t\t[1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0],\n\t\t\t[0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0],\n\t\t\t[0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1],\n\t\t\t[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0],\n\t\t\t[1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0],\n\t\t\t[1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1],\n\t\t\t[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1],\n\t\t\t[1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1]\n\t\t]\ncipher_list = base64.b64encode(DES.encrypt(flag))\n#b'vrkgBqeK7+h7mPyWujP8r5FqH5yyVlqv0CXudqoNHVAVdNO8ML4lM4zgez7weQXo'\n\n```\n\n## music\n\n注：由于考察点重复，最后关头我把题目去掉了\n\n#### 题干\n\n小Z喜欢听音乐，可是他不是VIP，也不想花钱下载音乐，可是你却在无意中发现了他拥有大量的音乐资源。试问，他是怎么做到的？flag格式为actf{***}\n\n#### 考察点\n\n音频解密（接近于杂项）\n\n灵感来源于学长分享的一片文章，我还对这篇文章提出了一些改进（即批量音频解密），然后把原文和改进后的文章一起发到了公众号“中南极光网安实验室”上。\n\n#### hint\n\n1.当你欣赏音乐的时候，记得打开文件看看哦\n\n#### writeup\n\n这道题其实是出自我的那篇推送文章的。自从XX音乐被爆只采用简单的异或加密以后，我就获得和很多首好听的歌曲。当然，这次的密钥不是0xa3，但分析方法一样。用010editor等十六进制编辑工具打开文件，看到文件里面大部分值为0x36，所以考虑到密钥的值为0x36，所以异或一下。\n\nflag不在音频里面，为了表彰一下大家，只需要去文件里面搜一下字符串即可。然后在文章结尾找到的是一串base64，解密一下即可。\n\n#### 题目源代码\n\n本次题目的编写没有用脚本，用的是010editor自带的异或功能。不过想要看批量解密的话，可以去公众号看，博客已经在路上了。\n\n## rsa0\n\n#### 题干\n\n看看rsa的资料，学学python吧，这种简单题绝对不卡你！flag格式为actf{***}\n\n#### 考察点\n\n压缩包伪加密，RSA基础知识与参数\n\n#### hint\n\n1.搞清楚各个参数的意义\n\n#### writeup\n\n都说了是压缩包伪加密，解决一下应该不难。\n\n然后里面是最简单的rsa了，看一下资料应该能解决。\n\n脚本\n\n```python\nimport gmpy2\nfrom Cryptodome.Util.number import *\np = 9018588066434206377240277162476739271386240173088676526295315163990968347022922841299128274551482926490908399237153883494964743436193853978459947060210411\nq = 7547005673877738257835729760037765213340036696350766324229143613179932145122130685778504062410137043635958208805698698169847293520149572605026492751740223\ne = 65537\nc = 50996206925961019415256003394743594106061473865032792073035954925875056079762626648452348856255575840166640519334862690063949316515750256545937498213476286637455803452890781264446030732369871044870359838568618176586206041055000297981733272816089806014400846392307742065559331874972274844992047849472203390350\nphi = (p-1)*(q-1)\nn = p*q\nd = gmpy2.invert(e,phi)\nm = pow(c,d,n)\nprint (long_to_bytes(m))\n\n```\n\n#### 出题源代码\n\n```python\nfrom Cryptodome.Util.number import *\nimport random\n\nFLAG=#hidden, please solve it\nflag=int.from_bytes(FLAG,byteorder = 'big')\n\n\np=getPrime(512)\nq=getPrime(512)\n\nprint(p)\nprint(q)\nN=p*q\ne=65537\nenc = pow(flag,e,N)\nprint (enc)\n\n```\n\n## baby-aes\n\n#### 题干\n\nAES是一种十分高效安全的对称加密方式，在现代密码学中有着举足轻重的地位。小Z对此很放心，于是就写了一个脚本用AES加密，你能获得他的明文嘛？flag格式为actf{***}\n\n#### 考察点\n\naes中的弱点（密钥），密钥、iv的作用，爆破\n\n#### hint\n\n1.现代密码的薄弱点在哪里\n\n#### writeup\n\n注意一下，这里的key和iv，虽说key是32字节，但是存在很多重复的现象。而且为了降低运算复杂度，我把key和iv的异或值给了处理。所以，我们只需要爆破即可，时间复杂度为256的二次方=65526次\n\n脚本如下（时间不长，就懒得写break了）\n\n```python\nfrom Cryptodome.Cipher import AES\nimport os\nfrom Cryptodome.Util.number import *\nimport gmpy2\n\ndef main():\n    enc_flag=b'\\x8c-\\xcd\\xde\\xa7\\xe9\\x7f.b\\x8aKs\\xf1\\xba\\xc75\\xc4d\\x13\\x07\\xac\\xa4&\\xd6\\x91\\xfe\\xf3\\x14\\x10|\\xf8p'\n    xornum=91144196586662942563895769614300232343026691029427747065707381728622849079757\n    for i in range(0,256):      \n        for j in range(0,256):\n             num=i*256+j\n             subkey=long_to_bytes(num).ljust(2,b'\\x00')\n             key=subkey*16\n             iv=long_to_bytes(bytes_to_long(key)^xornum)[-16:].ljust(16,b'\\x00')\n             aes=AES.new(key,AES.MODE_CBC,iv)\n             flag = aes.decrypt(enc_flag)\n             if(flag[:4]==b'actf'):\n                 print(flag)\n\nif __name__==\"__main__\":\n    main()\n\n```\n\n#### 出题源代码\n\n```python\nfrom Cryptodome.Cipher import AES\nimport os\nimport gmpy2\nfrom flag import FLAG\nfrom Cryptodome.Util.number import *\n\ndef main():\n    key=os.urandom(2)*16\n    iv=os.urandom(16)\n    print(bytes_to_long(key)^bytes_to_long(iv))\n    aes=AES.new(key,AES.MODE_CBC,iv)\n    enc_flag = aes.encrypt(FLAG)\n    print(key)\n    print(iv)\n    print(enc_flag)\n#91144196586662942563895769614300232343026691029427747065707381728622849079757\n#b'\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81'\n#b'\\x87lQbI0\\xfc\\xe6\\xaa\\x05P\\xb1\\x01\\xd1pL'\n#b'\\x8c-\\xcd\\xde\\xa7\\xe9\\x7f.b\\x8aKs\\xf1\\xba\\xc75\\xc4d\\x13\\x07\\xac\\xa4&\\xd6\\x91\\xfe\\xf3\\x14\\x10|\\xf8p'\nif __name__==\"__main__\":\n    main()\n\n```\n\n## rsa3\n\n#### 题干\n\n安全的密码算法，往往找不到任何的规律和联系。小Z由于学艺不精，无意中设计了一套极其危险的密码算法，你能帮忙破解一下这个密码算法中的秘密嘛？flag格式为actf{***}\n\n#### 考察点\n\n经典费马分解\n\n#### hint\n\n1.RSA常见的攻击方式\n\n#### writeup\n\n其实这道题和省赛拿到没做出来的题目考点是一样的，所以那次省赛我已经有脚本了，但是省赛题目不应该这么出，怎么到了最后变成了电脑性能的较量。。\n\n我觉得要考费马分解应该这样出：大家可以看到，题目中的两个素数之间相隔很近，这就给费马分解提供了机会（虽然我不知道网上有没有像我一样用这个next_prime这个函数的，但是意思应该也会相近），大家可以上网查查相关资料，省赛的时候一个学弟的脚本挺不错的，还多线程。但是我当时候的脚本和他写得不一样，当然也能解出来，不过哪时间复杂度可能稍慢一些，现在给出我的脚本：\n\n```python\nimport gmpy2\nfrom Cryptodome.Util.number import *\nn=177606504836499246970959030226871608885969321778211051080524634084516973331441644993898029573612290095853069264036530459253652875586267946877831055147546910227100566496658148381834683037366134553848011903251252726474047661274223137727688689535823533046778793131902143444408735610821167838717488859902242863683\nc=1457390378511382354771000540945361168984775052693073641682375071407490851289703070905749525830483035988737117653971428424612332020925926617395558868160380601912498299922825914229510166957910451841730028919883807634489834128830801407228447221775264711349928156290102782374379406719292116047581560530382210049\ne=65537\n\nfor b in range(0,10000):\n    a=gmpy2.iroot(n+b*b,2)[0]\n    if(a*a-b*b==n):\n        p=a+b\n        q=a-b\n        break;\nassert(p*q==n)\nphi = (p-1)*(q-1)\nd = gmpy2.invert(e,phi)\nm = pow(c,d,n)\nprint (long_to_bytes(m))\n\n```\n\n我通过修改学弟的脚本也可以解决这道题。\n\n```python\nimport threading\n\ndef isqrt(n):\n    x = n\n    y = (x + n // x) // 2\n    while y < x:\n      x = y\n      y = (x + n // x) // 2\n    return x\n\ndef Fermat(num, x):\n    y2 = x*x - num;\n    y = isqrt(y2);\n    if y*y == y2:\n        print([x+y, x-y]);\n\nif __name__ == \"__main__\":\n    num = int(input('n='))\n    x = isqrt(num)\n    if x*x < num:\n        x += 1\n    i = 1\n    while(i < 1e20):\n        threads = []\n        for j in range(40):\n            t = threading.Thread(target = Fermat, args = (num, x))\n            i += 1\n            x += 1\n            threads.append(t)\n        for t in threads:\n            t.start()\n        for t in threads:\n            t.join()\n```\n\n用这段代码可以在短时间内解出p,q。\n\n#### 出题源代码\n\n```python\nfrom flag import FLAG\nfrom Cryptodome.Util.number import *\nimport gmpy2\nimport random\n\ne=65537\np = getPrime(512)\nq = int(gmpy2.next_prime(p))\nn = p*q\nm = bytes_to_long(FLAG)\nc = pow(m,e,n)\nprint(n)\nprint(c)\n\n```\n\n## TinySPN(by [DJ学长](https://csuwangj.github.io/))\n注：出题方向是我提出的，但是这里面的题干，源代码和解题脚本都是[DJ学长](https://csuwangj.github.io/) 写的，我只负责把它放到服务器上，并且写出交互代码。\n\n#### 题干\n\nSPN is a classical design patter in cryptography.\n\nnc 47.103.117.169 10003\n\nflag格式为flag{***}\n\n#### 考察点\n\n线性/差分密码分析，交互\n\n#### hint\n\n1. what is SBOX?\n2. why can't we replace SBOX in cipher?\n\n#### writeup\n\n###### TL;DR\n\nattack simple SPN by chosen-plaintext attack, use linear cryptanalysis or differential cryptanalysis will break it. [exp](exp.py) use linear cryptanalysis.\n\n###### Detail\n\nbecause this SPN cipher is so simple, so we just need following steps.\n\n1. get LAT, like [example](lat.py)(Linear Approximation Table).\n2. find one path with high bias.\n3. collecting enough plaintext-cipher pairs.\n4. extracting key from pairs.(check exp for more details).([linear_cryptanalysis.py](linear_cryptanalysis.py) is a example of this step, but code is like a shit so you'd better forget it.)\n5. decrypt flag.\n\n[test.py](test.py) is my test data, ignore it.\n\nif SBOX is so good that can't break it, record it and replay exp~\n\n[send me](mailto:CSUwangj@protonmail.com) this SBOX so that I can post it~\n\n###### exp\n\n```python\n#!/usr/bin/python3\n\nfrom typing import List, Tuple\nfrom tqdm import tqdm\n# import test\n# import pysnooper\nfrom util import doxor, doin, trans_inv, SZ\nfrom binascii import unhexlify\nfrom codecs import encode\nimport random\nimport pwn\n\ndef maskeq(a: int, b: int) -> bool:\n    c: int = 0\n    while b > 0:\n        if b&1:\n            c ^= (a&1)\n        b //= 2\n        a //= 2\n    return c==0\n\ndef LAT(sbox: List[int]) -> List[List[int]]:\n    count = []\n    for row in tqdm(range(256), desc=\"compute LAT\"):\n        count.append([])\n        for col in range(256):\n            cnt = -128\n            bitmask = (row << 8) | col\n            for i in range(256):\n                if maskeq((i << 8) | sbox[i],  bitmask):\n                    cnt += 1\n            count[row].append(abs(cnt))\n        count[row].append(row)\n    return count\n\ndef check(num: int, bitmask: int) -> bool:\n    a = 0\n    while bitmask > 0:\n        if bitmask & 1 == 1:\n            a ^= num & 1\n        bitmask //= 2\n        num //= 2\n    return a == 0\n\ndef check_key(text_pairs: List[Tuple[int, int]], sbox: List[int], key: int, mask: int) -> int:\n    cnt = 0\n    for text_pair in text_pairs:\n        (plain, cipher) = text_pair\n        mid = cipher ^ key\n        mid = sbox[mid] \n        if check((plain << 8) | mid, mask):\n            cnt += 1\n    return cnt\n\n# @pysnooper.snoop()\ndef decrypt(sbox, sboxi, ct, k):\n    pt = ''\n    for i in range(0, len(ct), SZ):\n        res = decrypt_block(sbox, sboxi, ct[i:i+SZ], k)\n        pt += ''.join(map(chr, res))\n    return pt\n\ndef decrypt_block(sbox, sboxi, pt, ks):\n    cur = doxor(pt, ks[SZ:])\n    cur = list(map(lambda x:sbox[x], cur))\n    cur = trans_inv(cur)\n    cur = list(map(lambda x:sboxi[x], cur))\n    cur = doxor(cur, ks[:SZ])\n    return cur\n\ndef compute_frontkey(sbox, sboxi, pt: List[int], ct: List[int], lastkey: List[int]) -> List[int]:\n    cur = doxor(ct, lastkey)\n    cur = list(map(lambda x:sbox[x], cur))\n    cur = trans_inv(cur)\n    cur = list(map(lambda x:sboxi[x], cur))\n    return doxor(cur, pt)\n\ndef doin(x):\n    return list(unhexlify(x))\n\ndef doout(x):\n    tmp = ''.join(map(chr, x))\n    return (encode(tmp.encode(), 'hex')).decode()\n\ndef main():\n    # pwn.context.log_level = \"DEBUG\"\n    # io = pwn.remote(\"192.168.16.128\", 9999)\n    io = pwn.process(\"../src/server.py\")\n    sbox_str = io.readline()\n    sbox: List[int] = list(map(int, sbox_str[1:-2].split(b\",\")))\n    sboxi: List[int] = []\n    for i in range(256):\n        sboxi.append(sbox.index(i))\n    # print(sbox)\n    flag_ct = doin(io.readline().strip())\n    # print(flag_ct)\n    pts: List[str] = []#test.pt\n    cts: List[str] = []#test.ct\n    for i in tqdm(range(2048), desc=\"collect plaintext-cipher paits\"):\n        pt = random.randint(0, (1<<64)-1)\n        pt = \"{:016x}\".format(pt)\n        io.sendline(pt)\n        ct = io.readline().strip()\n        pts.append(pt)\n        cts.append(ct)\n    # print(\"pt0: {}\".format(pts[0]))\n    # print(\"ct0: {}\".format(cts[0]))\n    lat = LAT(sbox)\n    ptx = list(map(lambda x:(int(x[0:2], 16)), pts))\n    key = []\n    for i in range(8):\n        ctx = list(map(lambda x:(int(x[i*2:i*2+2], 16)), cts))\n        lat.sort(key=lambda x:x[(1<<(7-i))], reverse=True)\n        # print(\"{}th byte is for LT{}\".format(i, lat[0][256]))\n        res = []\n        for k in tqdm(range(256), desc=\"compute {}th byte of key\".format(i+9)):\n            res.append((k, abs(check_key(zip(ptx, ctx), sbox, k, (lat[0][256]<<8) |0b10000000)-(len(pts)//2))))\n        res.sort(key=lambda x: x[1], reverse=True)\n        key.append(res[0][0])\n        # print(res)\n        # print(\"{}th key is {:02x}\".format(i+9, res[0][0]))\n    pt1 = doin(pts[0])\n    ct1 = doin(cts[0])\n    key = compute_frontkey(sbox, sboxi, pt1, ct1, key) + key\n    print(\"computed key: {}\".format(doout(key)))\n    # print(key)\n    ans = decrypt(sbox, sboxi, flag_ct, key)\n    if ord(ans[-1]) < 9:\n        ans = ans[:-ord(ans[-1])]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n#### 题目源代码\n\n```python\n#!/usr/bin/python3\n\nimport os\nfrom binascii import hexlify, unhexlify\nimport Crypto.Random.random as random\nfrom secret import flag\n\nSZ = 8\n\nsbox = list(range(256))\nrandom.shuffle(sbox)\nsboxi = []\nfor i in range(256):\n    sboxi.append(sbox.index(i))\n\ndef doxor(l1,l2):\n    return [x[0]^x[1] for x in zip(l1,l2)]\n\ndef trans(blk):\n    res = []\n    for k in range(0, SZ, 8):\n        bits = [bin(x)[2:].rjust(8,'0') for x in blk[k:k+8]]\n        for i in range(8):\n            res.append(int(''.join([x[i] for x in bits]),2))\n    return res\n\ndef encrypt_block(pt, ks):\n    cur = doxor(pt, ks[:SZ])\n    cur = [sbox[x] for x in cur]\n    cur = trans(cur)\n    cur = [sboxi[x] for x in cur]\n    cur = doxor(cur, ks[SZ:])\n    return cur\n\ndef encrypt(pt, k):\n    x = 0 if len(pt)%SZ==0 else (SZ-len(pt)%SZ)\n    pt += [x]*x\n    ct = ''\n    for i in range(0, len(pt), SZ):\n        res = encrypt_block([x for x in pt[i:i+SZ]], k)\n        ct += ''.join([\"{:02x}\".format(xx) for xx in res])\n    return ct\n\ndef doout(x):\n    if len(x) % 16:\n        x = (16 - len(x) % 16) * \"0\" + x\n    return x\n\ndef doin(x):\n    return list(unhexlify(x))\n\ndef genkeys():\n    return list(os.urandom(2*SZ))\n\nif __name__ == \"__main__\":\n    print(sbox)\n    key = genkeys()\n    ct = encrypt(flag, key)\n    print(ct)\n    while True:\n        pt = doin(input())\n        print(doout(encrypt(pt, key)))\n```\n\n","tags":["project","competition","auroralab"],"categories":["auroralab"]},{"title":"about me","url":"/2020/02/15/about-me/","content":"\n关键词：个人自述，todolist。\n\n说来惭愧，写了很多的日记，也写过几篇可以充当作业或者领稿费的小文章，也发了很多的说说和pyq，但是发博客确是第一次。在朋友们都已经创办了属于自己的公众号，博客或者专刊的时候，我却才在blog上发表我的第一篇文章。现在，我愿意把我自己的所思所感已经之前写过的一部分日记形成文字，以展现一个真实的自己。\n\n为什么我忽然想到要写博客呢？\n\n其实，我在github上也算是个新手，但陆陆续续的参与了一些项目，并且承办了这次新人赛上密码学大部分的出题工作以后，每次有人来问我的github网址邀请我的时候，我不禁感到不好意思。怎么能给别人一个空白的github网址呢，感觉自己就像圈外人一样，人家计算机爱好者都在这里讨论问题，合作完成项目，而我虽然有兴趣，但是行动上却没有跟上来。所以我觉得得抓紧完善打理一下自己的博客，“打扫干净房子再请客”，所以就连着一晚简简单单的弄了一个博客。\n\n另外，我觉得我有必要做一个生产者，写点有意义的所思所感，也可以分享一些技术文章，来做出自己一份微薄的贡献。就像是当时触动我的那个人是这么说的，“ 许许多多的人曾用他们的光芒照亮了我，我也愿接下火炬继续燃烧。记录日常所思所感，是留给未来的诗歌与火光。 ”我觉得，需要把这些光芒传递下去，让火炬继续燃烧。\n\n能把我和我们团队的一些日常经历和idea分享给大家，是一件幸事。祝大家2020年能身体健康，万事如意，学有所成！![2020的祝福](2020.jpg)\n\n---\n\n4.30更新：\n\n这个blog建立到现在，也更新了大约有15次了。其实实践无处不在，每天的作业和实验都是一个难得的动手机会。但是，做作业，多多少少包含着一些被动完成任务的心态。所以最近我把博客上的文章精挑细选了一遍，着重展现我充分调动自己的能动性来完成的课外项目和选做任务，我觉得只有这样，才能体现出更全面的自己。当然，有空的话，一些课内的内容我也会尽快补充。\n\nTODO list：\n\n（1）汇总自己的日常灵感。\n\n（2）更新一些日常学习相关的博文，例如学习笔记，课程作业，实践作业及完成思路等。\n\n（3）更新一些比赛和项目相关的博文，整理以往CTF比赛的wp，天梯赛在PAT平台的训练代码（L1和L2全部），信安作品赛的比赛心得等。\n\n（4）以往的一些日记，包括人生道理的探讨，兴趣爱好及推荐等。","tags":["article","introduction"],"categories":["article"]}]