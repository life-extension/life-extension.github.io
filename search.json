[{"title":"基于门限方案的条形码保密及容错技术","url":"/2020/04/30/基于门限方案的条形码保密及容错技术/","content":"\n经历过初期两个小项目的探索，我们项目团队积累了一定的项目研究经验，在老师和16级学长的帮助下，我们把研究方向转到了门限方案的实际应用上。结合市面上用9张合并的条形码提高条形码的容错能力的操作，我们在保留一定的容错能力的基础上提高条形码的安全性，具体而言就是条形码的保密性和容错能力。\n\n### 背景\n\n依托于信息技术和电子商务的发展，条码技术，作为当今十分流行的一种自动识别与数据采集技术，在商品流通领域被广泛应用。但是在身份识别等应用场景下，传统的条形码不仅易被他人伪造，而且容易导致信息泄露；在恶劣的生产环境中，传统的条形码极有可能因污染损坏导致误读甚至无法识别；此外，常有因传统条形码被覆盖、遮挡或内装物品的安放而造成的条形码弯曲，扫描器无法识别的情况。因此，传统条形码的保密性显得不足，可靠性受到考验。人们急需冗余度高且具有保密能力的条形码，以及在此基础上的自动化扫码系统的大规模使用。\n\n### 主要问题\n\n目前传统的一维条形码的使用范围依然很广。 一维条形码的应用可以提高信息录入的速度，减少差错率，而且标签简单实用易于制作，成本几乎为零。但是一维码的设计从未考虑到保密性和防伪造的问题，以至于所有的消息用手机一扫就明文可见，并且输入同样的明文就可以产生相同的条形码。而且，对于所有条形码而言，冗余度低，破损后无法识别的问题普遍存在。\n\n同时，几乎所有的条形码都面临一个问题——冗余度为0，破损或污染以后即无法识别。\n\n### 解决方案\n\n针对传统一维条形码中存在的冗余度的问题，一些企业把条码重复拼接，以提高条形码的冗余度。这种做法的确大大的提高了条形码的冗余度和可靠性，值得肯定。但是在条码无一例外的重复的同时，我们是否能做一件手到拈来的事情呢？我们可以通过在重复的条形码中加入一些门限方案以及验证条形码，在保证条码可靠性的基础上，顺势达到保密性和防伪造的作用。\n\n为解决以上问题，本团队结合 shamir 门限方案与信息隐藏技术，在保障信息安全的基础上提出了基于门限方案的条形码容错与保密技术，旨在解决破损条形码无法扫描识别与传统条形码保密性差、易被伪造等信息安全问题，并且设计制作了一整套生成高保密新型条形码、读码的客户端软件——SaferBar。\n\n### 实现原理\n\n本方案依托操作简易的手机APP——SaferBar，可以根据客户需求将传统条形码转换成不同冗余度的门限条形码，极大地提高了条形码的容错率与保密性。另外，我们在原有明文的基础上拼接条形码的认证密钥，以达到防止伪造的效果。而且，基于图像识别技术，它同时采集处理多个条形码信息，并同时识别含多个子条形码的新型条形码，提高扫码效率，实现传统条形码与新型条形码的无缝衔接，极大程度地提高了条形码的容错率，防止了信息泄露和信息伪造，保障了商品财产及信息安全。具体流程如下：\n\n#### 生成认证密钥\n\nAPP为每一类商品都设置一个随机生成的认证密钥key，并上传存储在数据库中。通过字符串拼接在原有明文的基础上拼接条形码的认证密钥，以达到防止伪造的效果。解密的时候需要验证key的值是否正确，只有当key值正确时才连接数据库获取商品信息。  \n\n#### 编码与加密\n\n编码环节需要从多方面考虑来确定，如实际的信息量、所选条码的码数限制， 所载信息的可靠性与冗余量的相互取舍关系等。\n\n在条形码选择上，采用 CODE 39 码。这是一种双向扫描的非定长码，即条形码字符个数不是固定的，编码信息可以是数字也可以是大写英文字母码并自带校验码。条形码由九条不同的排列线条编码而得。基于信息冗余提高数据可靠性的思想，每段条形码的最后一位均附带上此条形码的校验位。\n\n生成门限条形码时，初始密钥x为原始的条形码编号。子密钥公式为：\n\n\nf (x)=m+a<sub>1</sub>x+a<sub>2</sub>x<sub>2</sub>+…+a<sub>k-1</sub>x<sub>k-1</sub> mod p\n\n\n以（5,9）型条形码为例：\n\n由（5,9）门限方案可知要将条形码分割成由九块条形码组成的门限条形码，n=9。\n扫描时只要扫描出5块完整内容就可能得到完整的数据，即门限值k=5。\n把编码 x 代入，依次可算出8个门限值yi=f(i),i=1-9；利用条形码换算公式，将 y<sub>1</sub>-y<sub>9</sub> 换算成对应的条形码，形成由九部分组成的门限条形码。如图：\n\n![image-20200430220542949](image-20200430220542949.png)\n\n#### 译码环节\n\n机器扫描门限条形码的过程中，将未被损坏的部分子条形码识别出来，将这些门限值y<sub>i </sub>代入拉格朗日，根据Shamir 的门限秘密共享方案的性质可知，最终一定能得出拼接后的条形码 x，其中包括商品编号以及认证密钥。  \n\n#### 服务器验证与商品信息显示\n\n在拼接后的条形码中获取认证密钥，发送到后端进行校验。服务器中数据库存储格式如下：\n\n![image-20200430224443914](image-20200430224443914.png)\n\n若校验成功，则连接数据库获取商品信息。\n\n![image-20200430224501556](image-20200430224501556.png)\n\n### 项目的意义\n\n项目创新性的提出了基于门限方案的条形码保密及容错方案，推出了一款集保密，防伪造，防污损等功能于一体的新型一维条形码。有以下几项重大意义：\n\n1.解决了一维条形码没有任何保密性和冗余度的现状。\n\n2.使得一维条形码可以在身份认证等应用场景流通。\n\n3.只需其中若干子条形码完整,即可可靠识别出原条形码的信息。\n\n4.可以一次性识别出多条条形码信息,即可一次识别出门限条形码,更加快捷。\n\n5.推广价值。本方案不仅限于条形码,还可用于其他相似领域,如二维码。","tags":["project"],"categories":["project"]},{"title":"多媒体第三次选做实验-图像处理、滤波以及动画效果","url":"/2020/04/23/多媒体第三次选做实验-图像处理、滤波以及动画效果/","content":"\n粗略看了一下要补充的代码，涉及的功能挺多跨度挺广，但是各个功能是相互独立的，所以即使不完成所有的功能，只要不运行相关代码，程序也不会报错。我决定一个一个来，完成后直接测试功能。\n\n### 计算灰度值\n\n计算灰度值的公式在PPT上，对照代码中已经获取了B,G,R的值，只需要保留灰度系数进行运算，注意顺序是B-G-R。\n\n```cpp\n////                   请补充代码-- 计算灰度值，并设置像素的每个通道值为该灰度值\n                      \n                //////////////  开始补充   ///////////////\n\t\t\t\tgray = B * 0.114 + G * 0.587 + R * 0.299;\n\t\t\t\t*(pD + offset) = gray;\n\t\t\t\t*(pD + offset + 1) = gray;\n\t\t\t\t*(pD + offset + 2) = gray;\n                //////////////  结束补充   ///////////////\n```\n\n测试效果过关：\n\n![image-20200423213240919](image-20200423213240919.png)\n\n### 提取水平向边缘和竖直向边缘\n\n水平向边缘的提取是一个卷积运算，而今天所学的好几项功能都需要用到卷积运算。此刻我希望的就是能有一个函数能帮我进行矩阵操作。搜了一下“卷积”，没有找到内容，正当我准备自己写这个函数的时候，我看到代码有提示，直接调用FilterBmp。\n\n浏览了一下FilterBmp的功能和参数，第一个参数是卷积核，第二个和第三个参数是bmp图像，不同的是第二个参数句柄是初始图像的，不用进行修改，而第三个参数需要修改。参考一下其他对FilterBmp的调用形式，我们发现bmp_ori_copy和bmp变量可以利用。\n\n```cpp\n FilterBmp(smooth_kernel, bmp_ori_copy, bmp);\n```\n\n记录一下水平向矩阵和竖直向矩阵的名字，xEdge_kernel和yEdge_kernel，所以补充好代码：\n\n```c++\n ////           请补充代码-- 提取水平向边缘，提示：调用FilterBmp\n                //////////////  开始补充   ///////////////\n\t\t\t\tFilterBmp(xEdge_kernel, bmp_ori_copy, bmp);\n                //////////////  结束补充   ///////////////\n```\n\n```c++\n////           请补充代码-- 提取竖直向边缘，提示：调用FilterBmp\n                //////////////  开始补充   ///////////////\n\t\t\t\tFilterBmp(yEdge_kernel, bmp_ori_copy, bmp);\n                //////////////  结束补充   ///////////////\n```\n\n运行结果是成功的，图像中的边缘被成功提取了出来。\n\n水平边缘图：\n\n![image-20200423214936625](image-20200423214936625.png)\n\n竖直边缘图：\n\n![image-20200423215015872](image-20200423215015872.png)\n\n### 实现图像锐化\n\n这一次提前看到了提示，与IDM_EDGE中的代码有关。IDM_EDGE中实现的功能就是整体边缘提取，边缘图 = 原图 – 模糊图像。而图像锐化的概念是锐化图 = 原图 + 边缘图。所以我们可以得到整体边缘图，再加上原图即可。此刻希望有一个相加函数，就像SubIm1FromIm2一样，结果在函数声明看到了AddIm1ToIm2。实现也就比较简单了。不过在实现前又看到了上面老师注释的一段代码，决定试一试。\n\n![image-20200423220001751](image-20200423220001751.png)\n\n效果还不错，具体看到实现以后，我明白了，原来这幅图是这样实现的：认为总体边缘图=水平边缘图+竖直边缘图，那么锐化图=原图+水平边缘图+竖直边缘图。但是这么实现的**不足之处**就是，代码 AddIm1ToIm2(bmp_ori_copy, bmp)会改变bmp_ori_copy的值，会影响到后面的操作。\n\n那么我自己的实现就只能按照PPT的形式了，先给出代码：\n\n```c++\n ////           请补充代码-- 实现图像锐化，提示：与IDM_EDGE中的代码有关\n                //////////////  开始补充   ///////////////\n\t\t\t\tFilterBmp(smooth_kernel, bmp_ori_copy, bmp);\n\t\t\t\tSubIm1FromIm2(bmp, bmp_ori_copy);\n\t\t\t\tAddIm1ToIm2(bmp_ori_copy, bmp);\n                //////////////  结束补充   ///////////////\n```\n\n再看看效果如何：\n\n不算很明显，不知道有没有成功，这是锐化后的：\n\n![image-20200423220822623](image-20200423220822623.png)\n\n我反而觉得锐化前更清晰一些。\n\n![image-20200423221301931](image-20200423221301931.png)\n\n### 判断鼠标位置并设置对应像素\n\n判断鼠标位置是否在图像内，我们知道图像的长宽，又知道图像没有偏移，起点在（0,0）。因此可以直接判断，这部分代码可以应用老师在FilterBmp的一段代码，但是为了让代码不那么啰嗦，我还是自己写了。另外设置像素值的事情让我想到了保留红色通道。\n\n```c++\n////           请补充代码--实现：判断鼠标位置是否在图像内，并设置对应像素为红色\n            //////////////  开始补充   ///////////////\n\t\t\tif (y >= 0 && y < bmp.bmHeight && x >= 0 && x < bmp.bmWidth)\n\t\t\t//在图像内\n\t\t\t{\n\t\t\t\tBYTE* pD = (BYTE*)bmp.bmBits;\n\t\t\t\tint i = y * bmp.bmWidth + x;\n\t\t\t\tlong offset = i * 4;\n\t\t\t\t*(pD + offset) = 0;\n\t\t\t\t*(pD + offset + 1) = 0;\n\t\t\t\t*(pD + offset + 2) = *(pD + offset + 2); //红色通道\n\t\t\t\t*(pD + offset + 3) = 0; //这是透明度通道\n\t\t\t\tInvalidateRect(hWnd, NULL, true);\n\t\t\t}        \n            //////////////  结束补充   ///////////////\n```\n\n运行的结果就是，能画线，但是位置真好反了过来，就像倒立了一样，所以这个offset抓的是有问题的。\n\n把\n\n```c++\nint i = y * bmp.bmWidth + x;\n```\n\n改为\n\n```c++\nint i = (bmp.bmHeight-y) * bmp.bmWidth + x;\n```\n\n这样一来就解决了问题。\n\n![image-20200423225138987](image-20200423225138987.png)\n\n### 与硬件无关的动画速度  \n\n根据PPT的内容，首先找到代码：\n\n```c++\npreTime = GetTickCount();\n```\n\n这个就是记录当前时间的方法，然后按照PPT上面基本可以补充好如下代码：\n\n```c++\n ////      请补充代码-- 实现与机器速度无关的平移\n    ///         要求实现x = x + animSpeed * deltaTime，其中deltaTime是本次与上次运行之间的时间差\n    //////////////  开始补充   ///////////////\n\tnow = GetTickCount();\n\tdeltaTime = now - preTime;\n\tpreTime = now;\n\tx = x + animSpeed * deltaTime;\n    //////////////  结束补充   ///////////////\n```\n\n运行结果：\n\n![image-20200423225822497](image-20200423225822497.png)\n\n运行成功，点住消息栏不放，小方块不会动，但一旦松开，程序将重新计算deltatime，所以小方块一般会出现较大的位移。","tags":["study"],"categories":["study"]},{"title":"基于win32 GDI的图像显示方法选做实验笔记","url":"/2020/04/17/基于win32-GDI的图像显示方法选做实验笔记/","content":"\n这是多媒体原理的第二次选做实验，这次为了充分调动自己的主观能动性，我打算自己先写好代码运行程序，然后再去评论区了解到其他同学对待这个问题的思考角度。\n\n### 程序代码与注释\n\n##### 任务一：修改画布内容，只显示G通道\n\n这段代码其实是老师在视频中重点讲解演示过的，不过当时的对象是红色通道。视频中提醒我需要注意的点：BMP中每个像素的存储点是按B-G-R顺序来进行的。我们的目标是对于每个像素点，对画布图片的指针进行操作，只保留绿色通道的值，其他都清零，于是可以补充代码：\n\n```c++\n\t\t\t\t\t\tlong offset = i * 4;\n\t\t\t\t\t\t*(pD + offset) = 0;\n\t\t\t\t\t\t*(pD + offset + 1) = *(pD + offset + 1);//绿色通道\n\t\t\t\t\t\t*(pD + offset + 2) = 0; \n\t\t\t\t\t\t*(pD + offset + 3) = 0; //这是透明度通道\n```\n\n但是我觉得这段代码也存在一些问题。比如我们这里，需要保留G通道的值，所以修改G通道的值的代码貌似是多余的，其他两个通道也是，都有一句代码是多余的，虽然这样更易读，但我还是决定删掉，最终通过测试的一部分代码如下：\n\n```c++\n                    for (long i = 0; i < nP; i++)\n                    {\n                       \n                       //请补充代码--保留G通道的值，把R和B通道值置零\n                       \n                        //////////////  开始补充   ///////////////\n\t\t\t\t\t\tlong offset = i * 4;\n\t\t\t\t\t\t*(pD + offset) = 0;\n\t\t\t\t\t\t*(pD + offset + 2) = 0; \n\t\t\t\t\t\t*(pD + offset + 3) = 0; //这是透明度通道\n                        //////////////  结束补充   ///////////////\n                    }\n```\n\n测试效果也是OK的。\n\n![image-20200417123354912](image-20200417123354912.png)\n\n##### 任务二：倒立图像\n\n在写代码之前，我思考了老师在代码中注释的一个问题，在这段代码中为什么halfline--：\n\n```c++\n\t\t\t\t\tint halfLines = bmp.bmHeight / 2;\n                    if (halfLines * 2 > bmp.bmHeight)\n                        halfLines--; //为什么要进行这个计算？\n```\n\n这段代码是为了找出图片翻转循环的执行次数。在代码上其实还有其他的表示方法，总体的目标就是找到中间行，使得除了中间行（如果存在的话）之外图像收尾对应行的交换，最终实现图像倒立。中间行是不必参与交换的。举个例子，如果图像有10行，从0开始数，那么第4行和第5行需要交换。如果图像有11行，那么第5行固定不动即可。\n\n补充的代码要求将第i行的像素值与垂直方向对应行像素值进行互换，那么按照上面10行的例子，就是第0行和第9行换，halflines是5，推广起来就是第i行和第halflines*2-1-i行换。具体的做法和两个值的交换函数没有区别，可补充代码：\n\n```c++\n                    //请补充代码--将第i行的像素值与垂直方向对应行像素值进行互换\n\n                    //////////////  开始补充   ///////////////\n\t\t\t\t\t*(pD + i * bmp.bmWidthBytes + j) =  *(pD + (halfLines * 2 - 1 - i) * bmp.bmWidthBytes + j);\n\t\t\t\t\t*(pD + (halfLines * 2 - 1 - i) * bmp.bmWidthBytes + j) = midV;\n\n                    //////////////  结束补充   ///////////////\n```\n\n成功完成任务：\n\n![image-20200417130122809](image-20200417130122809.png)\n\n### 讨论与交流\n\n上传任务后，我又去讨论区看了看其他同学的成果。他们大多提到了一个问题，那就是式子：\n\n```c++\nhalfLines * 2 > bmp.bmHeight\n```\n\n是一条永真式。我们讨论了一番，最后还是打算求助老师。","tags":["study"],"categories":["study"]},{"title":"基于CRT的物流信息安全处理方案","url":"/2020/04/15/基于CRT的物流信息安全处理方案/","content":"\n### 引言\n\n在2018年11月份的时候，段老师在密码学课上讲到了密钥分发协议，我当时就觉得这个协议很有意思也很有应用前景。后来老师还很主动地分享了一下它的idea，其中一部分就是有关物流单上的信息安全问题的。这个我深有感触，其实每次处理快递的时候，我都会把快递单撕得粉碎，然后倒进垃圾桶。但是物流过程中的信息泄露的确更让人担心。\n\n老师向我们提出了她的愿景：通过洋葱路由或者密钥分发技术加密快递单上的消息，使得快递在配送的过程中只知道它的上一站和下一站。于是我搭档了两位学习很认真的女同学，打算对基于CRT的物流信息安全处理方案一探究竟。\n\n### 实现过程\n\n基于CRT的理论知识，我们采用二维码技术以及密钥分发技术，提出了一种物流过程信息安全处理方法。这种方法的实施过程如下（设寄件人为p，收件人为q，先后经过快递驿站或快递员A,B,C,D）：\n\n1. **寄件人p通过app填上寄件驿站代号（A）,收件人q的地址、姓名以及app号。**\n\n2. **app终端立即自动生成快递单号以及最短路径，并分割形成相应密文。**\n          App根据寄件驿站与目的地，用迪杰斯特拉算法生成最短路径(p-A-B-C-D-q)，并告知q寄件人的相关信息。然后把路径中除了初始驿站的每一个结点分割出来(B/C/D/收件人姓名和地址)，并一次对每一个文件随机产生一次性密钥(Ks1, Ks2, Ks3, Ks4)，并用AES算法进行加密（生成密文c1,c2,c3,c4）\n\n3. **同时，生成通过中转站私钥生成随机数R，使该站只能解密其下一个站点的信息。**\n         若中转站的私钥为（Ka,Kb,Kc,Kd）：\n      \t（1）A知道下一个地址是B，那么我们可以构造R1使得下列方程组成立:\n      \t\tR1=Ks1(mod Ka)\n      \t\tR1=0(mod Kb)\n      \t\tR1=0(mod Kc)\n      \t\tR1=0(mod Kd)\n      \t（2）B知道下一个地址是C，那么我们可以构造R2使得下列方程组成立:\n      \t\tR2=0(mod Ka)\n      \t\tR2=Ks2(mod Kb)\n      \t\tR2=0(mod Kc)\n      \t\tR2=0(mod Kd)\n      \t（3）C知道下一个地址是D，那么我们可以构造R3使得下列方程组成立:\n      \t\tR3=0(mod Ka)\n      \t\tR3=0(mod Kb)\n      \t\tR3=Ks3(mod Kc)\n      \t\tR3=0(mod Kd)\n      \t（4）D知道下一个地址最终是用户q，那么我们可以构造R4下列方程组成立:\n      \t\tR4=0(mod Ka)\n      \t\tR4=0(mod Kb)\n      \t\tR4=0 (mod Kc)\n      \t\tR4= Ks4(mod Kd)\n\n4. **用二维码对所有密文（c1,c2,c3,c4）与随机数(R1,R2,R3,R4)以及快递单号进行封装**。\n\n5. **寄件。**\n\n   ​       p到A驿站寄件时出示快递单号，系统就会自动把二维码打印出来，由工作人员贴在快递上。同时终端删除路径信息，只留下快递单号和收件人的app号。A驿站派件时，只需要扫描一下二维码查看下一个站点，此时终端自动通过快递号给收件人q发送一条“快递已经在A寄出，下一站是B” 的消息。\n\n6. **中转。**\n\n   ​       到达中转站时，分发人员只需要扫描一下二维码，就可以得到该包裹下一站的信息，但是却得不到其他任何信息。同时通过终端给收件人q发送一条“快递已经到达中转站xx（B/C），下一站是xx（C/D）”的信息\n\n7. **到达。**\n\n   ​       到达最后一个中转站D时，由于扫出的信息带有用户姓名，app自动给用户发送一条“请到D驿站取快递，取件码xxx（随机生成）”的消息。\n\n8. **接收。**\n\n   ​       用户取快递时，只需要通过取件码和姓名取快递即可。若为贵重物品，则只需要拿出app通过快递号验证即可。\n\n### 优点分析\n\n**1.AES算法极大的简化了加密解密的时间，而且安全性也相对较好，资源消耗也较少。**\n\n**2.基于CRT的密钥分发协议，简单易实现，而且计算代价为常数阶。**\n\n**3.通过加密和密钥分发能充分达到保护用户隐私的要求。**\n       由于通过二维码只可以得知快递单号，其余均是密文，不法分子无法从中得到任何有用的信息，所以用户大可抛弃快递单。\n       不仅如此，对各中转站而言，他们也无法从中得到任何有用的信息，因为他们只知道快递的下一个中转站。而对于最后一站，他们尽管可以知道用户在app中的ID和姓名，但是没有电话号码，所以作用也不大。\n**4.用户能够了解物流寄出与派送情况**\n       用户可以通过app发出的消息，先后知道寄件人的信息，快递已经到达的中转站及其下一站，最后知道取件码等信息。所以出现问题也可以问责相关的物流站点。\n\n### 讨论与质疑\n\n我们小组在项目实施过程中，对项目的应用前景提出了如下质疑：\n\n1.流程中存在的漏洞：\n\n​       在设计流程中，我们先让寄件人选择好寄件地址和收件地址，并由算法确定接下来邮件的路径，但这样可能会存在一些非预期问题。如果寄件人说好在A驿站寄件却去了其他驿站，是拒绝派送还是新生成一张存储A驿站信息的二维码，方法有待商榷。另外如果由于工作或者其他原因邮件被寄到了某个不在路径之内的中转站，又应该怎么处理？\n\n2.密钥更新有关问题：\n\n​       分析对中转站密钥穷举攻击的可能性，以及中转站是否需要更换密钥，多久更换密钥。\n\n3.成本与性价比问题：\n\n​       需要分析二维码加密和识别工具的制作成本以及攻击者的攻击成本和可能导致的信息泄露后果，以及加密对快递拣发效率的影响。以确定该方案的性价比是否足够的好。\n\n### 总结与感想\n\n电子商务的快速发展使得个人信息的泄露问题已经成为公众生活的威胁之一，针对不法快递人员将快递信息用以市场交易，甚至直接威胁收件人、寄件人的生命财产安全，文章提出利用二维码技术与计算机技术相结合，基于二维码技术，采用分层加密技术，对物流信息进行分层加密后转储到二维码进行二次封装，并且不同等级授权机制解密相关信息，保护信息安全。\n\n但是流程中存在某些漏洞，实际应用中可能带来比较大的麻烦，性价比方面还需要调查研究。所以这个项目有待优化。\n","tags":["project"],"categories":["project"]},{"title":"基于CRT的新型群文件共享系统","url":"/2020/04/13/基于CRT的新型群文件共享系统/","content":"\n这个项目的是在2019年寒假期间进行的，4月份在中南大学信息安全作品赛答辩，但是由于功能只实现了主体部分，加之我在台上比较胆怯紧张，所以只获得团队三等奖，但是当时老师们还是对我们鼓励有加，说我们有实实在在在做项目。在此感谢两位搭档与我一起努力，共克难关。看着当时做的答辩PPT和项目代码，依然觉得感受良多。这的确是一次既有收获又有遗憾的项目经历。\n\n#### 选题背景\n\n在密码学课程中，我们的指导老师段老师给了我们很多新颖的idea。其中一条是和群文件分级管理有关的，她分析了一个现象：目前在比较大的QQ群里，往往存在很严重的信息泄露情况。如果我们能在聊天群里面对文件进行分级管理，会不会有更好的效果？\n\n的确，信息泄露现象已经屡见不鲜，前不久在学校举办的天梯赛里面就出现了这样的问题，**组委会在公布参赛人员名单的时候竟然把所有参与者的姓名，学院，专业名称，班级，学号，QQ，邮箱和联系电话等资料统统泄露了出来，其中也包括我的资料。**我对此感到不满，立即与发布这份名单的同学说清楚这样发布名单的危险。还好她很快认识到自己在隐私保护方面的不足，两三分钟后迅速地把这份报名表撤回了。\n\n![被泄露的报名表](1.png)\n\n虽然一份名单中的信息量不多，对不法分子而言可能还卖不出一份好价钱。但是如果人人都抱着这种随意和侥幸的心态，就有可能导致更多更重要的隐私被一次性泄露，从而带来非常大的危害。\n\n#### 作品功能\n\n经过项目组的讨论和意见交换，分析上述情况出现的原因主要有以下三点：\n\n**1.文件的发布者隐私保护意识不强。**\n\n**2.群里人员鱼龙混杂。**\n\n**3.群文件明文可见。**\n\n对发布者的隐私保护意识的提升，光有宣传，效果是不大的，只有通过设计出一款人性化的软件来使他们在不知不觉中形成这种习惯。而群里人员鱼龙混杂，则主要归因于群成员缺乏身份认证。群文件明文可见，则是由于对群成员缺乏分层管理，导致可拓展性低。\n\n为了保证群文件的安全，我们的应用程序打算做到以下几点：\n\n1.群文件加密保存。\n\n2.群成员实名认证。\n\n3.对群成员进行分级权限管理。\n\n4.提醒管理员注意群文件的安全。\n\n这意味着需要实现如下功能：\n\n1.通过**权限分级**实现**权限管理**，控制每个用户所能解密的文件等级，以保证保密级别较高的文件具有比较好的保密性。\n\n2.通过**基于CRT的密钥分发**系统，具体实现文件的**访问控制**，使级别较低的人不能解密级别较高的文件\n\n3.通过**实名制与重名查询**，实现辅助的**身份认证**。\n\n4.当群成员退出或者权限降低后，**密钥自动更新**，使得退出群组的成员无法再解密群中的文件。\n\n群成员的权限管理该采用什么模型呢？当时我在学操作系统安全，在寒假的预习过程中，我预习到了一种模型，叫做Biba模型，当看到这个模型的思路的什么，我就觉得，它正好可以用在我们项目组研制的软件中，根据Biba模型，我做出了一些调整，最终软件所能实现的分层管理功能就是：任何一个等级的群成员，只能浏览安全等级小于或者等于这个等级的群文件。例如，安全等级为4的用户可以得知安全等级为1,2,3,4的文件的密码(这个用户的私钥可以解密上述四种安全等级文件的会话密钥)，而安全等级为4的文件只可以被安全等级为4,5的用户查看(只要这些用户能通过解密相应信息或者这个文件的会话密钥)\n\n而基于CRT的密钥分发技术则是在密码学课程中我十分感兴趣的技术。例如在一个交际系统中，A,B,C,D,E都有自己的私钥，若B,C,D需要在不透露自己的私钥的情况下进行沟通，那么可以生成一个会话密钥并通过CRT技术用B,C,D的私钥进行加密，B,C,D可以通过解密这条消息看到相应的会话密钥，而A,E则不行。这样就实现了一个小范围保密通信协议。\n\n身份认证这方面，主要是重名查询。为免有人冒充群里已有的成员加入，每位成员加入的时候，系统会遍历一遍已有的群成员，如果已经存在该群成员，则系统会出现“Red Alert”，提醒管理员要十分注意核实该申请者的身份。同时每一位入群的成员都将被管理员设置成相应的安全级别。\n\n故作品的关键流程与技术如下：\n\n![](2.png)\n\n![](3.png)\n\n#### 作品实现\n\n作品最终实现了以下功能：群文件密钥分发，实名制，权限管理，密钥可更新，重名查询。\n\n我的两位队友主要负责聊天软件的制作(Q群界面的模拟和身份认证功能的实现)，而我负责关键流程的算法设计和代码实现（权限管理，访问控制和密钥更新）。但是最后由于两部分的代码不太兼容，最后没调通，我就直接在eclipse上面展示关键代码的功能了。\n\n关键代码部分（含注释）实现如下：\n\n```java\nimport java.math.BigInteger;//用于支持java密钥的大数\nimport java.util.*;\n\n\npublic class CRT {\n;\n\tpublic static void main(String[] args) {\n\t\tKEY []key=new KEY[5];\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tkey[i]=new KEY(32);//对话密钥一般比用户密钥少，用户密钥需要稍大\n\t\t\tSystem.out.println(\"初始化用户密钥: key\"+(i+1)+\"=\"+key[i].primekey);//用户私钥\n\t\t}\n\t\tint rank;//文件等级\n\t\tMOD m=new MOD();\n\t\tSystem.out.println(\"自动生成模数:\"+m.primemod);\n\t\ttry {Thread.sleep(1000);}\n\t\tcatch(Exception e) {};\n\t\tScanner cin=new Scanner(System.in);\n\t\t//某用户传送文件\n\t\tKEY []Ks=new KEY[5];//生成会话密钥\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tKs[i]=new KEY(30);//会话密钥要比普通密钥稍小\n\t\t\tSystem.out.println(\"初始化会话密钥: ks\"+(i+1)+\"=\"+Ks[i].primekey);//+\"=\"+Ks[i].primekey\n\t\t}\n\t\ttry {Thread.sleep(500);}//这一段是为了在答辩时老师能慢慢的看变化，看得更清楚\n\t\tcatch(Exception e) {};\n\t\t//System.out.println(\"系统内部生成文件加密密钥中\");//测试\n\t\t\n\t\tKEY []Kr=new KEY[5];\n\t\tSystem.out.println(\"根据文件等级生成传输密钥Kr\");\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\t//第i+1级文件的CRT\n\t\t\t//System.out.println(\"根据文件等级生成传输密钥Kr\"+(i+1));\n\t\t\tKr[i]=Ks[i].CRT(key,m,i+1);//根据CRT生成总密钥Kr,Ks是对应会话密钥,m是模数,(i+1)是等级\n\t\t\tSystem.out.println(\"Kr\"+(i+1)+\"=\"+Kr[i].get());\n\t\t}\n\t\ttry {Thread.sleep(1000);}\n\t\tcatch(Exception e) {};\n        //展示CRT分级管理后的效果\n\t\tSystem.out.println(\"测试：各等级用户能得到的密钥——请输入你想看的文件等级:\");\n\t\trank=cin.nextInt();\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tBigInteger result=Kr[rank-1].get().remainder(key[i].get());\n\t\t\tSystem.out.println(\"第\"+(i+1)+\"级用户得到的会话密钥是\"+result);\n\t\t}\n\t\tint k=2;\n\t\twhile(k>0)\n\t\t{\n\t\t\tSystem.out.println(\"新建用户\");\n\t\t\tUser a=new User();\n\t\t\tint j=2;\n\t\t\twhile(j>0)\n\t\t\t{\n\t\t\t\tSystem.out.println(\"请输入你想看的文件级别:\");\n\t\t\t\trank=cin.nextInt();\n\t\t\t\tBigInteger result=Kr[rank-1].get().remainder(key[a.rank-1].get());\n\t\t\t\tSystem.out.println(\"用户得到的密钥是\"+result);\n\t\t\t\tSystem.out.println(\"测试：第\"+rank+\"级文件会话密钥:\"+Ks[rank-1].primekey);\n\t\t\t\t//System.out.println(\"是否继续？除y之外任意键退出查看文件并注销用户。\");\n\t\t\t\tj--;\n\t\t\t\ttry {Thread.sleep(5000);}\n\t\t\t\tcatch(Exception e) {};\n\t\t\t}\n\t\t\t//用户注销，执行析构函数\n\t\t\tSystem.out.println(\"用户注销，密钥将自动更新\");\n\t\t\tint userank=a.get();\n\t\t\t\n\t\t\tfor(int i=0;i<userank;i++)\n\t\t\t{\t\n\t\t\t\tKs[i]=new KEY(30);//生成会话密钥\n\t\t\t\t//System.out.println(\"会话密钥已更新\");\n\t\t\t\tkey[i]=new KEY(32);\n\t\t\t\t//System.out.println(\"等级私钥已更新\");\n\t\t\t\tSystem.out.println(\"更新后的等级密钥: key\"+(i+1)+\"=\"+key[i].primekey);\n\t\t\t\ttry {Thread.sleep(300);}\n\t\t\t\tcatch(Exception e) {};\n\t\t\t}\n\t\t\tfor(int i=0;i<5;i++)\n\t\t\t{\n\t\t\t\t//第i+1级文件的CRT\n\t\t\t\tSystem.out.println(\"重新根据文件等级生成传输密钥Kr\"+(i+1));\n\t\t\t\tKr[i]=Ks[i].CRT(key,m,i+1);//根据CRT生成总密钥Kr,Ks是对应会话密钥,m是模数,(i+1)是等级\n\t\t\t\tSystem.out.println(\"新的Kr\"+(i+1)+\"=\"+Kr[i].get());\n\t\t\t\ttry {Thread.sleep(100);}\n\t\t\t\tcatch(Exception e) {};\n\t\t\t}\n\t\t\t/*System.out.println(\"是否继续？除y之外任意键退出。\");\n\t\t\tString str=cin.toString();\n\t\t\tstr=cin.toString();\n\t\t\tif(str.charAt(0)!='y')\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}*/\n\t\t}\n\t\tk--;\n\t\ttry {Thread.sleep(3000);}\n\t\tcatch(Exception e) {};\n\t}\n\n}\nclass User\n{\n\tint rank;\n\t//用户登录,输入密码,获得用户等级\n\tUser()\n\t{\n\t\tScanner ci=new Scanner(System.in);\n\t\tSystem.out.println(\"请输入用户等级:\");\n\t\trank=ci.nextInt();//测试用，手动输入用户等级,貌似有错误输入\n\t}\n\tint get()\n\t{\n\t\treturn rank;\n\t}\n\t\n}\nclass MOD\n//生成模数\n{\n\tBigInteger primemod;\n\tMOD()\n\t{\n\t\tRandom rand=new Random();\n\t\tbyte []rand_byte=new byte[35];\n\t\trand.nextBytes(rand_byte);\n\t\trand_byte[0]=1;//为了让模数大于密码\n\t\tBigInteger a=new BigInteger(rand_byte),b=new BigInteger(rand_byte);\n\t\tprimemod=a.multiply(b);\n\t\tprimemod=primemod.nextProbablePrime();\n\t}\n\tBigInteger get()\n\t{\n\t\treturn  primemod;\n\t}\n}\nclass KEY\n//密钥生成\n{\n\tBigInteger primekey;\n\tKEY()\n\t{\n\t\tRandom rand=new Random();\n\t\tbyte []rand_byte=new byte[32];\n\t\trand.nextBytes(rand_byte);\n\t\tBigInteger a=new BigInteger(rand_byte);//随机大正数\n\t\ta=a.abs();\n\t\tprimekey=a.nextProbablePrime();\n\t}\n\tKEY(int i)\n\t{\n\t\tRandom rand=new Random();\n\t\tbyte []rand_byte=new byte[i];\n\t\trand.nextBytes(rand_byte);\n\t\tBigInteger a=new BigInteger(rand_byte);//随机大正数\n\t\ta=a.abs();\n\t\tprimekey=a.nextProbablePrime();\n\t}\n\tBigInteger get()//输出\n\t{\n\t\treturn  primekey;\n\t}\n\tKEY(BigInteger a)\n\t{\n\t\tprimekey=a;\n\t}\n\tvoid push(BigInteger b)//修改\n\t{\n\t\tprimekey=b;\n\t}\n\tKEY CRT(KEY key[],MOD m,int rank)\n\t{\n\t\tKEY Kr=new KEY(BigInteger.ZERO);\n\t\tBigInteger []x=new BigInteger[5];\n\t\tfor(int i=1;i<=5;i++)//把密钥分发给需要的人\n\t\t{\n\t\t\tif(i<rank)//比如等级是三级的文件，1，2级不能看，密钥填0\n\t\t\t{\n\t\t\t\tx[i-1]=BigInteger.ZERO;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tx[i-1]=primekey;//Ks[i]，即对应的会话密钥\n\t\t\t}\n\t\t}\n\t\tBigInteger p=m.get();\n\t\tBigInteger Mn=BigInteger.ONE;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tMn=Mn.multiply(key[i].get());\n\t\t}\n\t\tBigInteger []W=new BigInteger[5];\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tW[i]=Mn.divide(key[i].get());\n\t\t}\n\t\tBigInteger []T=new BigInteger[5];//开辟了数组空间\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tT[i]=W[i].modInverse(key[i].get());\n\t\t}\n\t\tBigInteger result=BigInteger.ZERO;\n\t\tfor(int i=0;i<5;i++)\n\t\t{\n\t\t\tresult=result.add(x[i].multiply(W[i].multiply(T[i])));\n\t\t}\n\t\tresult=result.remainder(Mn);//咋变成0了\n\t\t//result=result.remainder(p);\n\t\tKr.push(result);\n\t\treturn Kr;\n\t}\n}\n```\n\n在测试中，我们的展示流程是这样的：\n\n初始化群用户密钥并生成每类文件的会话密钥。\n\n![](4.png)\n\n自动生成每类等级文件密钥的加密信息。\n\n![](5.png)\n\n测试CRT定理对密钥分发的有效性：\n\n每个级别的用户对于某个文件等级的文件，能获取到的密钥(样例文件等级为3)：\n\n![](7.png)\n\n用户入群后，随意访问文件密钥，但是只能看到安全等级比较低的文件，不能访问安全等级比自己等级高的文件。\n\n![](6.png)\n\n密钥更新部分，密钥更新产生了新的会话密钥，老用户不再能使用之前的密钥。(PPT没有截图，具体实现可以看代码)\n\n#### 质疑与争论\n\n**我的质疑**：\n\n在答辩前，我写了一份有关这个项目的优势和劣势的一些分析并交予小组成员一起讨论，主要有如下几点：\n\n1.在鱼龙混杂的qq群中，如果管理员真的愿意耐心的给每一个人和文件分配权限的话，那么权限比较低的人看不到权限比较高的文件。那么如果是权限比较高的人出了问题呢？比如管理员的号被盗了怎么办？\n\n2.我们给他足够高的权限意味着我们足够相信他，但是泄密者不一定是本人，也不一定是前员工，如果只是qq号被攻击者窃取了，那么别人是可以在管理员不知情的情况下获取文件内容的。如果文件内容被获取，那么截图或者下载，总有可能是会泄露的。\n\n3.如果我们实在担心文件的安全，为什么还一定要把文件上传到qq而不通过其他方式分享文件？\n\n4.不可否认，通过入群的认证,离开群后更新密钥和分级管理是可以起到一定保护作用。但这种方式的性价比真的高吗，真的值得吗？\n\n不可否认，我可能想得有点多，但是关于上述几个问题，的确值得商榷，最让我担心的还是项目的性价比和应用前景。\n\n**团队总结的遗留问题：**\n\n经过一番讨论，我们在答辩过程中提出了如下的不足之处和创新点：\n\n![](8.png)\n\n![](9.png)\n\n**老师的质疑：**\n\n项目答辩的时候，老师也问了这个项目的应用前景，他们觉得没有这个必要。因为完全可以建一个小一些的Q群，或者使用更安全的公司内部网络。他们建议，我们把这个问题上升到公司内部文件系统的安全上面去，不然看着觉得很好，但是想着又觉得又有点虚。\n\n---\n\n2020.4.21随想\n\n有时候人性的弱点带来的危险最大，我之前虽然会看入群验证但很少核实信息是否真实。所以我觉得一个应用，最主要的还是要解决人的问题，方便人的生活，同时自然就能保证安全了。\n\n","tags":["project"],"categories":["project"]},{"title":"lz77编码选做实验过程笔记","url":"/2020/04/03/lz77编码选做实验过程笔记/","content":"\n# 多媒体原理与系统设计选做实验\n\n### 编码算法完善过程\n\n先把LZ77算法的伪代码拷贝下来\n\n![image-20200403190150298](image-20200403190150298.png)\n\n#### 1.else分支\n\n需要补充的代码是else分支的处理代码。由于数据结构是固定的，因此只能输入0，0和next_char的三元组信息。如果要设计更复杂的实现算法和数据结果的话，可以把0省略，以实现更大程度的压缩。\n\n先看看if分支的代码有没有可以借鉴的地方：\n\n```c++\nswprintf(code, 125, L\"(%d,%d,%lc)\", offset, length, source[pointer+length] );//输出三元组，需要借鉴保留，因为不匹配，length=0和offset=0必定满足\n\t\t\tcpy_len = wcslen(code);//计算新增编码长度，借鉴保留\n\t\t\t\n\t\t\twcscpy_s(codes + code_size,cpy_len+1, code);//应该是用于展示的，借鉴保留\n\n\t\t\tpointer = pointer + length + 1;//指针移动，但是length=0，只需要借鉴保留\n\t\t\tcode_size+= cpy_len;//更新总编码长度，借鉴保留\n```\n\n于是就得到如下代码：\n\n```c++\n//没有发现匹配字符串时，输入0，0和next_char信息\n\t\t\t//******************************************************************\n\t\t\t//**                 此处需要你补全代码\n\t\t\t//******************************************************************\n\t\t\t//开始你的代码\n\t\t\tswprintf(code, 125, L\"(%d,%d,%lc)\", offset, length, source[pointer + length]);//输出三元组\n\t\t\tcpy_len = wcslen(code);\n\n\t\t\twcscpy_s(codes + code_size, cpy_len + 1, code);\n\n\t\t\tpointer = pointer + length + 1;\n\t\t\tcode_size += cpy_len;\n\t\t\t//结束你的代码\n\t\t\t//******************************************************************\n```\n\n#### 2.报文尾部\n\n先看看如何判断是到了报文尾部。按照一般的情况，可能需要记录报文的长度或者剩余报文的字数，如果当前指针偏移达到报文长度或者剩余报文长度为0的话，就意味着到了报文结尾。也可以通过某种特殊符号记录报文末尾。\n\n观察代码，找到了程序相关变量：\n\n```c++\n//source明文，winsize窗口大小,codes编码后文字\nvoid lz77_coder(WCHAR* source, int win_size, WCHAR* codes)\n{\t\t\n\tsize_t source_len = wcslen(source);//计算原文字符串长度\n```\n\n那么如果win_size_real为0，就意味着到达了报文末尾了。可以补全相关代码：\n\n```c++\n\t\t//达到报文末尾时，退出编码循环\n\t\t//******************************************************************\n\t\t//**                 此处需要你补全代码\n\t\t//******************************************************************\n\t\t//开始你的代码\n\t\tif (source_len <= pointer)//把常量写左边，以防写错比较符号\n\t\t{\n\t\t\treturn;\n\t\t}\n\t\t//结束你的代码\n\t\t//******************************************************************\n\n```\n\n### 解码算法完善过程\n\n解码算法没有相应的伪代码，但是可以参照编码算法来完善。\n\n首先了解源程序每个循环的作用和如何解析三元组找到offset的：\n\n```c++\n//每个循环都解析一个编码，结构为：(offset,length,next_char)，最后一个编码的右边可能缺少next_char和)\n//找到offset\n\t\twhile(codes[idx] != ',')//三元组的第一元，读到逗号为止\n\t\t{\n\t\t\tidx++;\n\t\t}\n\t\ttoken_sz = idx - start_idx;//忽略逗号的长度，正好把两个逗号长度抵消\n\t\tcopy_str1_to_str0(token, codes+start_idx, token_sz);//把offset取出来\n\t\toffset = _wtoi(token);//把内容是数字的字符串转换整型数字\n\t\tidx++;//忽略逗号\t\n```\n\n于是可以轻松补充出找到length的代码:\n\n```c++\n\t\t//找到length\n\t\t//******************************************************************\n\t\t//**                 此处需要你补全代码\n\t\t//******************************************************************\n\t\t//开始你的代码\n\t\tidx++;//目前的位置是逗号，往后走一位\n\t\tstart_idx = idx;\n\n\t\t//找到offset\n\t\twhile (codes[idx] != ',')\n\t\t{\n\t\t\tidx++;\n\t\t}\n\t\ttoken_sz = idx - start_idx;//忽略逗号的长度，也是刚好抵消\n\t\tcopy_str1_to_str0(token, codes + start_idx, token_sz);\n\t\tlength = _wtoi(token);//把内容是数字的字符串转换整型数字\n\t\tidx++;//忽略逗号\n\t\t//结束你的代码\n\t\t//******************************************************************\n```\n\n考虑到最后一个编码的右边可能缺少next_char和)，找到next_char的代码需要出现一些分支判断。而且next_char不是数字，本身是一个字符，所以这部分代码需要修改:\n\n```c++\n\t\t//找到next_char\n\t\t//******************************************************************\n\t\t//**                 此处需要你补全代码\n\t\t//******************************************************************\n\t\t//开始你的代码\n\t\tidx++;//目前的位置是逗号，往后走一位\n\t\tstart_idx = idx;\n\n\t\t//判断是否是最后一个编码\n\t\tif (idx >= codes_len)\n\t\t{\n\t\t\t//最后一个编码了\n\t\t\tnext_char = '\\0';//结束符,反正都是要附加上去的，加上结束符刚好\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnext_char = codes[idx];//这就是next_char\n\t\t\tidx += 2;//加一是右括号，加二才可能到达左括号\n\t\t}\n\t\t//结束你的代码\n\t\t//******************************************************************\t\n```\n\n然后补全解码时输出匹配字符串和最后一个附加的next_char字符的代码，我看到next_char已经输出了，那么接下来最主要的就是根据length和offset找到匹配字符串，然后把匹配字符串按字符一个个附加到解码字符串后面：\n\n```c++\n\t\t\tfor (size_t i = 0; i < length; i++)//这里已经在length的循环里面了\n\t\t\t{\n\t\t\t\t//******************************************************************\n\t\t\t\t//**                 此处需要你补全代码\n\t\t\t\t//******************************************************************\n\t\t\t\t//开始你的代码\n\t\t\t\tdecodes[decodes_idx++] = decodes[(decodes_idx++) - offset];\n\t\t\t\t//结束你的代码\n\t\t\t\t//******************************************************************\t\n\t\t\t}\n```\n\n### 调试与运行\n\n一开始的时候，编码算法和原文对比是没有问题的，但是解码的时候出现了问题：\n\n![image-20200403211706525](image-20200403211706525.png)\n\n明显所有的nextchar都被读成了右括号。后来发现原来是自己的代码里面重复了一次id++。\n\n![image-20200403212041843](image-20200403212041843.png)\n\n把其中一处删掉，更改后寻找next_char代码如下：\n\n```c++\nstart_idx = idx;\n\n\t\t//判断是否是最后一个编码\n\t\tif (idx >= codes_len)\n\t\t{\n\t\t\t//最后一个编码了\n\t\t\tnext_char = '\\0';//结束符,反正都是要附加上去的，加上结束符刚好\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnext_char = codes[idx];//这就是next_char\n\t\t\tidx += 2;//加一是右括号，加二才可能到达左括号\n\t\t}\n```\n\n再次运行，还是稍微有一些问题：\n\n![image-20200403212319194](image-20200403212319194.png)\n\n观察丢失字符的特性，可以发现重复的字符串的字符完全丢失，只有输出next_char的部分是完全正确的。\n\n那么就可能是寻找offset的代码或者输出的相关代码出现问题。\n\n找到输出相应代码：\n\n`decodes[decodes_idx++] = decodes[(decodes_idx++) - offset];`\n\n发现我的一句代码里面出现了两次i++，这样就导致一次寻常指针往后走了两个位置。重新修改这段代码：\n\n```c++\n//当offset和length不为0时，输出匹配字符串和最后一个附加的next_char字符\n\t\t\tstart_idx = decodes_idx;\n\t\t\tfor (size_t i = 0; i < length; i++)//这里已经在length的循环里面了\n\t\t\t{\n\t\t\t\t//******************************************************************\n\t\t\t\t//**                 此处需要你补全代码\n\t\t\t\t//******************************************************************\n\t\t\t\t//开始你的代码\n\t\t\t\tdecodes[decodes_idx++] = decodes[(decodes_idx) - offset];\n\t\t\t\t//结束你的代码\n\t\t\t\t//******************************************************************\t\n\t\t\t}\n\t\t\tdecodes[decodes_idx++] = next_char;\n```\n\n但是这一部分的失误不可能导致字符串整个丢失，那么获取length的算法肯定也存在一些问题。结果我发现了和上面一样的问题。\n\n![image-20200403213722664](image-20200403213722664.png)\n\n还是删除最下面的idx，于是运行成功：\n\n![image-20200403213826058](image-20200403213826058.png)\n\n### 感受\n\n通过选做实验完善课程项目的编程其实真的是一种很棒的教学形式。就如同在科研团队或者工作中，一个大项目被分成若干的部分，每个人完成其中一小部分。这需要项目参与者的相互配合，交流并了解对方代码的含义。要使用统一的变量和接口函数，以免在代码衔接过程中产生bug，使得软件出现功能的不符合或者安全脆弱点。当然，为了验证程序的重要性，调试和测试阶段也是不可免的。\n\n这次编程过程，出现了很多的小问题，特别是相同的错误在两段代码里都出现了，所以体现出自己在补充代码时可能会考虑没有这么全面，但是通过代码测试和代码审计，最终把所有错误纠正了，也熟悉了一次lz77编解码的相关知识，这个过程本身就是很值得的。","tags":["study"],"categories":["study"]},{"title":"极光实验室战队考核密码学部分考察点与题解","url":"/2020/04/01/极光实验室战队考核密码学部分考察点与题解/","content":"\n## 实验室战队考核新人赛题目点评与WP\n\n#### 题目\n\n![image-20200404204929407](image-20200404204929407.png)\n\n#### 出题思路\n\n由于是战队考核，这次的题目应出得相对综合，也更考验同学们的知识面和对各方面加密的理解和把握能力。同时，题目应当结合密码学的实际应用，有生动的背景和场景。\n\n出题前，我在网上做了两三道rsa和aes的题目，觉得出题点还是比较单一，于是联想了一下之前做过的一些印象深刻的密码学题目，于是我想到了把密码学实验和aes，rsa结合起来，出一次改进版的中间人攻击，作为密码学实验的补充。之所以要和aes，rsa结合，是因为通过混合密码通信的安全性更高，效率也更好。我们段老师的PPT是这么说的：\n\n![image-20200402112220312](image-20200402112220312.png)\n\n但是，如果rsa加密过程中存在某些问题呢？假如rsa私钥部分泄露呢？那面对中间人的攻击，这种通信方法也难以保证它的安全性。见如下[参考论文](王小云,刘明洁.格密码学研究[J].密码学报,2014,1(01):13-27.):\n\n![7](.\\极光实验室战队考核密码学部分考察点与题解\\7.png)\n\n在题目环境中，我就让私钥最低位的一半比特泄露出来，这是足够解对称密码私钥的了。根据等式：\n$$\ne * d == 1 mod phi(N)\n$$\n我们引入常数k，使得:\n$$\ne * d - k * phi(N) == 1\n$$\n由于e模phi的逆：\n\n```python\n    d = gmpy2.invert(e,phi)\n```\n\n所以对于上述等式，有：\n\n$$\nphi(N) > d\n$$\n\n那么就有：\n$$\nk<e\n$$\n由于e一般在16位以下（题目中不超过1024），所以k是可爆破的。\n\n我们对等式两边都模上2的1050次方，并化简：\n$$\n(e * d - k * phi(N)) mod 2**1050 == 1 mod 2**1050\n$$\n\n$$\n((e mod 2**1050) * (d mod 2**1050) - k * phi(N) ) mod 2**1050 == 1 mod 2**1050\n$$\n\n$$\n(e * d0 - k*phi(N)) mod 2**1050 == 1 mod 2**1050\n$$\n\n$$\ne * d0 - k*phi(N) == 1 mod 2**1050\n$$\n\n方程两边同乘q，并代入等式：\n$$\nphi(N)==(p-1)*(q-1)\n$$\n以及\n$$\nN==p*q\n$$\n可以得到：\n$$\ne*d0*p - k*(n*p-p*p-n+p) == p mod 2**1050\n$$\n所以只需要对k进行遍历，然后对每一个k通过sage解同余方程即可。\n\n\n获取了对称密码的私钥以后，消息明文便不难获取了。同时，和密码学实验一样，我们假设中间人有着足够的能力完成近乎实时的通信，在没有认证机制的DH通信协议中，他就可以冒充通信双方进行欺骗。*这里为了保证实时性，本来应该进行时间限制的，这样大家就只能通过python的pwntools工具来进行交互了。但是考虑到考点比较综合，任务量大，在12小时之内能写出这么多脚本的可能性不太大，所以就不限制时间了。*\n\n#### 考察点\n\nAES(CBC和ECB）加解密， 铜匠攻击，DH通信协议，中间人攻击，base64加解密\n\n#### 出题过程\n\n首先，还是建立两个文件，Arica.py和conversation.py，保存一些不想公布的变量值:\n\n```python\n#Arica.py\nkey=b'grzu7KTaDuiiBVWL'\nflag=b'ACTF{You_have_got_the_flag!That_is_impossible!}'\n```\n\n```python\n#conversation.py\nquestions = [\n    b\"Who are you?\",\n    b\"Oh my dear Brooke, I miss you so much!\",\n    b\"Brooke, I was so lonely during the outbreak of Novel coronavirus!\",\n    b\"Brooke, do you mind me asking you a few more question?\",\n    b\"What can I do for you?\"]\nanswer = [\n    b\"I'm Brooke.\",\n    b\"I miss you too.\",\n    b\"Me too! I wanna go out for dance!\",\n    b\"Not at all.\",\n    b\"Nothing.\"]\nfake_answer=b\"I want to get my AES-key.\"\nsaying_key=b\"Here is the key: \"\n\n```\n\n然后在windows上写了针对key的加密函数(aes-cbc)和针对flag的加密函数(泄露私钥的rsa函数)。\n\n```python\n#encryption.py\nfrom Cryptodome.Cipher import AES\nfrom Arica import key,flag\nimport base64\nimport gmpy2\n\nfrom Cryptodome.Util.number import (\n    bytes_to_long,\n    long_to_bytes,\n    str2long,\n    long2str,\n    getPrime\n)\nfrom Cryptodome.Random.random import (\n    getrandbits,\n    randint\n)\n\np = 217534615279223294476101434763509239207\ng = 2\n\ndef encrypt_flag():\n    global flag\n    aes = AES.new(key, AES.MODE_ECB)\n    flag = adaptmessage(flag)\n    c = aes.encrypt(flag)\n    print(\"Here is the encrypted flag: \"+str(base64.b64encode(c)))\n    #b'gTAmtDzEDIYdzs6j55csresodxpsKJlOVMOmzLq8/39Vm0lJZvnrGtPBW6IKUpML'\ndef encrypt_key():\n    e = 1667\n    p = getPrime(700)\n    q = getPrime(1400) \n    n = p*q\n    print(\"\"\"+------------------------------------------------------+\n|Attension! Through soical engineering, you got this: |\n+------------------------------------------------------+\"\"\")\n    phi = (p-1)*(q-1)\n    d = gmpy2.invert(e,phi)\n    print(\"n = \"+str(n))\n    #print(d)\n    print(\"Brooke's partial d: \"+ str(int(d) % (2**1050)))\n    enc = pow(bytes_to_long(key), e, n)\n    return enc\n\ndef generateDH(exp):\n    return pow(g, exp, p)\n\ndef adaptmessage(message):\n    return message.ljust(16-len(message)%16+len(message), b\"\\x00\")\n\ndef aricaSay(*args):\n    print(\"\"\"+-------------------+\n|    Arica said:    |\n+-------------------+\"\"\")\n    print(\" \".join(map(str,args)))\n\ndef brookeSay(*args):\n    print(\"\"\"+--------------------+\n|    Brooke said:    |\n+--------------------+\"\"\")\n    print(\" \".join(map(str,args)))\n\ndef say2arica(*args):\n    print(\"\"\"+---------------------+\n|    Say to Arica:    |\n+---------------------+\n\"\"\"+ \" \".join(map(str,args)), end=\"\")\n    return input()\n\ndef say2brooke(*args):\n    print(\"\"\"+----------------------+\n|    Say to Brooke:    |\n+----------------------+\n\"\"\" + \" \".join(map(str,args)), end=\"\")\n    return input()\n\n```\n\n然后把DH通信的脚本和题目情景写好：\n\n```python\n#server.py\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom encryption import *\nfrom conversation import *\n\nbanner = \"\"\"\n+--------------------------------------------------+\n|HELLO CHALLENGER!                                 |\n|                                                  |\n|Have you ever seen movies like MISSION IMPOSSIBLE?|\n|Unfortunately, You have got a mission that seemed |\n|impossible to finish!                             |\n|                                                  |\n|In the task, you are required to decrypt the      |\n|'Most secret' message of Arica, the bank clerk.   |\n|                                                  |\n|Fortunately, after social engineering you have    |\n|hacked in her communication with her boyfriend    |\n| Brooke and you have got Brooke's partial         |\n|RSA-private-key.                                  |\n|                                                  |\n|To get the message, you must first establish      |\n| communication with Arica through 'DH key exchange|\n| protocol', chat with her by saying what Brooke   |\n|said, but you need to send the message            |\n| \"I want to get my AES-key.\" and the timestamp    |\n| after Arica said \"What can I do for you?\",       |\n|then she will give the AES-key encrypted with her |\n| RSA-public-key，this message should be start with|\n| \"Here is the key:\".                              |\n+--------------------------------------------------+\n\"\"\"\n\ndef main():\n    print(banner)\n    encrypt_flag()\n    enc = encrypt_key()\n    expA = getrandbits(128)\n    expB = getrandbits(128)\n    A = generateDH(expA)\n    B = generateDH(expB)\n    aricaSay(\"A:\", A)\n    AC = int(say2brooke(\"A: \"))\n    brookeSay(\"B:\", B)\n    BC = int(say2arica(\"B: \"))\n    keyC = pow(AC, expB, p)\n    keyS = pow(BC, expA, p)\n    keyC = long_to_bytes(keyC).rjust(16, b\"\\x00\")\n    keyS = long_to_bytes(keyS).rjust(16, b\"\\x00\")\n    cipherC = AES.new(keyC, AES.MODE_ECB)\n    cipherS = AES.new(keyS, AES.MODE_ECB)\n    for _i in range(5):#5\n        index=_i\n        randomnum = randint(0, 256)\n        messageA = questions[index]\n        messageA = adaptmessage(messageA)\n        cS = bytes_to_long(cipherS.encrypt(messageA))\n        aricaSay(\"A:\", \"{:032x}\".format(cS))\n        s = int(say2brooke(\"A: \"), 16)\n        s = long_to_bytes(s)\n        q = cipherC.decrypt(s)\n        if q != messageA:\n            print(\"Brooke does't get your words and realize something, U FAILED...\")\n            exit(0)\n        randomnum = randint(0, 256)\n        messageB = answer[index]\n        messageB = adaptmessage(messageB)\n        cC = bytes_to_long(cipherC.encrypt(messageB))\n        brookeSay(\"B:\", \"{:032x}\".format(cC))\n        s = int(say2arica(\"B: \"), 16)\n        s = long_to_bytes(s)\n        a = cipherS.decrypt(s)\n        if(_i==4):\n            messageB = fake_answer\n            messageB = adaptmessage(messageB)\n        if a != messageB:\n            print(\"Arica does't get your words and realize something, U FAILED...\")\n            exit(0)\n        \n    randomnum = randint(0, 256)\n    messageA = saying_key+long_to_bytes(enc)\n    messageA = adaptmessage(messageA)\n    cS = bytes_to_long(cipherS.encrypt(messageA))\n    aricaSay(\"A:\", \"{:032x}\".format(cS))\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n在出题过程中，根据自己的测试又稍微对题目更改了一下。\n\n首先，在对aes私钥进行rsa加密的时候，一开始的e比较大，在1500左右，在测试中发现对于不同的d0值和n值，脚本的运行时间需要10分钟-3个小时，而3个小时在12个小时比赛时间里面所占比例太大，所以把e限制在1024以内，且设置为动态可变的数值。但是为了不增加难度，aeskey是固定的。\n\n```python\ndef encrypt_flag():\n    global flag\n    aes = AES.new(key, AES.MODE_ECB)\n    flag = adaptmessage(flag)\n    c = aes.encrypt(flag)\n    print(\"Here is the encrypted flag: \"+str(base64.b64encode(c)))\n    #b'gTAmtDzEDIYdzs6j55csresodxpsKJlOVMOmzLq8/39Vm0lJZvnrGtPBW6IKUpML'\ndef encrypt_key():\n    #e = 1667\n    p = getPrime(700)\n    q = getPrime(1400) \n    n = p*q\n    print(\"\"\"+------------------------------------------------------+\n|Attension! Through soical engineering, you got this: |\n+------------------------------------------------------+\"\"\")\n    phi = (p-1)*(q-1)\n    while(1):\n        e=getPrime(10)\n        if(phi%e!=0):\n            print(\"e = \"+str(e))\n            break\n    d = gmpy2.invert(e,phi)\n    print(\"n = \"+str(n))\n    #print(d)\n    print(\"Brooke's partial d: \"+ str(int(d) % (2**1050)))#d有问题\n    enc = pow(bytes_to_long(key), e, n)\n    return enc\n```\n\n另外由于DH的g为2，所以公钥应当为大于0的整数(不管你是1或者g**y%p，都不可能是0)，所以加入了一段代码检验：\n\n```python\n    #之所以要做出这个判断，是因为公钥真的不可能为0或负数\n    if(AC <=0):\n        brookeSay(\"You are not Arica! Her public key should not be:\", AC)\n        exit(0)\n    brookeSay(\"B:\", B)\n    BC = int(say2arica(\"B: \"))\n    if(BC <=0):\n        aricaSay(\"You are not Brooke! His public key should not be:\", BC)\n        exit(0)\n```\n\n另外，为了考察大家有没有细读message里面的内容，我在每条message后面都附带一个随机timestamp。每一次都需要更改这个timestamp，使得newtimestamp = (oldtimestamp+1)%256，程序里加上相应举例与提示：\n\n```python\n+---------------------------------------------------------+\n| PS:                                                     |\n| All message should be followed with new timestamp!!!    |\n| newtimestamp = (oldtimestamp+1)%256                     |\n| Please don't stuck with it:(                            |\n| For example, when you decrypt what Arica said like this:|\n| +--------------------+                                  |\n| |    Brooke said:    |                                  |\n| +--------------------+                                  |\n| I'm Brooke.                                             |\n| timestamp:112                                           |\n| You should encrypt this message to Arica:               |\n| +---------------------+                                 |\n| |    Say to Arica:    |                                 |\n| +---------------------+                                 |\n| I'm Brooke.                                             |\n| timestamp:113                                           |\n+---------------------------------------------------------+\n```\n\n请大家不要太纠结timestamp的意义，这个机制是Arica和Brooke确保不被中间人攻击的机制，假设Arica和Brooke的时戳是同步的，对话中每次附加一个时戳值，通过验证时戳与当前时间是否相同来过关。但是如果是采用真正的时间的话，攻击成功的概率就更小了，所以简化一下，就生成一个固定的256位随机数。同时，中间人修改信息需要时间，并把修改后的时间替换发给另一方。这时候我们假设中间人接收并重发消息的时间代价为1s，所以我们要将时戳加一。举例代码如下：\n\n```python\n#server.py\nmessageA = questions[index]+b\"\\ntimestamp:\"+bytes(str((randomnum+1)%256),encoding='utf-8')\nmessageA = adaptmessage(messageA)\n```\n\n#### Writeup样例\n\n首先，改编server.py为client.py，和服务器进行交互。这里由于交互程序变动较大，我直接通过手动输入把Arica和Brooke的密文信息传进去，等到解出明文以后手动修改timestamp。另外为了方便起见，我传递过去的公钥为1(即私钥为0)，这样的话和Brooke以及Alice的会话密钥都是1，就比较简单了。\n\n```python\n#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nfrom encryption import *\n\ndef main():\n    keyC = 1\n    keyS = 1\n    keyC = long_to_bytes(keyC).rjust(16, b\"\\x00\")\n    keyS = long_to_bytes(keyS).rjust(16, b\"\\x00\")\n    cipherC = AES.new(keyC, AES.MODE_ECB)\n    cipherS = AES.new(keyS, AES.MODE_ECB)\n    for _i in range(0):#5\n        #Arica说话了\n        s = int(say2brooke(\"A: \"), 16)#输入Arica说的话\n        s = long_to_bytes(s)\n        q = cipherC.decrypt(s)\n        print(q)\n        #这里还是直接从外头输入吧\n        messageA = bytes(input(),encoding='utf-8')\n        messageA += b\"\\n\"\n        messageA += bytes(input(),encoding='utf-8')\n        messageA = adaptmessage(messageA)\n\n        s=cipherC.encrypt(messageA)\n        print(hex(bytes_to_long(s))[2:])#对Brooke说的话\n\n        #Brooke说话了\n        s = int(say2arica(\"B: \"), 16)#输入Brooke说的话\n        s = long_to_bytes(s)\n        a = cipherS.decrypt(s)\n        print(a)\n        #这里还是直接从外头输入吧\n        messageB = bytes(input(),encoding='utf-8')\n        messageB += b\"\\n\"\n        messageB += bytes(input(),encoding='utf-8')\n        messageB = adaptmessage(messageB)\n        \n        s=cipherS.encrypt(messageB)\n        print(hex(bytes_to_long(s))[2:])#对Arica说的话\n        \n        \n    #Arica说出key了\n    s = int(say2brooke(\"A: \"), 16)#输入Arica说的话\n    s = long_to_bytes(s)\n    q = cipherC.decrypt(s)\n    key = q[17:]\n    for i in range (len(key)):\n        if(key[i:i+10]==b'\\ntimestamp'):\n            key=key[:i]\n            break\n    print(q)\n    print(key)\n    print(bytes_to_long(key))#key\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n然后开始运行，运行截图如下：\n\n首先收到服务器的消息:\n\n![](1.png)\n\n这些就是rsa的公钥，模数和泄露的私钥，先保存住，然后开始通信。\n\n首先，传递的公钥都为1。然后把Arica said的内容decryption，修改timestamp后把输出给回say to Brooke。\n\n服务器端界面：\n\n![2](2.png)\n\ndecryption.py运行界面：\n\n![image-20200402131956740](image-20200402131956740.png)\n\n一直运行下去：\n\n![3](3.png)\n\n直到最后得到key:\n\n![4](4.png)\n\n把key的部分截取下来，转换为数字，然后根据已有的e，n，partial d来解出aeskey：\n\n```python\ne=863\nn = 100518394843898371534434468452366727877002363101196571557097132988734353726584916462381290904798733002716305256677572628142627545744681541293793069726231800754314572981168235829239563613754713724345581918566947492170647540708428013292098065584617876680109166595710006367308500341766024651457023537770009981295726110940010220082434490215229951191714998895277291076151298363584672162765486380515325199053994651202708865071379999942193926154807059329464291992287421875356468218685095369057734586073271903432589401520355996027480658214090147502829069822606753125953586123331154015992246394834867237734405963056883227552074835515815968441\nc=86032824638305503499105979004374728344861493802341583733786447138684660694449673826205271902766363026345759436852747743967254218765160248630402258125202844303276381357264903281385470521070161164325276902001627351570675438339067652784355957225763207341000628151024518554862922220201109512940053316358078220681816224518400117972877854801506805929902506832781106133167532327833813179558969694268634413548545525533605595649634856393268111552838570383386406869870266457914799472663817890880697043874427042958587244568923338441053981863674366842769379075373006984522023718553749977766836594738859315852333132093474709715377682153430675891\nd0=8429433927120666131169351623736961178529851960373209550653840828920672665447032524933438956407503522388445988812739437427277858013428300926608147855795349674824173869269407061090165202002106353884034590344852857623737262477675587193006629765892565228448265429521617733861051151345083787592170864896543517637252788111\n\nd = 0\nfor k in range(0,e):\n    print k\n    X = var('X')\n    results = solve_mod([e*d0*X - k*(n*X-X*X-n+X) == X], 2**1050)\n    for x in results:\n        p0 = ZZ(x[0])\n        if is_prime(p0) and gcd(n,p0)!=1:\n            print p0\n            q0 = n//p0\n            phi=(q0-1)*(p0-1)\n            d = inverse_mod(e,phi)\n            break\n    if(d!=0):\n        break\nprint d\nm = pow(c,d,n)\nprint m\n```\n\n运行结果如图：\n\n![5](5.png)\n\n得到aeskey以后解密flag，脚本如下：\n\n```python\nfrom Cryptodome.Cipher import AES\nimport base64\nfrom Cryptodome.Util.number import (\n    bytes_to_long,\n    long_to_bytes,\n)\nkey_in_num = 137504889148498708381160600835355727692\nencryptedflag = b'gTAmtDzEDIYdzs6j55csresodxpsKJlOVMOmzLq8/39Vm0lJZvnrGtPBW6IKUpML'\nc = base64.b64decode(encryptedflag)\nkey = long_to_bytes(key_in_num)\nprint(key)\naes = AES.new(key, AES.MODE_ECB)\nflag = aes.decrypt(c)\nprint(\"Here is the decrypted flag: \"+str(flag))\n```\n\n最终得到flag\n\n![6](6.png)\n\n\n\n###### 参考资料：\n\n[1]王小云,刘明洁.格密码学研究[J].密码学报,2014,1(01):13-27.\n\n","tags":["project","competition","auroralab"],"categories":["auroralab"]},{"title":"Coppersmith攻击方式小结","url":"/2020/03/29/Coppersmith攻击方式小结/","content":"\n*这周本打算对各个方向有所了解，但进度并不是很如意，方向也有点分散。中间因为有点疲惫松懈了两天，后面有了精神以后首先写好了所有作业，然后做了几道CTF密码学题目，然后跟着就开始系统的小结一些密码学攻击方式，再接着就看起了密码学和人工智能安全相关的论文。论文还没细看，几道题目比较老套也没有什么太有新意的地方。但是毕竟立下了flag要一周写一篇文章，那么就只能把网上学习到的对Coppersmith的攻击方式完整地总结一下了。*\n\n# CopperSmith攻击\n\nCopperSmith攻击的种类真的很多，所以总是觉得自己归纳的不够彻底\n\n#### 一道新的例题——p的高位和地位泄露\n\n### *Securinets CTF Quals 2020 - Destruction*\n\n题目中提及MSB寓意即最高比特位，LSB即最低比特位，根据铜匠攻击即可,sage脚本：\n\n```python\nsize = 512\nsizep=256\nknownbits= 134\nN=14086160291425342283520344380411983364812792954622400251334758082442316624175006850950987254617679940795136231914925367368535278968830499182004816257654049\n\n#we need to define an polynomial == 0 (mod p) that gives us the missing part (x)\n# f_p(x) = x*2**(knownbits/2) + p_msb + p_lsb\n# it's not monic so we need to divide by 2**(knownbits/2)\n# set R = 2**(knownbits/2) and invert it modulo N\n\nR = 2**(knownbits/2)#从第68位开始测试\ninvR = inverse_mod(R,N)\n#补齐两边\np_msb = 251000163339563476196 << (sizep-knownbits/2-1)\np_lsb=int('2567fcb8c35e6dc63',16)\n#setup coppersmith\nF.<x> = PolynomialRing(Zmod(N))\n#define the poly in x modulo p\nf = x + (p_msb+p_lsb)*invR\n#solve it\nx0 = f.small_roots(X=2^(sizep-knownbits)-1, beta=0.44, epsilon=1/64)[0]\n\n \n\nprint (\"reconstructed p: {:x}\".format(Integer(x0*R)+p_msb+p_lsb))\n```\n\n在这道题目中，p的高位和地位比特都被泄露，可以解出rsa明文。\n\n#### 引申与补充\n\n除了上述例题所述的情况外，我目前至少见过四种coppersmith攻击模式。\n\n#### *2019强网杯-RSA-Coppersmith*\n\n1.challenge 1\n\n**已知明文的高位，是Stereotyped messages攻击 或 Lattice based attacks** \n\n```python\nn = #输入n  \ne = 3\nm = randrange(n)\nc = pow(m, e, n)\nbeta = 1\nepsilon = beta^2/7\nnbits = n.nbits()\nkbits = floor(nbits*(beta^2/e-epsilon))\nmbar = m & (2^nbits-2^kbits)\nc = 0x1f6f6a8e61f7b5ad8bef738f4376a96724192d8da1e3689dec7ce5d1df615e0910803317f9bafb6671ffe722e0292ce76cca399f2af1952dd31a61b37019da9cf27f82c3ecd4befc03c557efe1a5a29f9bb73c0239f62ed951955718ac0eaa3f60a4c415ef064ea33bbd61abe127c6fc808c0edb034c52c45bd20a219317fb75\n \nprint \"upper %d bits (of %d bits) is given\" % (nbits-kbits, nbits)\nPR.<x> = PolynomialRing(Zmod(n))\nf = (mbar + x)^e - c \nprint m\n \nx0 = f.small_roots(X=2^kbits, beta=1)[0]  # find root < 2^kbits with factor = n1\n \nprint mbar + x0\n \n```\n\n2.challenge 2\n\n**已知p的高位，Factoring with High Bits Known**\n\n```python\nn = 0x5894f869d1aecee379e2cb60ff7314d18dbd383e0c9f32e7f7b4dc8bd47535d4f3512ce6a23b0251049346fede745d116ba8d27bcc4d7c18cfbd86c7d065841788fcd600d5b3ac5f6bb1e111f265994e550369ddd86e20f615606bf21169636d153b6dfee4472b5a3cb111d0779d02d9861cc724d389eb2c07a71a7b3941da7dL\np_fake = 0x5d33504b4e3bd2ffb628b5c447c4a7152a9f37dc4bcc8f376f64000fa96eb97c0af445e3b2c03926a4aa4542918c601000000000000000000000000000000000L\n \n \n \n \n#pbits = 2048\npbits = p_fake.nbits()\n#kbits = 900\nkbits = 128  #p失去的低位\npbar = p_fake & (2^pbits-2^kbits)\nprint \"upper %d bits (of %d bits) is given\" % (pbits-kbits, pbits)\n \nPR.<x> = PolynomialRing(Zmod(n))\nf = x + pbar\n \nx0 = f.small_roots(X=2^kbits, beta=0.4)[0]  # find root < 2^kbits with factor >= n^0.3\np= x0 + pbar\nprint p\n```\n\n3.challenge 3\n\n**已知私钥的512位的低位 Partial Key Exposure Attack(部分私钥暴露攻击)**\n\n```python\ndef partial_p(p0, kbits, n):\n    PR.<x> = PolynomialRing(Zmod(n))\n    nbits = n.nbits()\n    f = 2^kbits*x + p0 \n    f = f.monic()\n    roots = f.small_roots(X=2^(nbits//2-kbits), beta=0.3)  # find root < 2^(nbits//2-kbits) with factor >= n^0.3\n    if roots:\n        x0 = roots[0]\n        p = gcd(2^kbits*x0 + p0, n)\n        return ZZ(p)\n\ndef find_p(d0, kbits, e, n):\n    X = var('X')\n \n    for k in xrange(1, e+1):\n        results = solve_mod([e*d0*X - k*X*(n-X+1) + k*n == X], 2^kbits)\n        for x in results:\n            p0 = ZZ(x[0])\n            p = partial_p(p0, kbits, n)\n            if p:\n                return p\n \n \nif __name__ == '__main__':\n    n = 0xd463feb999c9292e25acd7f98d49a13413df2c4e74820136e739281bb394a73f2d1e6b53066932f50a73310360e5a5c622507d8662dadaef860b3266222129fd645eb74a0207af9bd79a9794f4bd21f32841ce9e1700b0b049cfadb760993fcfc7c65eca63904aa197df306cad8720b1b228484629cf967d808c13f6caef94a9\n    e = 3\n    d = 0x603d033f2ef6c759aec839f132a45215fc8a635b757f3951a731fe60bc6729b3bcf819b57abfcaba3a93e9edef766c0d499cad3f7adb306bcf1645cfb63400e3\n    beta = 0.5\n    epsilon = beta^2/7\n    nbits = n.nbits()\n    print \"nbits:%d:\"%(nbits) \n    #kbits = floor(nbits*(beta^2+epsilon))\n    kbits = nbits - d.nbits()-1\n    print \"kbits:%d\"%(kbits)\n    d0 = d & (2^kbits-1)\n    print \"lower %d bits (of %d bits) is given\" % (kbits, nbits)\n    p = find_p(d0, kbits, e, n \n    print \"found p: %d\" % p\n    q = n//p\n    print d\nprint inverse_mod(e, (p-1)*(q-1))\n```\n\n#### *私钥泄露*\n\n这部分学习的是在[网上]( https://ctftime.org/tasks/?tags=crypto&hidden-tags=crypto )看到的一道题目的一篇[wp](https://github.com/p4-team/ctf/tree/master/2019-09-21-dragonctf/rsachained)写的，都说密钥时现代密码的弱点，所以rsa私钥部分泄露原来也可以导致对rsa的铜匠攻击！这部分的方程倒不难推算，因此我也出了一道和私钥泄露有关的题目,[题解](../极光实验室战队考核密码学部分考察点与题解)也在博客里。这里把sage脚本也放出来吧。\n\n```python\ne=863\nn = 100518394843898371534434468452366727877002363101196571557097132988734353726584916462381290904798733002716305256677572628142627545744681541293793069726231800754314572981168235829239563613754713724345581918566947492170647540708428013292098065584617876680109166595710006367308500341766024651457023537770009981295726110940010220082434490215229951191714998895277291076151298363584672162765486380515325199053994651202708865071379999942193926154807059329464291992287421875356468218685095369057734586073271903432589401520355996027480658214090147502829069822606753125953586123331154015992246394834867237734405963056883227552074835515815968441\nc=86032824638305503499105979004374728344861493802341583733786447138684660694449673826205271902766363026345759436852747743967254218765160248630402258125202844303276381357264903281385470521070161164325276902001627351570675438339067652784355957225763207341000628151024518554862922220201109512940053316358078220681816224518400117972877854801506805929902506832781106133167532327833813179558969694268634413548545525533605595649634856393268111552838570383386406869870266457914799472663817890880697043874427042958587244568923338441053981863674366842769379075373006984522023718553749977766836594738859315852333132093474709715377682153430675891\nd0=8429433927120666131169351623736961178529851960373209550653840828920672665447032524933438956407503522388445988812739437427277858013428300926608147855795349674824173869269407061090165202002106353884034590344852857623737262477675587193006629765892565228448265429521617733861051151345083787592170864896543517637252788111\n\nd = 0\nfor k in range(0,e):\n    print k\n    X = var('X')\n    results = solve_mod([e*d0*X - k*(n*X-X*X-n+X) == X], 2**1050)\n    for x in results:\n        p0 = ZZ(x[0])\n        if is_prime(p0) and gcd(n,p0)!=1:\n            print p0\n            q0 = n//p0\n            phi=(q0-1)*(p0-1)\n            d = inverse_mod(e,phi)\n            break\n    if(d!=0):\n        break\nprint d\nm = pow(c,d,n)\nprint m\n```\n\n#### *其他题目*\n\n除此以外，印象中还存在另外一些coppersmith题目，印象中我把所有解方程有关的题目都当成coppersmith了。我新人赛的时候也心血来潮自创了一题，打算放到校赛用。反正最基础的办法就是：**找齐足够的方程，代入消元求解。**","tags":["exploration"],"categories":["auroralab"]},{"title":"安卓反混淆软件探索-deobf","url":"/2020/03/19/安卓反混淆软件探索-deobf/","content":"\n## 前言\n\n我们的大创项目其实是分两方面进行的，一方面，我们从代码混淆的角度比较各种软件对安卓程序的加固能力；另一方面，我们着重针对OLLVM进行反混淆测试。OLLVM集成了代码混淆的几种最基本的方法：控制流平坦化，虚假控制流，指令替代等三种方式；其中控制流平坦化和虚假控制流可以混淆各个基本块之间的执行顺序，使得程序的执行流程更难读懂，但是它们有一个致命的攻破方法——符号执行。这不仅成为了每一位资深逆向人员必备的技能，而且也逐渐被开发成了自动化反混淆工具。目前市面上开源的自动化反混淆工具很少，有一款是[针对安卓应用的simplify](https://github.com/CalebFenton/simplify) ，另外我在github上面搜寻了OLLVM的反混淆软件，排除大部分无用的项目，最终只发现了这两个有实际价值的项目。\n\n#### [ollvm_de_fla]( https://github.com/sfwishes/ollvm_de_fla)\n\n针对控制流平坦化的反混淆工具，不足之处就是只适用于带thumb2指令的ios macho格式文件，因此它的平台普适性不高，应用范围极其窄。 该项目于两年前便停止更新。\n\n#### [deobf](https://github.com/maiyao1988/deobf )\n\ndeobf主要也是针对控制流平坦化这种主流的代码混淆方式。相比ollvm_de_fla，deobf的优势多很多。首先，这是一个新兴项目，创建于大约四个月前，在四天前还曾发布了重大更新。另外，这个项目适用于linux和windows等大众平台，可以不限于thumb指令的使用，有着广泛的应用前景。在项目的说明文档中，很清楚的说明了项目的拷贝方法，安装方法和运行参数。**不仅可以反混淆一般的so文件，也可以针对性的处理抖音的libcms.so文件。**\n\n但是这个项目依然有着自己的不足，只适用于python3.7版本，更低级的版本不能兼容。\n\n## 下载与安装\n\n由于deobf需要python3.7环境支持，所以需要下载python3.7，在linux下默认的环境没有python3.7，升级步骤可以参考一篇不错的[文章]( https://blog.csdn.net/u014775723/article/details/85213793) 。后来在windows下也安装了一个，按照[项目链接](https://github.com/maiyao1988/deobf )下第二步的详细做法完成即可。但是这里建议把32位和64位的keystone都下下来（当然32位的比较重要）。如果运行报错很有可能是dll的原因，两个dll混搭着用应该就没有问题。\n\n## deobf反混淆原理初探\n\n#### 基于OLLVM的反混淆框架的实现\n\n一般的反混淆软件都会有以下几个模块:\n\n1）**基本块识别模块** ：识别出有用块和无用块。经 OLLVM 控制流平展化混 淆的程序中会增加很多无用的基本块以混淆程序逻辑，这就 需要设计有效的基本块识别算法，找出有用的基本块和无用 的基本块。\n\n 2）**与程序执行流程相关模块** ：确定有用块之间的前后关系，得到真实有效的程序执行路径，因为混淆程序中的很多基本块跳转逻辑并不是程序的实际执行流程。 一般采用符号执行技术。\n\n3）**指令修复模块** ：修复二进制程序。在使用 NOP 指令填充无用基本块 后，为使程序正常运行，我们需要对跳转指令的跳转偏移量 进行修正；同时，还需要将 cmov 条件传送指令改写成相应 的条件跳转指令，并在其后添加一条 jmp 指令，使其跳向另 一分支。 \n\n*参考文献*\n\n*[1]肖顺陶,周安民,刘亮,贾鹏,刘露平.[基于符号执行的OLLVM反混淆框架](http://kns.cnki.net/kcms/detail/51.1307.TP.20180319.1531.012.html.)[J/OL].计算机应用:1-6[2020-03-22].*\n\n*[2]肖顺陶,周安民,刘亮,贾鹏,刘露平.基于符号执行的底层虚拟机混淆器反混淆框架[J].计算机应用,2018,38(06):1745-1750.*\n\n#### 通过IDA调试确定基本块的前后关系\n\n这是deobf的一个突出特点，它是根据一个IDA-python脚本直接对软件执行调试，通过这里确定程序的执行流程。[参考脚本 ](**https://github.com/maiyao1988/IDAScripts/blob/master/trace.py**)。\n\n这也就意味着，和传统采用的符号执行不同，**deobf不需要虚拟执行的结果，而是实打实的进行了调试。但是这样的确定就是不能抗动态调试。万一一个程序加入了很多的动态调试函数，那么讲给deobf的运行效果带来很大的挑战。**\n\n## deobf反混淆效果\n\n#### 参考\n\n由于deobf的软件的基本框架和上述论文中的反混淆框架在思路上完全一致，除了确定基本块以外其他方面的实现方案上大致相同，因此在这里先引用一下论文中有关混淆效果的数据，如下：\n\n![image-20200322231048178](image-20200322231048178.png)\n\n\n\n\n\n![image-20200322231036631](image-20200322231036631.png)\n\n#### 验证\n\n为了验证OLLVM的反混淆效果是否真的和论文一致，我使用项目中提供给测试使用的so文件进行混淆，这个项目运用了\n\nida查看混淆后的控制流图，十分复杂庞大：\n\n![image-20200320000323204](image-20200320000323204.png)\n\n而反编译后的伪C代码如下，十分复杂，出现多个嵌套的while循环和if分支语句：\n\n```c\nint __fastcall JNI_OnLoad(int a1)\n{\n  int v1; // r0\n  signed int v2; // r6\n  int v3; // r11\n  signed int v4; // r5\n  bool v5; // zf\n  signed int i; // r0\n  int result; // r0\n  int v8; // [sp+8h] [bp-30h]\n  int v9; // [sp+Ch] [bp-2Ch]\n  int v10; // [sp+10h] [bp-28h]\n  int v11; // [sp+14h] [bp-24h]\n  int v12; // [sp+18h] [bp-20h]\n\n  v10 = 0;\n  v1 = (*(int (**)(void))(*(_DWORD *)a1 + 24))();\n  v2 = 189500648;\n  v8 = v1;\n  while ( 1 )\n  {\nLABEL_3:\n    while ( 1 )\n    {\n      v3 = v1;\n      v4 = v2;\n      if ( v2 > 941059666 )\n        break;\n      if ( v2 > -526232813 )\n      {\n        if ( v2 == -526232812 )\n        {\nLABEL_2:\n          v2 = 1535406375;\n          v1 = -1;\n          continue;\n        }\n        if ( v2 == 189500648 )\n        {\n          v2 = 2058077166;\n          if ( v8 )\n            v2 = 1482189424;\n        }\n      }\n      else\n      {\n        v2 = 1535406375;\n        v1 = 65540;\n        if ( v4 == -1125020146 )\n          continue;\n        v5 = v4 == -724953770;\nLABEL_10:\n        v1 = v3;\n        v2 = v4;\n        if ( v5 )\n          goto LABEL_2;\n      }\n    }\n    if ( v2 <= 1535406374 )\n    {\n      if ( v2 == 941059667 )\n      {\n        v11 = (*(int (__fastcall **)(int, const char *))(*(_DWORD *)v9 + 24))(v9, \"com/douyu/lib/http/JniMakeUrl\");\n        for ( i = 1448204801; ; i = 1422645221 )\n        {\n          v2 = -1125020146;\n          if ( i > 1398646745 )\n            goto LABEL_36;\nLABEL_33:\n          while ( i == 193258894 )\n          {\n            v5 = (*(int (__fastcall **)(int, int, char **, signed int))(*(_DWORD *)v9 + 860))(v9, v11, off_45004, 7) == 0;\n            i = -686378191;\n            if ( !v5 )\n              i = -986576434;\n            if ( i > 1398646745 )\n            {\nLABEL_36:\n              while ( 2 )\n              {\n                while ( i == 1448204801 )\n                {\n                  i = 193258894;\n                  if ( !v11 )\n                    i = 1398646746;\n                  if ( i <= 1398646745 )\n                    goto LABEL_33;\n                }\n                if ( i == 1398646746 )\n                {\nLABEL_32:\n                  i = 1422645221;\n                  v2 = -724953770;\n                  continue;\n                }\n                break;\n              }\n              if ( i == 1422645221 )\n              {\n                v1 = v3;\n                goto LABEL_3;\n              }\n              while ( 1 )\nLABEL_47:\n                ;\n            }\n          }\n          if ( i == -986576434 )\n            goto LABEL_32;\n          if ( i != -686378191 )\n            goto LABEL_47;\n        }\n      }\n      v5 = v2 == 1482189424;\n      goto LABEL_10;\n    }\n    if ( v2 != 2058077166 )\n      break;\n    v2 = 941059667;\n    v9 = v10;\n    if ( !v10 )\n      v2 = -526232812;\n  }\n  if ( v2 != 1535406375 )\n    goto LABEL_3;\n  result = _stack_chk_guard - v12;\n  if ( _stack_chk_guard == v12 )\n    result = v3;\n  return result;\n}\n```\n\n执行如下反混淆指令，反混淆其中的JNI_Onload函数：\n\n` python deobf.py libmakeurl2.4.9.so url.so ins-url.trc 0x0000342C 0x00003668 1 `\n\n以下是对各个参数的注释：\n\n待处理的混淆文件：libmakeurl2.4.9.so\n\n反混淆后输出的文件：url.so\n\n 通过ida调试时产生的目标函数的跟踪文件（可以跟踪关键指令或函数） ：ins-url.trc\n\n混淆代码段起始部分偏移：0x0000342C（JNI_Onload函数开头）\n\n混淆代码段结束部分偏移：0x00003668（JNI_Onload函数结尾）\n\n目标函数是否是thumb：是\n\n反混淆后的控制流图，程序执行流程变得十分清晰：\n\n![image-20200320000158559](image-20200320000158559.png)\n\n反混淆后的函数也变得简短易懂：\n\n```c\nint __fastcall JNI_OnLoad(int a1)\n{\n  int v1; // r11\n  int v2; // ST0C_4\n  int result; // r0\n  int v4; // [sp+10h] [bp-28h]\n  int v5; // [sp+14h] [bp-24h]\n  int v6; // [sp+18h] [bp-20h]\n\n  v4 = 0;\n  (*(void (**)(void))(*(_DWORD *)a1 + 24))();\n  v2 = v4;\n  v5 = (*(int (__fastcall **)(int))(*(_DWORD *)v4 + 24))(v4);\n  (*(int (__fastcall **)(int, int, char **, signed int))(*(_DWORD *)v2 + 860))(v2, v5, off_45004, 7);\n  result = _stack_chk_guard - v6;\n  if ( _stack_chk_guard == v6 )\n    result = v1;\n  return result;\n}\n```\n\n## 其他OLLVM反混淆软件常用技术\n\n#### 符号执行\n\ndeobf的反混淆主要借助与符号执行技术，符号执行技术的核心思想是使用符号值来表示程序的输入数据，并将程序的运算过程逐指令或逐语句地转换为数学表达式，在CFG的基础上生成符号执行树，并为每一条路径建立一系列以输入数据为变量的符号表达式。在符号执行过程中，每当遇到判断与跳转语句时，deobf便会将当前执行路径的路径约束收集到该路径的约束集合中。通过使用约束求解器对约束集合进行求解，可以得到该条路径的可达性：如果约束求解的结果有解，表示该条路径可达，否则表示该条路径不可达，在时间与计算资源足够的理想情况下，符号执行能够遍历目标程序的所有路径并判断其可达性。\n\n其中，路径约束是指程序分支指令中与输入符号相关的分支条件的取值，是一系列不具有量词的布尔型公式。而路径约束集合则被用来存储每一条程序路径上收集到的约束，用“与”操作进行连接。\n\n借用软件安全课程的图片，对于下图示例程序1：\n\n![image-20200319232030997](image-20200319232030997.png)\n\n首先画出控制流图，切割基本块。然后计算得函数外部的输入变量数为2，我们只需要设置两个输入变量X,Y。程序中的所有都用与X,Y相关的式子代替。\n\n![image-20200319233648011](image-20200319233648011.png)\n\n然后进入函数顺序执行第2-4行，不出现分叉，在第五行代码时，由于是判断语句，符号执行树出现分支，满足分支条件的作为左子树，不满足的作为右子树，左右子树又继续根据路径约束进一步细化，出现更多分支。最终扩展出的符号执行树如图：\n\n![image-20200319233036906](image-20200319233036906.png)\n\n最后，通过将X、Y变量代入，计算叶子节点的约束集合是否为真，则可以知道哪些路径是可达的。\n\n","tags":["project"],"categories":["project"]},{"title":"记一次安卓代码加固软件的测试过程","url":"/2020/03/13/记一次安卓代码加固研究过程/","content":"\n在大创项目的实践中，我们对市面上的一些安卓代码加固软件进行了采集，经过搜集，发现了几类代码加固方法并分组进行研究。我发现很多代码加固软件都是对java字节码进行混淆与加固，另外一些则选择对原生语言和so文件进行加固，而我打算研究的这一款软件，则是对资源文件进行加固，它就是[AndResGuard]( https://github.com/shwenzhang/AndResGuard/blob/master/README.zh-cn.md )。\n\n### 混淆原理\n\n大致上来说就是apk在调用资源的时候不是通过资源名来调用的，而是通过一个资源ID值来调用的，因此资源名和资源ID存在一种映射关系，保存在 resources.arsc 中。而由于资源名是一种相对独立的存在方式，仅仅是为了源码的易读性，所以可以用用更短的资源名取代，从而减少apk文件的体积；而新的代号没有任何语义上的可读性，所以可以达到混淆的目的。而且由于这种映射关系是独立于安卓编译过程的，所以我们可以在整个apk的基础上进行操作，通过实现对apk的解压并修改资源文件和 resources.arsc 进行混淆。\n\n项目贡献者的说明文章见[这里](https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&mid=208135658&idx=1&sn=ac9bd6b4927e9e82f9fa14e396183a8f#rd )。\n\n### 混淆过程\n\n为了统一研究对象，采用的混淆软件是我第六次安卓作业后生成的apk文件:\n\n![](1.png)\n\n下载完整个项目以后，最重要的文件是箭头所指的jar文件，这个其实就是源码编译以后的可执行文件了：\n\n![](2.png)\n\n不过还需要输入一些参数才可以运行，包括待混淆apk，混淆配置文件，输出路径，甚至可以加入签名库的路径。\n\n#### 配置\n\n输入参数前，先更改一下混淆配置文件，打开config.xml后，我根据实际研究的情况作了如下更改。\n\n1.**设置不采用7z压缩。**显然，7z压缩是这个软件集成的外部功能，一方面能更加减小程序的空间，另一方面也可以提高程序表观上的复杂程度。但是需要指出的是，7z压缩在AndResGuard中是一个比较独立的组成部分，首先在技术原理和实现方式上就有很大的不同，而且7z压缩更像是对混淆后资源文件的一种打包技术，就像是把安卓源码混淆后再进行打包一样，有着独立的压缩和解压方法，并不涉及任何混淆的思想，也不需要任何的反混淆技术。而如果采用7z压缩后再进行分析，就相当于采用两种技术加固软件后和其他采用一种技术加固软件的方法进行优劣比较，这种方法是不合理的。\n\n![](3.png)\n\n2.**设置不采用签名。**由于混淆前的软件没有采用签名技术，因此作为对照组，混淆后的软件也不应该采用签名技术。\n\n![](4.png)\n\n#### 混淆\n\nAndResGuard的混淆是针对整个文件进行的，只需要输入如下参数即可：\n\n![](5.png)\n\n耗时不到5秒即完成。\n\n#### 混淆效果测试\n\n混淆后，从程序体积，代码可读性等两方面分析混淆效果，主要出现了如下变化：\n\n1.**体积变小。**混淆后生成了另一个apk，把两个apk放在一起，可以明显的看到混淆后的apk文件体积变小，从2511kb变为2104kb。\n\n![](6.png)\n\n2.**资源文件的可读性变复杂，资源名的失去了原有的语义。**采用apk-tool对混淆前后的apk文件进行反编译。这款软件的优势在于可以把apk的文件转变为smali中间代码和资源文件源码，把 resources.arsc还原为原来的res文件夹。通过Android Studio对比整个res文件夹的结构，我们可以发现如下变化：\n\n(1)资源名称出现变化\n\n资源文件总量不变，名称被更短的代号取代。\n\n以Layout文件夹为例，混淆前的前四个资源文件名称如下：\n\n![](7.png)\n\n而混淆后的资源文件名则被更简短的代号取代。以Layout文件夹为例，混淆后的前四个资源文件名称如下：\n\n![](8.png)\n\n点击混淆前和混淆后最上方的文件，发现文件的内容已经不再对应，所以可以认为这是一种无规律的命名，打乱了各个资源文件名的对应关系。\n\n（2）资源文件中所有的引用名都被修改\n\n在res文件夹下所有的所有资源引用中，资源名都被更改，以res\\values\\attrs.xml为例，混淆前我们可以获取完整的资源名称，如图：\n\n![](9.png)\n\n而混淆后，所有的资源名都变为了简短的代号。\n\n![](10.png)\n\n3.**值得注意的是，源代码中所有的内容都不曾被改变，这说明AndResGuard不依赖于smali代码和编译过程。**首先把apk的后缀改为rar并解压，取出dex文件采用dex2jar进行反编译，再使用jd-gui打开生成的jar文件，我们可以发现，混淆前的jar包和混淆后的jar包是完全一致的，以MainActivity为例，混淆前后完全看不出任何区别。混淆前代码如下：\n\n![](11.png)\n\n混淆后代码如下：\n\n![](12.png)\n\n#### 运行性能测试\n\n首次运行混淆后的程序时，出现如下报错：\n\n![](13.png)\n\n查阅[资料]( https://blog.csdn.net/almosti/article/details/88586873 )后猜测报错原因.\n\n但测试了一遍ARM框架的软件还是不行，那么我推测，报错的原因很有可能是因为资源文件被打乱，导致虚拟机无法识别。我尝试用华为手机下载，里面的报错是：该安装包未包含任何证书，因此我可能需要考虑一下运行参数的问题了。但是在测试了除了签名之外的参数后，发现依然无法运行。但是用.android目录下的debug.keystore签名时出现报错，报错情况如下：\n\n![](14.png)\n\n目前暂不知错误，正在分析中。**希望大家可以帮帮我！**不知道是否需要其他什么文件呢。\n\n### 总结\n\n其实AndResGuard就是对apk包的资源 resources.arsc进行更改，使得原有的资源文件中的资源名变得更加简短而不可读。这增加了安卓逆向人员的分析难度，实现了代码混淆。","tags":["project"],"categories":["project"]},{"title":"一个局外人对227事件的认识","url":"/2020/03/05/一个局外人对227事件的认识/","content":"\n## 前言\n\n很抱歉，这本来应该是一篇很长的日记，似乎我很少这样对这么多网友敞开心扉，而且我真的不知道我这样理解对不对；但是我的博客本来就是写给自己看的，应该没有什么人关注，所以暂时也没有必要计较我在写什么以及你是谁。我只是想中肯地发表自己的观点罢了，为了不加入自己的情绪，我在对朋友说的那句话里面进行了一些修改，把可能表述不太对的部分去掉了，所以如果那位朋友理解我的观点，也想进行更深入的沟通的话，可以微信私聊我。另外明天就是你的生日，所以近期我没有主动找你谈这件事了，也希望你生日那天能够开开心心的！\n\n## 对227事件的一些看法\n\n这件事让我我认识到了三点：\n\n（1）双方都有自己的道理，但也有过激的行为。\n\n（2）没有完美的人，也没有完美的解决方案。\n\n（3）在这件事上，我永远都是旁观者，永远都无法站在亲历者的角度去感同身受。\n\n我觉得，从2.27以来，两边都闹得不是很好看，而且xzf还有把事情愈演愈烈的趋势，我不知道是什么导致了大家把一件很小的事情越闹越大。我把这件微博热搜第一而且震动了整个娱乐圈，饭圈，同人圈的事情问了母亲，她的第一反应就是，在那个连温饱都很难保证的年代，谁会关心娱乐圈的这种小事。现代人的精神生活境界越来越高，但是却出现了一些畸形的东西。一点即燃的网络暴力无处不在，对偶像的盲目崇拜，对某个话题的敏感和不自禁的代入，让这个虚拟世界充满了战火，甚至燃烧到了现实世界。\n\n---\n\n对此，我不禁想对我的同人圈的朋友说：\n虽然我真的很想安慰你 也对一个自由创作平台 甚至是亲手写的作品的丢失 感到心酸 但我可能还是不能切身做到处地的感受吧 毕竟我对此了解少之又少 再怎么说都很难做到真正的理解 我只能尝试着去理解 但是 现在 我觉得 双方都有错 维护自己的权益是对的 但我不支持大家采用过激的手段 xz的粉丝举报的权利没错 但是他们举报错了对象 而且形成了一种煽动性的举报 同人圈的反击没错 但是矛头不应该是xz 而且应该适可而止 那几位牵头的粉丝已经知道错了 也给很多无脑粉上了一课 那就够了 何必再影响其他没有错的人  网络是个虚拟的世界 再无路可退 我们还有现实作伴 那就是 身边的花花草草 蓝天白云 竹林晚风 我们可以在著作中品尝优美的文字 可以翻看经典的电视剧和电影 获取做人的道理 累了 可以书写自己的日记 把自己的灵感和美好的瞬间记录下来 网络应当只是我们的辅助 这两个月 离开了网络 我依然能快乐幸福的度过 所以说 没有网络 我们虽然可能没有这么方便 但是依然可以很幸福 网络世界不是我们的全部 希望你能从悲伤失落中恢复过来 世界很大 我们并没有不能离开的东西\n\n上面这段话写于3月2日，但是我总觉得我的理解可能有什么问题，我希望能等你气消了再与你讨论这个问题。作为好朋友，我能做的，只有把我的所感形成文字先记录下来。\n\n---\n\n我还想对肖战的粉丝说：\n\n停止这场战争吧，恶果已经酿成，大家已经两败俱伤，没有必要鱼死网破。\n\n---\n\n我还想对各位网友说：\n\n追星没错，我最近也开始追星了，但是，希望大家理性追星，不要这么轻易被别人煽动情绪，当你要发表言论或者做一件事情的时候，能否三思而后行，先想想后果。希望大家在网络上不要咄咄逼人，一副见人就喷的感觉，大家坐下来，好好谈，难道不行吗？\n\n","tags":["diary"],"categories":["diary"]},{"title":"安卓开发中遇到的坑坑洼洼","url":"/2020/03/01/安卓开发中遇到的坑坑洼洼(持更中)/","content":"\n\n\n大三下学期选修了十分重要的安卓开发课程，老师让我们编写编译书中的程序并完成书后的挑战练习。但是由于Android Studio的版本问题和gradle脚本以及主程序的命名与书中不同，这次编程还是遇到了一点坑，这迫使我上网查资料，并且认真研读资源目录和gradle的源代码，以找到出错的地方。以下是我的一些发现和遇到的一些坑：\n\n#### 版本要匹配\n\n千万不要随便改变项目根目录和app目录下的build.gradle，我更改了几个参数，导致编译通过后打包失败：\n\n1.项目根目录下的插件版本“build:gradle:3.4.1”，这个版本号不能随便改，原因是你的AS版本不一定支持对应的gradle版本和插件版本，当然，当AS更新以后，可能旧项目中的版本不能被支持，这个时候你就需要去更改以下几个地方：\n\n（1）项目根目录下的插件版本号，这个和AS的版本应该是一致的\n\n（2）gradle-wrapper.properties下的distributionUrl，一定要找到这个插件版本号对应的Gradle版本号，具体参考 [这里](https://blog.csdn.net/sqf251877543/article/details/101281308)\n\n（3）下载对应的gradle版本，网址就是distributionUrl的地址。\n\n2.在app目录下的build.gradle也涉及到一些版本的问题，一是compileSdkVersion不能小于某个值，否则会报错；二是minSdkVersion的更改可能会导致在某些手机上不适配，我曾经把minSdkVersion由16改为\"R\",结果在虚拟机上就不能运行了，据网上资料说，只要把minSdkVersion值设为19以下，就可以适配95%以上的安卓手机。\n\n3.版本不匹配会出现如下报错:\n\n(1)Invalid escape sequence at line 1 column xx path $[0].name\n\n(2)gradle project sync failed\n\n(3)Could not find method google() for arguments [] on repository container\n\n4.但是有时候报上述第3点的第（1）条错误时不一定是版本问题，若版本正确仍出现如上问题，应当考虑 开File->Setting->找到instant run（或者搜索）->取消Enable instant run。然后应用即可。 \n\n5.同样的，**虚拟机版本的不同**也可能导致一些问题。比如对于第三章，有的手机屏幕旋转了以后会改变设备配置，从而改变Activity生命周期，但有些却不行。在测试中，Nexus 5 API 29(Android 9+)旋转不会改变Activity生命周期，也不会改变设备配置，但Nexus 5 API 27(Android 8)会。\n\n#### 提示无法执行\n\n1.遇到了一个问题，当我使用Log.d的时候安卓提示要导入android.util.log，但是无法点击，手动输入也不行，后来发现util下面用的是Log这个包，所以有时候提示也是不正确的。\n\n#### 类名的对应\n\n1.在主控制器中，private static final String TAG这个字符串对应的值应该和主控制器名称对应，虽然在第一第二章的时候问题不大，但是使用logcat测试后会发现有很严重的异常报错。\n\n#### 覆盖@Override\n\n1.必须调用父类的同名方法，否则报错：\n\n> Overriding method should call super.onActivityResult less... (Ctrl+F1) \n> Inspection info:Some methods, such as View#onDetachedFromWindow, require that you also call the super implementation as part of your method.  Issue id: MissingSuperCall\n\n#### 中文路径\n\n1.安卓虚拟机最好不要放在有中文的路径下，否则录屏出现如下报错：\n\n>  Emulator: emulator: ERROR: FfmpegRecorder.cpp:267: Could not open [C:\\Users\\?????\\.android\\avd\\Nexus_5_API_27.avd\\tmp.webm]: Invalid argument \n\n这些问号就是中文字符\n\n#### Android Studio平台的一些问题\n\n1.虚拟机默认装C盘，我刚刚清出的一点空间，开了三个虚拟机，结果全满了，占了我C盘一半的空间！[解决方法](https://blog.csdn.net/geekqian/article/details/60145357 )\n\n2.新版的Android Studio找不到DDMS, 如果只是需要查看文件，可以在View->Tools WIndows下选Device File Explorer.\n\n#### LogCat过滤关键词\n\n1.关键错误：FATAL EXCEPTION\n\n#### 空指针问题\n\n在水平方向上运行安卓没问题，竖直方向运行安卓的时候程序终止，明显是布局的问题。LogCat报错如下：\n\n> 2020-03-07 18:49:45.296 3434-3434/com.example.geoquiz E/AndroidRuntime: FATAL EXCEPTION: main\n>     Process: com.example.geoquiz, PID: 3434\n>     java.lang.RuntimeException: Unable to start activity ComponentInfo{com.example.geoquiz/com.example.geoquiz.MainActivity}: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object reference\n> \t……\n>     Caused by: java.lang.NullPointerException: Attempt to invoke virtual method 'void android.widget.Button.setOnClickListener(android.view.View$OnClickListener)' on a null object reference\n>         at com.example.geoquiz.MainActivity.onCreate(MainActivity.java:54)\n>        ……\n\n上网查资料，[参考文章](https://blog.csdn.net/qq_42618969/article/details/81141895 )\n\n先去看看布局文件里面有没有id，很有可能是因为这样导致的空指针，结果发现 不知道为什么两个button的布局代码没了， 所以找不到按钮的地址 ， 形成了空指针  。\n\n","tags":["study"],"categories":["study"]},{"title":"对音频缓存加密的探讨","url":"/2020/02/17/对音频缓存加密的探讨/","content":"\n![img](1.png)\n\n前段时间，某音乐被爆其缓存文件只使用了简单的异或加密，且容易得到加密密钥为0xa3。[原文链接点击这里]( https://forum.90sec.com/t/topic/38/9 )。以下是我的延伸探讨。\n\n## 1.对音频缓存的批量解密攻击\n\n[^该部分来自于我11月份写的推送]: \n\n抱着好奇的心理，我把手机里面该音乐的缓存转到了电脑上面，如图：\n\n![img](2.jpg)\n\n据分析这些UC！文件就是加密后的MP3文件。\n\n用010editor打开其中一个文件，发现存在很多0xa3的字符，如果我们断定网易云用的是异或加密，那么极有可能原文就是0x00，那么异或的密钥就是0xa3。还原得到可以被qq音乐播放的mp3文件：\n\n![img](3.jpg)\n\n通过010editor逐一分析，发现加密密钥的确都是0xa3。既然加密密钥都是同一个，那么用010editor手改上百个文件就太难受了，能否写一个脚本或者程序来跑一下呢？\n\n由于我刚学了java，觉得java文件流很不错，于是我就用java编写以下脚本：\n\n```java\nimport java.io.*;\n\npublic class Main {\n    static FileInputStream fis;\n    static  FileOutputStream fos;\n    public static void main(String[] args) throws IOException {\n   // write your code here\n        String path = \"*********\";\n        travelfolder(path);\n    }\n    public static void travelfolder(String path) throws IOException {\n        File file = new File(path);\n        if (file.exists()) {\n            File[] files = file.listFiles();\n            if (null != files) {\n                for (File file2 : files) {\n                    if (file2.isDirectory()) {//文件夹\n                        System.out.println(\"进入文件夹:\" + file2.getAbsolutePath());\n                        travelfolder(file2.getAbsolutePath());//深度优先遍历算法\n                    }\n                    else {\n                        //普通文件\n                        if(file2.getName().substring(file2.getName().length()-3).equals(\"mp3\"))\n                        {\n                            //这些是已经改好的文件，不必修改\n                            System.out.println(\"MP3文件:\" + file2.getAbsolutePath());\n                        }\n                        else if(file2.getName().substring(file2.getName().length()-3).equals(\"uc!\"))\n                        {\n                            //这些文件还没修改\n                            System.out.println(\"UC!文件:\" + file2.getAbsolutePath());\n                            fis = new FileInputStream(file2);\n                            File newfile = new File(file2.getName().substring(0,file2.getName().length()-4));//把uc!文件变为mp3文件\n                            fos = new FileOutputStream(path+\"\\\\\"+newfile);\n                            byte[] buf = new byte[1024];//缓冲区\n                            int length = 0;\n                            while((length = fis.read(buf)) != -1){\n                                for(int i=0;i<length;i++)\n                                {\n                                    buf[i]^=0xa3;//还原\n                                }\n                                fos.write(buf);\n                            }\n                            fis.close();\n                            fos.close();\n                        }\n                    }\n                }\n            }\n        } else {\n            System.out.println(\"文件不存在!\");\n        }\n    }\n}\n\n```\n\n于是开始运行这段代码：\n\n![img](4.jpg)\n\n运行后就得到了我们想要的mp3文件啦！\n\n![img](5.jpg)\n\n## 2.音频缓存加密过于简单的原因\n\n当然，音频的缓存文件是不可能太过于复杂的，我们听音频的时候，是很讲求时效性的，如果使用太复杂的加密方式，那么可能会导致播放器卡顿。使用异或的加密方式，虽然不太安全，但是还原起来还是很容易的。有时候，安全和性能往往会相互牵制，因此对产品开发者来说，需要把握好安全和性能间的平衡。当然，该音乐应用对安全的把握其实是不太好的，因为解密一首音乐，甚至可以不用写脚本。\n\n## 3.对音频缓存加密方式的建议\n\n其实该音乐应用可以改进加密算法，提高密钥空间的分析。\n\n市面上目前也有很多音乐应用，使用了比较好的加密算法。\n\n例如qq音乐采用了tea加密。如果tea加密比较复杂的话，我认为用维吉尼亚加密也可以，但是注意密钥要稍微长一些，不然通过对文件头的分析是可以把密钥给重新还原的。","tags":["project"],"categories":["project"]},{"title":"ACTF新人赛密码学部分考察点与题解","url":"/2020/02/16/ACTF新人赛密码学部分wp/","content":"\n新生赛是我进入实验室以来参与出题的第一场比赛。为了这个比赛，我在平时还是做了一些积累，只有有灵感，我就着手开始写出题脚本和解题脚本，然后有一道自己完成不了的题目就麻烦DJ学长帮我写了一下，在这里感谢DJ学长啦！第二次在gitea上协作完成项目，无论是实验室的同学，学长，学弟还是河北师范的同学都给予了我很大的帮助。这次我吸取了之前密码学实验项目的教训，对于分支，调试，校对，发布的流程有了更多的了解。另外这次出题，在苏洋同学的帮助下我终于开始用git bash了，这也为我后面自学开博客打下了基础。最后，这次我也格外注重了文档的规范性，每一道题目都提前按格式把出题方向，题解，源代码，发布的题目，提示，题干，hint给写好了。![出题文件层次分明](1.png)\n说起这次题目的遗憾，就是有两道稍微有难度而又很有意思的题目没有放上来。看了大家的做题情况，密码学的题目基本上都还是几位同学在做。所以对于更加复杂的两道题目，我认为没有必要这么早放上来了，等到校赛吧，等着你们成长。我看到同学们也努力了，比如某位同学，辛辛苦苦终于解出了一道维吉尼亚，当然他一开始对维吉尼亚有些误解，也问了我，最后独立的把题目解了出来。我觉得不管能不能解出题目，只要题目足够有意思，大家足够享受这个过程，就够了。还有一个比较悲剧的，就是没想到杂项出题的学长会和我出了同一个考点，面对着90%以上的题目相似度，我觉得学长题目内容的确更简洁一些，而我的题干更好一些，于是我就放弃了我的那道题目，把自己的题干放到了杂项的那道题目那里。杂项密码学也有千丝万缕的联系呢，少一道也不亏。以下是同学们的完成状况：\n![2](2.png) ![3](3.png) ![4](4.png) ![5](5.png) ![密码学题目完成情况](6.png) ![杂项题目完成情况](7.png)\n从同学们的完成状况来看，密码学的确没有杂项，逆向和web那么受欢迎，究其原因，应该是密码学的就业面没这么大，而且理论相对深奥，难度较大。但是我认为密码学一直都是挺有意思的存在，多了解一些密码学的知识点总是好的，如果的确有能力，可以做做密码学的研究；觉得自己能力不够的话，退而研究算法，或者在信息安全的其他方面引入密码学的知识，活学活用也很不错。好了，接下来就是这次的wp，我觉得自己这次的题目还是偏简单了一些，和CTF有比较大的差别，另外为了使一道题目有更多的考点，也更加有趣，我的确准备了很多的压缩包密码，所以遭到了一些吐槽。不过也没关系啦，继续完善一下自己，争取校赛能提供更好的题目！\n\n## classic0\n\n#### 题干\n\n小Z用C语言编写了一个最简单的密码系统，里面都采用的是最简单的古典加密。但是他的源程序不幸泄露，聪明的你能否解读他采用的算法并进行解密？flag格式为actf{***}\n\n#### 考察点\n\n凯撒，异或，编程能力，生日字典\n\n#### hint\n\n字典\n\n#### writeup\n\n题目给出了密文还有一个生日字典加密后的加密脚本压缩包。如果你够厉害，当然你可以直接根据密文来解啦，不过就是两种加密合在一起，不是简单凯撒，所以有一定难度。\n\n不过如果你知道生日字典攻击的话，不妨拿个工具跑一下，那么很快就可以得到结果了，最后写出解题代码：\n\n```c\n#include<stdio.h>\n\nchar flag[25] = {\"Ygvdmq[lYate[elghqvakl}\"};\n\nint main()\n{\n\tint i;\n\tfor(i=0;i<25;i++)\n\t{\n\t\tflag[i] ^= 0x7;\n        flag[i] += 3;\n\t\tprintf(\"%c\",flag[i]);\n\t}\n}\n\n```\n\n注意，有个地方的字符不是空格也不是'.'！不过你是可以用winhex或者010editor看到它具体的值的，这个值是7f。\n\n#### 附：加密源代码\n\n```c\n#include<stdio.h>\n\nchar flag[25] = {\"actf{my_naive_encrytion}\"};\n\nint main()\n{\n\tint i;\n\tfor(i=0;i<25;i++)\n\t{\n\t\tflag[i] -= 3;\n\t\tflag[i] ^= 0x7;\n\t\tprintf(\"%c\",flag[i]);\n\t}\n\treturn 0; \n}\n\n```\n\n## classic1\n\n#### 题干\n\n维吉尼亚加密是极其经典的古典密码，flag格式为actf{}，明文中的字母均为小写\n\n#### 考察点\n\n键盘密码，维吉尼亚密码\n\n#### hint\n\n1.谜底就在谜面上\n\n#### writeup\n\n压缩包密码是一个键盘密码，稍微熟悉键盘的同学低下头看看，然后再看到密文里面“,.;”这一连串字符，应该会有些感觉。这些密文里面都是一个圈这样围在一起的，里面那个就是明文。key为circle。\n\n这里的维吉尼亚密码，由于密文比较短，频率分析不管用，看一下题干，flag的格式已经给出，稍微尝试一下，得到加密密钥的值为sp，然后即可解决。\n\n#### 附：加密源代码\n\n```c\n#include<stdio.h>\n#include<iostream>\n\n#define CYPHERLEN 31 \n#define KEYLEN 2\n\nusing namespace std;\n\nint main()\n{\n\tchar str[CYPHERLEN]={0};\n\tchar key[3]=\"sp\"; \n\tint i; \n\tfor(i=0;i<CYPHERLEN;i++)\n\t{\n\t\tscanf(\"%c\",&str[i]);\n\t}\n\tfor(i=0;i<CYPHERLEN;i++)\n\t{\n\t\tif(isupper(str[i])||islower(str[i]))\n\t\t{\n\t\t\tstr[i]=toupper(str[i]);\n\t\t\tstr[i]-='A';\n\t\t\tstr[i]+=(key[i%KEYLEN]-'a');\n\t\t\tstr[i]%=26;\n\t\t\tstr[i]+='A';\n\t\t}\n\t}\n\tfor(i=0;i<CYPHERLEN;i++)\n\t{\n\t\t\tprintf(\"%c\",str[i]);\n\t}\n\treturn 0;\n } \n```\n\n## des-mailbox\n\n#### 题干\n\n小Z自创了一套DES加密方法。他悄悄告诉你，这是你们传递秘密的信箱，所以想要获得他的秘密很简单，动动小脑袋瓜和小手指头就可以啦！flag格式为actf{***}\n\n#### 考察点\n\nC语言强制转换，DES相关编程\n\n#### hints\n\n1.type casting\n2.In fact, that is not completely how DES work. We divided the process into several steps.\n3.the keys are just overthere.\n\n#### writeup\n\n首先要知道这个是一个强制转换，把字符转为浮点数，我们用puts即可把浮点数转换为字符，解出key。\n\n```c\n#include<stdio.h>\n\n\nint main()\n{\n\tfloat f[]={\n\t72143238992041641000000.000000,\n    77135357178006504000000000000000.000000,\n    1125868345616435400000000.000000,\n    67378029765916820000000.000000,\n    75553486092184703000000000000.000000,\n    4397611913739958700000.000000,\n    76209378028621039000000000000000.000000\n    };\n\tputs((char*)f);\n } \n\n```\n\n然后就可以看到des.py，里面子密钥都给出了，解密不就只是安装一个密码学包然后再用回密钥解密就行了嘛。\n\n```python\nimport pyDes\nimport base64\nfrom FLAG import flag\ndeskey = \"********\"\nDES = pyDes.des(deskey)\nDES.setMode('ECB')\nDES.Kn = [\n\t\t\t[1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0],\n\t\t\t[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0], \n\t\t\t[0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0],\n\t\t\t[1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1], \n\t\t\t[0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n\t\t\t[0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0],\n\t\t\t[0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],\n\t\t\t[0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0],\n\t\t\t[1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0],\n\t\t\t[0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0],\n\t\t\t[0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1],\n\t\t\t[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0],\n\t\t\t[1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0],\n\t\t\t[1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1],\n\t\t\t[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1],\n\t\t\t[1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1]\n\t\t]\ncipher_list = b'vrkgBqeK7+h7mPyWujP8r5FqH5yyVlqv0CXudqoNHVAVdNO8ML4lM4zgez7weQXo'\nprint(DES.decrypt(base64.b64decode(cipher_list)))\n```\n\n#### 出题源代码\n\n**强制类型转换**（这个思路要感谢DJ学长，最初的出处请见afctf第一届初赛，我在此基础上对代码做了一些调整）\n\n```c\n#include <stdio.h> \nchar flag[32]=\"Interestring Idea to encrypt\";\n \nint main() \n{    \n\tfor(int i=0;i<7;++i)\n\t{        \n\t\tprintf(\"%20f\\n\",*(float*)(flag+i*4));    \n\t} \n\tprintf(\"%20f\\n\",*(float*)(\"\"))  ; \n\treturn 0; \n}\n\n```\n\n**des加密代码**（这个思路主要来自于湖湘杯2019）\n\n```python\nimport pyDes\nimport base64\nfrom FLAG import flag\ndeskey = \"********\"\nDES = pyDes.des(deskey)\nDES.setMode('ECB')\nDES.Kn = [\n\t\t\t[1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0],\n\t\t\t[1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0], \n\t\t\t[0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 0],\n\t\t\t[1, 1, 0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1], \n\t\t\t[0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],\n\t\t\t[0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0],\n\t\t\t[0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0],\n\t\t\t[0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0],\n\t\t\t[1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0],\n\t\t\t[0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0],\n\t\t\t[0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1],\n\t\t\t[0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0],\n\t\t\t[1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 1, 0, 0],\n\t\t\t[1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1],\n\t\t\t[1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1],\n\t\t\t[1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1]\n\t\t]\ncipher_list = base64.b64encode(DES.encrypt(flag))\n#b'vrkgBqeK7+h7mPyWujP8r5FqH5yyVlqv0CXudqoNHVAVdNO8ML4lM4zgez7weQXo'\n\n```\n\n## music\n\n注：由于考察点重复，最后关头我把题目去掉了\n\n#### 题干\n\n小Z喜欢听音乐，可是他不是VIP，也不想花钱下载音乐，可是你却在无意中发现了他拥有大量的音乐资源。试问，他是怎么做到的？flag格式为actf{***}\n\n#### 考察点\n\n音频解密（接近于杂项）\n\n灵感来源于学长分享的一片文章，我还对这篇文章提出了一些改进（即批量音频解密），然后把原文和改进后的文章一起发到了公众号“中南极光网安实验室”上。\n\n#### hint\n\n1.当你欣赏音乐的时候，记得打开文件看看哦\n\n#### writeup\n\n这道题其实是出自我的那篇推送文章的。自从XX音乐被爆只采用简单的异或加密以后，我就获得和很多首好听的歌曲。当然，这次的密钥不是0xa3，但分析方法一样。用010editor等十六进制编辑工具打开文件，看到文件里面大部分值为0x36，所以考虑到密钥的值为0x36，所以异或一下。\n\nflag不在音频里面，为了表彰一下大家，只需要去文件里面搜一下字符串即可。然后在文章结尾找到的是一串base64，解密一下即可。\n\n#### 题目源代码\n\n本次题目的编写没有用脚本，用的是010editor自带的异或功能。不过想要看批量解密的话，可以去公众号看，博客已经在路上了。\n\n## rsa0\n\n#### 题干\n\n看看rsa的资料，学学python吧，这种简单题绝对不卡你！flag格式为actf{***}\n\n#### 考察点\n\n压缩包伪加密，RSA基础知识与参数\n\n#### hint\n\n1.搞清楚各个参数的意义\n\n#### writeup\n\n都说了是压缩包伪加密，解决一下应该不难。\n\n然后里面是最简单的rsa了，看一下资料应该能解决。\n\n脚本\n\n```python\nimport gmpy2\nfrom Cryptodome.Util.number import *\np = 9018588066434206377240277162476739271386240173088676526295315163990968347022922841299128274551482926490908399237153883494964743436193853978459947060210411\nq = 7547005673877738257835729760037765213340036696350766324229143613179932145122130685778504062410137043635958208805698698169847293520149572605026492751740223\ne = 65537\nc = 50996206925961019415256003394743594106061473865032792073035954925875056079762626648452348856255575840166640519334862690063949316515750256545937498213476286637455803452890781264446030732369871044870359838568618176586206041055000297981733272816089806014400846392307742065559331874972274844992047849472203390350\nphi = (p-1)*(q-1)\nn = p*q\nd = gmpy2.invert(e,phi)\nm = pow(c,d,n)\nprint (long_to_bytes(m))\n\n```\n\n#### 出题源代码\n\n```python\nfrom Cryptodome.Util.number import *\nimport random\n\nFLAG=#hidden, please solve it\nflag=int.from_bytes(FLAG,byteorder = 'big')\n\n\np=getPrime(512)\nq=getPrime(512)\n\nprint(p)\nprint(q)\nN=p*q\ne=65537\nenc = pow(flag,e,N)\nprint (enc)\n\n```\n\n## baby-aes\n\n#### 题干\n\nAES是一种十分高效安全的对称加密方式，在现代密码学中有着举足轻重的地位。小Z对此很放心，于是就写了一个脚本用AES加密，你能获得他的明文嘛？flag格式为actf{***}\n\n#### 考察点\n\naes中的弱点（密钥），密钥、iv的作用，爆破\n\n#### hint\n\n1.现代密码的薄弱点在哪里\n\n#### writeup\n\n注意一下，这里的key和iv，虽说key是32字节，但是存在很多重复的现象。而且为了降低运算复杂度，我把key和iv的异或值给了处理。所以，我们只需要爆破即可，时间复杂度为256的二次方=65526次\n\n脚本如下（时间不长，就懒得写break了）\n\n```python\nfrom Cryptodome.Cipher import AES\nimport os\nfrom Cryptodome.Util.number import *\nimport gmpy2\n\ndef main():\n    enc_flag=b'\\x8c-\\xcd\\xde\\xa7\\xe9\\x7f.b\\x8aKs\\xf1\\xba\\xc75\\xc4d\\x13\\x07\\xac\\xa4&\\xd6\\x91\\xfe\\xf3\\x14\\x10|\\xf8p'\n    xornum=91144196586662942563895769614300232343026691029427747065707381728622849079757\n    for i in range(0,256):      \n        for j in range(0,256):\n             num=i*256+j\n             subkey=long_to_bytes(num).ljust(2,b'\\x00')\n             key=subkey*16\n             iv=long_to_bytes(bytes_to_long(key)^xornum)[-16:].ljust(16,b'\\x00')\n             aes=AES.new(key,AES.MODE_CBC,iv)\n             flag = aes.decrypt(enc_flag)\n             if(flag[:4]==b'actf'):\n                 print(flag)\n\nif __name__==\"__main__\":\n    main()\n\n```\n\n#### 出题源代码\n\n```python\nfrom Cryptodome.Cipher import AES\nimport os\nimport gmpy2\nfrom flag import FLAG\nfrom Cryptodome.Util.number import *\n\ndef main():\n    key=os.urandom(2)*16\n    iv=os.urandom(16)\n    print(bytes_to_long(key)^bytes_to_long(iv))\n    aes=AES.new(key,AES.MODE_CBC,iv)\n    enc_flag = aes.encrypt(FLAG)\n    print(key)\n    print(iv)\n    print(enc_flag)\n#91144196586662942563895769614300232343026691029427747065707381728622849079757\n#b'\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81\\xc9\\x81'\n#b'\\x87lQbI0\\xfc\\xe6\\xaa\\x05P\\xb1\\x01\\xd1pL'\n#b'\\x8c-\\xcd\\xde\\xa7\\xe9\\x7f.b\\x8aKs\\xf1\\xba\\xc75\\xc4d\\x13\\x07\\xac\\xa4&\\xd6\\x91\\xfe\\xf3\\x14\\x10|\\xf8p'\nif __name__==\"__main__\":\n    main()\n\n```\n\n## rsa3\n\n#### 题干\n\n安全的密码算法，往往找不到任何的规律和联系。小Z由于学艺不精，无意中设计了一套极其危险的密码算法，你能帮忙破解一下这个密码算法中的秘密嘛？flag格式为actf{***}\n\n#### 考察点\n\n经典费马分解\n\n#### hint\n\n1.RSA常见的攻击方式\n\n#### writeup\n\n其实这道题和省赛拿到没做出来的题目考点是一样的，所以那次省赛我已经有脚本了，但是省赛题目不应该这么出，怎么到了最后变成了电脑性能的较量。。\n\n我觉得要考费马分解应该这样出：大家可以看到，题目中的两个素数之间相隔很近，这就给费马分解提供了机会（虽然我不知道网上有没有像我一样用这个next_prime这个函数的，但是意思应该也会相近），大家可以上网查查相关资料，省赛的时候一个学弟的脚本挺不错的，还多线程。但是我当时候的脚本和他写得不一样，当然也能解出来，不过哪时间复杂度可能稍慢一些，现在给出我的脚本：\n\n```python\nimport gmpy2\nfrom Cryptodome.Util.number import *\nn=177606504836499246970959030226871608885969321778211051080524634084516973331441644993898029573612290095853069264036530459253652875586267946877831055147546910227100566496658148381834683037366134553848011903251252726474047661274223137727688689535823533046778793131902143444408735610821167838717488859902242863683\nc=1457390378511382354771000540945361168984775052693073641682375071407490851289703070905749525830483035988737117653971428424612332020925926617395558868160380601912498299922825914229510166957910451841730028919883807634489834128830801407228447221775264711349928156290102782374379406719292116047581560530382210049\ne=65537\n\nfor b in range(0,10000):\n    a=gmpy2.iroot(n+b*b,2)[0]\n    if(a*a-b*b==n):\n        p=a+b\n        q=a-b\n        break;\nassert(p*q==n)\nphi = (p-1)*(q-1)\nd = gmpy2.invert(e,phi)\nm = pow(c,d,n)\nprint (long_to_bytes(m))\n\n```\n\n我通过修改学弟的脚本也可以解决这道题。\n\n```python\nimport threading\n\ndef isqrt(n):\n    x = n\n    y = (x + n // x) // 2\n    while y < x:\n      x = y\n      y = (x + n // x) // 2\n    return x\n\ndef Fermat(num, x):\n    y2 = x*x - num;\n    y = isqrt(y2);\n    if y*y == y2:\n        print([x+y, x-y]);\n\nif __name__ == \"__main__\":\n    num = int(input('n='))\n    x = isqrt(num)\n    if x*x < num:\n        x += 1\n    i = 1\n    while(i < 1e20):\n        threads = []\n        for j in range(40):\n            t = threading.Thread(target = Fermat, args = (num, x))\n            i += 1\n            x += 1\n            threads.append(t)\n        for t in threads:\n            t.start()\n        for t in threads:\n            t.join()\n```\n\n用这段代码可以在短时间内解出p,q。\n\n#### 出题源代码\n\n```python\nfrom flag import FLAG\nfrom Cryptodome.Util.number import *\nimport gmpy2\nimport random\n\ne=65537\np = getPrime(512)\nq = int(gmpy2.next_prime(p))\nn = p*q\nm = bytes_to_long(FLAG)\nc = pow(m,e,n)\nprint(n)\nprint(c)\n\n```\n\n## TinySPN(by [DJ学长](https://csuwangj.github.io/))\n注：出题方向是我提出的，但是这里面的题干，源代码和解题脚本都是[DJ学长](https://csuwangj.github.io/) 写的，我只负责把它放到服务器上，并且写出交互代码。\n\n#### 题干\n\nSPN is a classical design patter in cryptography.\n\nnc 47.103.117.169 10003\n\nflag格式为flag{***}\n\n#### 考察点\n\n线性/差分密码分析，交互\n\n#### hint\n\n1. what is SBOX?\n2. why can't we replace SBOX in cipher?\n\n#### writeup\n\n###### TL;DR\n\nattack simple SPN by chosen-plaintext attack, use linear cryptanalysis or differential cryptanalysis will break it. [exp](exp.py) use linear cryptanalysis.\n\n###### Detail\n\nbecause this SPN cipher is so simple, so we just need following steps.\n\n1. get LAT, like [example](lat.py)(Linear Approximation Table).\n2. find one path with high bias.\n3. collecting enough plaintext-cipher pairs.\n4. extracting key from pairs.(check exp for more details).([linear_cryptanalysis.py](linear_cryptanalysis.py) is a example of this step, but code is like a shit so you'd better forget it.)\n5. decrypt flag.\n\n[test.py](test.py) is my test data, ignore it.\n\nif SBOX is so good that can't break it, record it and replay exp~\n\n[send me](mailto:CSUwangj@protonmail.com) this SBOX so that I can post it~\n\n###### exp\n\n```python\n#!/usr/bin/python3\n\nfrom typing import List, Tuple\nfrom tqdm import tqdm\n# import test\n# import pysnooper\nfrom util import doxor, doin, trans_inv, SZ\nfrom binascii import unhexlify\nfrom codecs import encode\nimport random\nimport pwn\n\ndef maskeq(a: int, b: int) -> bool:\n    c: int = 0\n    while b > 0:\n        if b&1:\n            c ^= (a&1)\n        b //= 2\n        a //= 2\n    return c==0\n\ndef LAT(sbox: List[int]) -> List[List[int]]:\n    count = []\n    for row in tqdm(range(256), desc=\"compute LAT\"):\n        count.append([])\n        for col in range(256):\n            cnt = -128\n            bitmask = (row << 8) | col\n            for i in range(256):\n                if maskeq((i << 8) | sbox[i],  bitmask):\n                    cnt += 1\n            count[row].append(abs(cnt))\n        count[row].append(row)\n    return count\n\ndef check(num: int, bitmask: int) -> bool:\n    a = 0\n    while bitmask > 0:\n        if bitmask & 1 == 1:\n            a ^= num & 1\n        bitmask //= 2\n        num //= 2\n    return a == 0\n\ndef check_key(text_pairs: List[Tuple[int, int]], sbox: List[int], key: int, mask: int) -> int:\n    cnt = 0\n    for text_pair in text_pairs:\n        (plain, cipher) = text_pair\n        mid = cipher ^ key\n        mid = sbox[mid] \n        if check((plain << 8) | mid, mask):\n            cnt += 1\n    return cnt\n\n# @pysnooper.snoop()\ndef decrypt(sbox, sboxi, ct, k):\n    pt = ''\n    for i in range(0, len(ct), SZ):\n        res = decrypt_block(sbox, sboxi, ct[i:i+SZ], k)\n        pt += ''.join(map(chr, res))\n    return pt\n\ndef decrypt_block(sbox, sboxi, pt, ks):\n    cur = doxor(pt, ks[SZ:])\n    cur = list(map(lambda x:sbox[x], cur))\n    cur = trans_inv(cur)\n    cur = list(map(lambda x:sboxi[x], cur))\n    cur = doxor(cur, ks[:SZ])\n    return cur\n\ndef compute_frontkey(sbox, sboxi, pt: List[int], ct: List[int], lastkey: List[int]) -> List[int]:\n    cur = doxor(ct, lastkey)\n    cur = list(map(lambda x:sbox[x], cur))\n    cur = trans_inv(cur)\n    cur = list(map(lambda x:sboxi[x], cur))\n    return doxor(cur, pt)\n\ndef doin(x):\n    return list(unhexlify(x))\n\ndef doout(x):\n    tmp = ''.join(map(chr, x))\n    return (encode(tmp.encode(), 'hex')).decode()\n\ndef main():\n    # pwn.context.log_level = \"DEBUG\"\n    # io = pwn.remote(\"192.168.16.128\", 9999)\n    io = pwn.process(\"../src/server.py\")\n    sbox_str = io.readline()\n    sbox: List[int] = list(map(int, sbox_str[1:-2].split(b\",\")))\n    sboxi: List[int] = []\n    for i in range(256):\n        sboxi.append(sbox.index(i))\n    # print(sbox)\n    flag_ct = doin(io.readline().strip())\n    # print(flag_ct)\n    pts: List[str] = []#test.pt\n    cts: List[str] = []#test.ct\n    for i in tqdm(range(2048), desc=\"collect plaintext-cipher paits\"):\n        pt = random.randint(0, (1<<64)-1)\n        pt = \"{:016x}\".format(pt)\n        io.sendline(pt)\n        ct = io.readline().strip()\n        pts.append(pt)\n        cts.append(ct)\n    # print(\"pt0: {}\".format(pts[0]))\n    # print(\"ct0: {}\".format(cts[0]))\n    lat = LAT(sbox)\n    ptx = list(map(lambda x:(int(x[0:2], 16)), pts))\n    key = []\n    for i in range(8):\n        ctx = list(map(lambda x:(int(x[i*2:i*2+2], 16)), cts))\n        lat.sort(key=lambda x:x[(1<<(7-i))], reverse=True)\n        # print(\"{}th byte is for LT{}\".format(i, lat[0][256]))\n        res = []\n        for k in tqdm(range(256), desc=\"compute {}th byte of key\".format(i+9)):\n            res.append((k, abs(check_key(zip(ptx, ctx), sbox, k, (lat[0][256]<<8) |0b10000000)-(len(pts)//2))))\n        res.sort(key=lambda x: x[1], reverse=True)\n        key.append(res[0][0])\n        # print(res)\n        # print(\"{}th key is {:02x}\".format(i+9, res[0][0]))\n    pt1 = doin(pts[0])\n    ct1 = doin(cts[0])\n    key = compute_frontkey(sbox, sboxi, pt1, ct1, key) + key\n    print(\"computed key: {}\".format(doout(key)))\n    # print(key)\n    ans = decrypt(sbox, sboxi, flag_ct, key)\n    if ord(ans[-1]) < 9:\n        ans = ans[:-ord(ans[-1])]\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\n```\n\n#### 题目源代码\n\n```python\n#!/usr/bin/python3\n\nimport os\nfrom binascii import hexlify, unhexlify\nimport Crypto.Random.random as random\nfrom secret import flag\n\nSZ = 8\n\nsbox = list(range(256))\nrandom.shuffle(sbox)\nsboxi = []\nfor i in range(256):\n    sboxi.append(sbox.index(i))\n\ndef doxor(l1,l2):\n    return [x[0]^x[1] for x in zip(l1,l2)]\n\ndef trans(blk):\n    res = []\n    for k in range(0, SZ, 8):\n        bits = [bin(x)[2:].rjust(8,'0') for x in blk[k:k+8]]\n        for i in range(8):\n            res.append(int(''.join([x[i] for x in bits]),2))\n    return res\n\ndef encrypt_block(pt, ks):\n    cur = doxor(pt, ks[:SZ])\n    cur = [sbox[x] for x in cur]\n    cur = trans(cur)\n    cur = [sboxi[x] for x in cur]\n    cur = doxor(cur, ks[SZ:])\n    return cur\n\ndef encrypt(pt, k):\n    x = 0 if len(pt)%SZ==0 else (SZ-len(pt)%SZ)\n    pt += [x]*x\n    ct = ''\n    for i in range(0, len(pt), SZ):\n        res = encrypt_block([x for x in pt[i:i+SZ]], k)\n        ct += ''.join([\"{:02x}\".format(xx) for xx in res])\n    return ct\n\ndef doout(x):\n    if len(x) % 16:\n        x = (16 - len(x) % 16) * \"0\" + x\n    return x\n\ndef doin(x):\n    return list(unhexlify(x))\n\ndef genkeys():\n    return list(os.urandom(2*SZ))\n\nif __name__ == \"__main__\":\n    print(sbox)\n    key = genkeys()\n    ct = encrypt(flag, key)\n    print(ct)\n    while True:\n        pt = doin(input())\n        print(doout(encrypt(pt, key)))\n```\n\n","tags":["project","competition","auroralab"],"categories":["auroralab"]},{"title":"about me","url":"/2020/02/15/about-me/","content":"\n说来惭愧，写了很多的日记，也写过几篇可以充当作业或者领稿费的小文章，也发了很多的说说和pyq，但是发博客确是第一次。在朋友们都已经创办了属于自己的公众号，博客或者专刊的时候，我却才在blog上发表我的第一篇文章。现在，我愿意把我自己的所思所感已经之前写过的一部分日记形成文字，以展现一个真实的自己。\n\n为什么我忽然想到要写博客呢？\n\n其实，我在github上也算是个新手，但陆陆续续的参与了一些项目，并且承办了这次新人赛上密码学大部分的出题工作以后，每次有人来问我的github网址邀请我的时候，我不禁感到不好意思。怎么能给别人一个空白的github网址呢，感觉自己就像圈外人一样，人家计算机爱好者都在这里讨论问题，合作完成项目，而我虽然有兴趣，但是行动上却没有跟上来。所以我觉得得抓紧完善打理一下自己的博客，“打扫干净房子再请客”，所以就连着一晚简简单单的弄了一个博客。当然文章还是会继续更的，以前的日记浏览了一下，还是有不少能原封不动的发上来，不过还是要再考虑一下配图这些问题吧（抱歉这篇文章就临时配一张测试配图吧，关于配图的上传调试了很久，希望没有问题。祝大家2020年能身体健康，万事如意，学有所成！)![2020的祝福](2020.jpg)\n\n另外，我觉得我有必要做一个生产者，写点有意义的所思所感，也可以分享一些技术文章，来做出自己一份微薄的贡献。就像是当时触动我的那个人是这么说的，“ 许许多多的人曾用他们的光芒照亮了我，我也愿接下火炬继续燃烧。记录日常所思所感，是留给未来的诗歌与火光。 ”我觉得，需要把这些光芒传递下去，让火炬继续燃烧。\n\n---\n\n4.30最新动态：\n\n这个blog建立到现在，也更新了大约有15次了。其实实践无处不在，每天的作业和实验都是一个难得的动手机会。但是，做作业，多多少少包含着一些被动完成任务的心态。所以博客上的文章，我都精挑细选，着重展现我充分调动自己的能动性来完成的课外项目和选做任务，我觉得只有这样，才能体现出更全面的自己。当然，有空的话，我会展示一下之前算法和数据结构中编写的所有程序，密码学的编程脚本，以及天梯赛备战时在PAT平台全部通过的L1和L2的代码。希望自己能更加多的动手实践，争取更上一层楼！\n\n本来还想呈现几篇日记，但目前的记录太散了，暂时整理不了，就先更一些技术类文章，日记内容稍微剧透一些，大概可能会涉及如下话题——\n\n1.不知，不愠。\n\n2.包容与理解。\n\n3.理智与现实。\n\n4.看淡外部环境的影响，保持心态平和，勇敢地与自己独处。\n\n5.我的生死观和时间观。\n\n这些话题我在日记里面是写过的，但是能不能整理好发出来，就不一定了。","tags":["introduction","diary"],"categories":["diary"]}]